// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2021 The Khronos Group Inc.
** Copyright (c) 2019-2021 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_HANDLES_HPP_
#define OPENXR_HANDLES_HPP_
/**
 * @file
 * @brief Declares wrappers for OpenXR handle types, with function calls transformed into methods,
 * as well as free functions for those few that do not take a handle as their first argument.
 *
 * Does not include the implementations of the functions: for that, see @ref openxr_method_impls.hpp
 * @ingroup handles
 * @ingroup api_free_functions
 */

#include "openxr_atoms.hpp"
#include "openxr_enums.hpp"
#include "openxr_exceptions.hpp"
#include "openxr_flags.hpp"
#include "openxr_handles_forward.hpp"
#include "openxr_structs_forward.hpp"
#include "openxr_time.hpp"
#include "openxr_dispatch_traits.hpp"

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#include <vector>
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#if !defined(OPENXR_HPP_INLINE)
#if defined(__clang___)
#if __has_attribute(always_inline)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#else
#define OPENXR_HPP_INLINE inline
#endif
#elif defined(__GNUC__)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#elif defined(_MSC_VER)
#define OPENXR_HPP_INLINE inline
#else
#define OPENXR_HPP_INLINE inline
#endif
#endif  // !OPENXR_HPP_INLINE

#if !defined(OPENXR_HPP_CONSTEXPR)
#if defined(_MSC_VER) && (_MSC_VER <= 1800)
#define OPENXR_HPP_CONSTEXPR
#else
#define OPENXR_HPP_CONSTEXPR constexpr
#endif
#endif  // !OPENXR_HPP_CONSTEXPR

#if !defined(OPENXR_HPP_SWITCH_CONSTEXPR)
//! @todo set this to constexpr in c++14
#define OPENXR_HPP_SWITCH_CONSTEXPR
#endif  // !OPENXR_HPP_SWITCH_CONSTEXPR

// 32-bit OpenXR is not typesafe for handles, so don't allow copy constructors
// on this platform by default. To enable this feature on 32-bit platforms
// please define OPENXR_HPP_TYPESAFE_CONVERSION
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__)) || \
    defined(_M_X64) || defined(__ia64) || defined(_M_IA64) || defined(__aarch64__) ||       \
    defined(__powerpc64__)
#if !defined(OPENXR_HPP_TYPESAFE_CONVERSION)
#define OPENXR_HPP_TYPESAFE_CONVERSION
#endif
#endif

#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
#if !defined(OPENXR_HPP_TYPESAFE_EXPLICIT)
#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
#define OPENXR_HPP_TYPESAFE_EXPLICIT
#else
#define OPENXR_HPP_TYPESAFE_EXPLICIT explicit
#endif
#endif  // !OPENXR_HPP_TYPESAFE_EXPLICIT

#ifdef OPENXR_HPP_DOXYGEN
#define OPENXR_HPP_NO_DEFAULT_DISPATCH
#define OPENXR_HPP_NO_SMART_HANDLE
#undef OPENXR_HPP_NO_SMART_HANDLE
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER DispatchLoaderStatic()
#undef OPENXR_HPP_DEFAULT_CORE_DISPATCHER
#define OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#undef OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#endif

/*!
 * @def OPENXR_HPP_TYPESAFE_CONVERSION
 * @brief Whether to force conversion/implicit constructors.
 *
 * Enabled by default on 64-bit platforms.
 * 32-bit OpenXR is not typesafe for handles, so this is disabled on such platforms by default.
 * To enable this feature on 32-bit platforms please define `OPENXR_HPP_TYPESAFE_CONVERSION`
 *
 * @ingroup config
 */
/*!
 * @defgroup config_dispatch Default dispatch configuration
 * @ingroup config
 */
/*!
 * @def OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @brief Define to disable default dispatch arguments.
 * @see OPENXR_HPP_DEFAULT_CORE_DISPATCHER, OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_CORE_DISPATCHER
 * @brief Define to the expression you'd like to use as the default dispatcher for core API
 * functions.
 *
 * Defaults to `DispatchLoaderStatic()` unless `OPENXR_HPP_NO_DEFAULT_DISPATCH` is defined.
 *
 * If both this and `OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE` are defined (by you, or by default if
 * `OPENXR_HPP_NO_DEFAULT_DISPATCH` is not defined), `OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG` will be
 * defined to `= OPENXR_HPP_DEFAULT_CORE_DISPATCHER`.
 *
 * @see DispatchLoaderStatic, OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE,
 * OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
 * @brief Define to the type of the expression you'd like to use as the default dispatcher for core
 * API functions.
 *
 * This will be used as the default type parameter in functions where
 * `OPENXR_HPP_DEFAULT_CORE_DISPATCHER` will be the default argument.
 *
 * Defaults to `DispatchLoaderStatic` unless `OPENXR_HPP_NO_DEFAULT_DISPATCH` is defined.
 *
 * If both this and `OPENXR_HPP_DEFAULT_CORE_DISPATCHER` are defined (by you, or by default if
 * `OPENXR_HPP_NO_DEFAULT_DISPATCH` is not defined), `OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG`
 * will be defined to `= OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE`.
 *
 * @see DispatchLoaderStatic, OPENXR_HPP_DEFAULT_CORE_DISPATCHER, OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
 * @brief Define to the expression you'd like to use as the default dispatcher for extension API
 * functions.
 *
 * This has no default value: by default, you need to provide a dispatcher explicitly for extension
 * functions. If you define this and `OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE`, however,
 * `OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG` will be set to `=` and your definition.
 *
 * A globally-accessible instance of xr::DispatchLoaderDynamic would be suitable.
 *
 * @ingroup config_dispatch
 */

/*!
 * @def OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE
 * @brief Define to the type expression you'd like to use as the type of the default dispatcher for
 * extension API functions.
 *
 * This has no default value: by default, you need to provide a dispatcher explicitly for extension
 * functions. If you define this and `OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER`, however,
 * `OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG` will be set to `=` and your definition.
 *
 * xr::DispatchLoaderDynamic would be suitable.
 *
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DISABLE_ENHANCED_MODE
 * @brief Define in order to disable the more complete C++ projections of OpenXR methods, leaving
 * only the most C-like prototypes behind.
 *
 * This will disable returning of output parameters (directly and through ReturnType pairs),
 * wrapping of two-call-idiom methods, functions creating `Unique` handles with ownership, etc.
 * It slightly reduces the number of files included.
 *
 * @ingroup config
 */

/*!
 * @def OPENXR_HPP_NO_SMART_HANDLE
 * @brief Define in order to disable the UniqueHandle-creating C++ method projections.
 *
 * Enhanced mode creation calls by default include a projection that returns a smart handle
 * representing unique ownership. Defining this macro will hide those methods.
 *
 * @see OPENXR_HPP_DISABLE_ENHANCED_MODE
 *
 * @ingroup config
 */

#ifndef OPENXR_HPP_NO_DEFAULT_DISPATCH

#if !defined(XR_NO_PROTOTYPES) && !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER) && \
    !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER DispatchLoaderStatic()
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE DispatchLoaderStatic
#include "openxr_dispatch_static.hpp"
#endif  // !defined(XR_NO_PROTOTYPES) && !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER)

#endif  // !OPENXR_HPP_NO_DEFAULT_DISPATCH

#if defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER) && defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG = OPENXR_HPP_DEFAULT_CORE_DISPATCHER
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG = OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
#endif

#if defined(OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER) && \
    defined(OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG = OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG = OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE
#endif

#ifndef OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG
#endif

namespace OPENXR_HPP_NAMESPACE {

/*!
 * @defgroup return_results Returning results
 * @brief Types used by API call wrappers to return output in a friendly, C++ manner.
 */

/*!
 * @brief Contains a Result enumerant and a returned value.
 *
 * Implicitly convertible to std::tuple<> so you can do `std::tie(result, value)
 * = callThatReturnsResultValue()`
 *
 * @ingroup return_results
 */
template <typename T>
struct ResultValue {
  ResultValue(Result r, T const& v) : result(r), value(v) {}

  ResultValue(Result r, T&& v) : result(r), value(std::move(v)) {}

  Result result;
  T value;

  operator std::tuple<Result&, T&>() { return std::tuple<Result&, T&>(result, value); }
  operator std::tuple<Result const&, T const&>() const {
    return std::tuple<Result const&, T const&>(result, value);
  }
};

}  // namespace OPENXR_HPP_NAMESPACE
namespace OPENXR_HPP_NAMESPACE {

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
// The generalization of std::string with user-specifiable allocator types.
template <typename Allocator = std::allocator<char>>
using string_with_allocator = std::basic_string<char, std::char_traits<char>, Allocator>;
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief Handle class - wrapping XrInstance without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstance>
 *
 * @xrentity{XrInstance}
 * @ingroup handles
 */
class Instance {
public:
  using Type = Instance;
  using RawHandleType = XrInstance;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Instance() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrInstance type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Instance(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Instance(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrInstance
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrInstance type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Instance value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Instance value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrInstance manipulation
   * @{
   */
  //! Gets the raw XrInstance value.
  OPENXR_HPP_CONSTEXPR XrInstance get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Instance yourHandle;
   * auto result = d.xrCreateInstance(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Instance&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetInstanceProcAddr wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInstanceProcAddr enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetInstanceProcAddr enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyInstance wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyInstance enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyInstance enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetInstanceProperties wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProperties(InstanceProperties& instanceProperties,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInstanceProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type InstanceProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<InstanceProperties> getInstanceProperties(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetInstanceProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type InstanceProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  InstanceProperties getInstanceProperties(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPollEvent wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollEvent>
   *
   * @xrentity{xrPollEvent}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pollEvent(EventDataBuffer& eventData,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPollEvent enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::EventUnavailable, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollEvent>
   *
   * @xrentity{xrPollEvent}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pollEvent(EventDataBuffer& eventData,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrResultToString wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrResultToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrResultToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStructureTypeToString wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStructureTypeToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStructureTypeToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSystem wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSystem(const SystemGetInfo& getInfo, SystemId systemId,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSystem enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SystemId
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SystemId> getSystem(const SystemGetInfo& getInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSystem enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SystemId
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SystemId getSystem(const SystemGetInfo& getInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSystemProperties wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSystemProperties(SystemId systemId, SystemProperties& properties,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSystemProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SystemProperties
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SystemProperties> getSystemProperties(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSystemProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SystemProperties
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SystemProperties getSystemProperties(SystemId systemId,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateEnvironmentBlendModes wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateEnvironmentBlendModes(SystemId systemId,
                                        ViewConfigurationType viewConfigurationType,
                                        uint32_t environmentBlendModeCapacityInput,
                                        uint32_t* environmentBlendModeCountOutput,
                                        XrEnvironmentBlendMode* environmentBlendModes,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<EnvironmentBlendMode, Allocator>> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<EnvironmentBlendMode, Allocator>> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<EnvironmentBlendMode, Allocator> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<EnvironmentBlendMode, Allocator> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSession(const SessionCreateInfo& createInfo, Session& session,
                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSession enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Session> createSession(const SessionCreateInfo& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSession enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Session createSession(const SessionCreateInfo& createInfo,
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSession wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>> createSessionUnique(
      const SessionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSession wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Session, impl::RemoveRefConst<Dispatch>> createSessionUnique(
      const SessionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateViewConfigurations wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateViewConfigurations(SystemId systemId, uint32_t viewConfigurationTypeCapacityInput,
                                     uint32_t* viewConfigurationTypeCountOutput,
                                     XrViewConfigurationType* viewConfigurationTypes,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationType, Allocator>> enumerateViewConfigurationsToVector(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationType, Allocator>> enumerateViewConfigurationsToVector(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationType, Allocator> enumerateViewConfigurationsToVector(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationType, Allocator> enumerateViewConfigurationsToVector(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetViewConfigurationProperties wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getViewConfigurationProperties(SystemId systemId,
                                        ViewConfigurationType viewConfigurationType,
                                        ViewConfigurationProperties& configurationProperties,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetViewConfigurationProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ViewConfigurationProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ViewConfigurationProperties> getViewConfigurationProperties(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetViewConfigurationProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ViewConfigurationProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ViewConfigurationProperties getViewConfigurationProperties(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateViewConfigurationViews wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateViewConfigurationViews(SystemId systemId,
                                         ViewConfigurationType viewConfigurationType,
                                         uint32_t viewCapacityInput, uint32_t* viewCountOutput,
                                         XrViewConfigurationView* views,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationView, Allocator>>
  enumerateViewConfigurationViewsToVector(SystemId systemId,
                                          ViewConfigurationType viewConfigurationType,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationView, Allocator>>
  enumerateViewConfigurationViewsToVector(SystemId systemId,
                                          ViewConfigurationType viewConfigurationType,
                                          Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationView, Allocator> enumerateViewConfigurationViewsToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationView, Allocator> enumerateViewConfigurationViewsToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrStringToPath wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stringToPath(const char* pathString, Path path,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStringToPath enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Path
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Path> stringToPath(const char* pathString,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStringToPath enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Path
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Path stringToPath(const char* pathString,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrPathToString wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pathToString(Path path, uint32_t bufferCapacityInput, uint32_t* bufferCountOutput,
                      char* buffer, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> pathToString(
      Path path, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> pathToString(Path path,
                                                             Allocator const& vectorAllocator,
                                                             Dispatch&& d) const;

#else
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> pathToString(
      Path path, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> pathToString(Path path, Allocator const& vectorAllocator,
                                                Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateActionSet wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createActionSet(const ActionSetCreateInfo& createInfo, ActionSet& actionSet,
                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSet enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionSet> createActionSet(const ActionSetCreateInfo& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSet enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionSet createActionSet(const ActionSetCreateInfo& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSet wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>> createActionSetUnique(
      const ActionSetCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSet wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>> createActionSetUnique(
      const ActionSetCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSuggestInteractionProfileBindings wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSuggestInteractionProfileBindings enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSuggestInteractionProfileBindings enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)

  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getOpenGLGraphicsRequirementsKHR(SystemId systemId,
                                          GraphicsRequirementsOpenGLKHR& graphicsRequirements,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsOpenGLKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsOpenGLKHR> getOpenGLGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsOpenGLKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsOpenGLKHR getOpenGLGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)

  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getOpenGLESGraphicsRequirementsKHR(SystemId systemId,
                                            GraphicsRequirementsOpenGLESKHR& graphicsRequirements,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsOpenGLESKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsOpenGLESKHR> getOpenGLESGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsOpenGLESKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsOpenGLESKHR getOpenGLESGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanInstanceExtensionsKHR(SystemId systemId, uint32_t bufferCapacityInput,
                                        uint32_t* bufferCountOutput, char* buffer,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanInstanceExtensionsKHR(SystemId systemId,
                                                                  Allocator const& vectorAllocator,
                                                                  Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanDeviceExtensionsKHR(SystemId systemId, uint32_t bufferCapacityInput,
                                      uint32_t* bufferCountOutput, char* buffer,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanDeviceExtensionsKHR(SystemId systemId,
                                                                Allocator const& vectorAllocator,
                                                                Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsDeviceKHR(SystemId systemId, VkInstance vkInstance,
                                    VkPhysicalDevice* vkPhysicalDevice,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VkPhysicalDevice> getVulkanGraphicsDeviceKHR(
      SystemId systemId, VkInstance vkInstance,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VkPhysicalDevice getVulkanGraphicsDeviceKHR(SystemId systemId, VkInstance vkInstance,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsRequirementsKHR(SystemId systemId,
                                          GraphicsRequirementsVulkanKHR& graphicsRequirements,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsVulkanKHR> getVulkanGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsVulkanKHR getVulkanGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)

  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getD3D11GraphicsRequirementsKHR(SystemId systemId,
                                         GraphicsRequirementsD3D11KHR& graphicsRequirements,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsD3D11KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsD3D11KHR> getD3D11GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsD3D11KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsD3D11KHR getD3D11GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)

  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getD3D12GraphicsRequirementsKHR(SystemId systemId,
                                         GraphicsRequirementsD3D12KHR& graphicsRequirements,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsD3D12KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsD3D12KHR> getD3D12GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsD3D12KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsD3D12KHR getD3D12GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertWin32PerformanceCounterToTimeKHR(const LARGE_INTEGER* performanceCounter, Time time,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Time> convertWin32PerformanceCounterToTimeKHR(
      const LARGE_INTEGER* performanceCounter,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Time convertWin32PerformanceCounterToTimeKHR(const LARGE_INTEGER* performanceCounter,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time

#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimeToWin32PerformanceCounterKHR(Time time, LARGE_INTEGER* performanceCounter,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type LARGE_INTEGER
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<LARGE_INTEGER> convertTimeToWin32PerformanceCounterKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type LARGE_INTEGER
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  LARGE_INTEGER convertTimeToWin32PerformanceCounterKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time

#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

  /*!
   * @brief xrConvertTimespecTimeToTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimespecTimeToTimeKHR(const struct timespec* timespecTime, Time time,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimespecTimeToTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Time> convertTimespecTimeToTimeKHR(
      const struct timespec* timespecTime, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimespecTimeToTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Time convertTimespecTimeToTimeKHR(const struct timespec* timespecTime,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time

#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

  /*!
   * @brief xrConvertTimeToTimespecTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimeToTimespecTimeKHR(Time time, struct timespec* timespecTime,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimeToTimespecTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type timespec
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<timespec> convertTimeToTimespecTimeKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimeToTimespecTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type timespec
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  timespec convertTimeToTimespecTimeKHR(Time time,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrCreateVulkanInstanceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                                 VkInstance* vulkanInstance, VkResult* vulkanResult,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVulkanInstanceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                                 VkInstance* vulkanInstance, VkResult* vulkanResult,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVulkanInstanceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                               VkInstance* vulkanInstance, VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrCreateVulkanDeviceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                               VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVulkanDeviceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                               VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVulkanDeviceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                             VkResult* vulkanResult,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsDevice2KHR(const VulkanGraphicsDeviceGetInfoKHR& getInfo,
                                     VkPhysicalDevice* vulkanPhysicalDevice,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VkPhysicalDevice> getVulkanGraphicsDevice2KHR(
      const VulkanGraphicsDeviceGetInfoKHR& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VkPhysicalDevice getVulkanGraphicsDevice2KHR(const VulkanGraphicsDeviceGetInfoKHR& getInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsRequirements2KHR(SystemId systemId,
                                           GraphicsRequirementsVulkanKHR& graphicsRequirements,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsVulkanKHR> getVulkanGraphicsRequirements2KHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsVulkanKHR getVulkanGraphicsRequirements2KHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createDebugUtilsMessengerEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                      DebugUtilsMessengerEXT& messenger,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<DebugUtilsMessengerEXT> createDebugUtilsMessengerEXT(
      const DebugUtilsMessengerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  DebugUtilsMessengerEXT createDebugUtilsMessengerEXT(
      const DebugUtilsMessengerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>>
  createDebugUtilsMessengerUniqueEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>
  createDebugUtilsMessengerUniqueEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                    const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                    const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                  XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                  const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

  //! @}
private:
  XrInstance val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrInstance) == sizeof(Instance),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrInstance from an Instance value.
 *
 * @found_by_adl
 * @see Instance::get()
 * @relates Instance
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrInstance get(Instance const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrInstance handle in a Instance (by reference).
 *
 * e.g.
 * ```
 * Instance yourHandle;
 * auto result = d.xrCreateInstance(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Instance
 */
static OPENXR_HPP_INLINE XrInstance* put(Instance& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Instance const& lhs,
                                                      Instance const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Instance const& lhs,
                                                      Instance const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Instance const& lhs,
                                                      XrInstance rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrInstance lhs,
                                                      Instance const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Instance const& lhs,
                                                      XrInstance rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrInstance lhs,
                                                      Instance const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Instance and nullptr: true if the handle is null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Instance: true if the handle is null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Instance const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Instance and nullptr: true if the handle is not null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Instance: true if the handle is not null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Instance const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSession without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSession>
 *
 * @xrentity{XrSession}
 * @ingroup handles
 */
class Session {
public:
  using Type = Session;
  using RawHandleType = XrSession;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Session() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSession type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Session(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Session(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSession
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSession type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Session value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Session value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSession manipulation
   * @{
   */
  //! Gets the raw XrSession value.
  OPENXR_HPP_CONSTEXPR XrSession get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Session yourHandle;
   * auto result = d.xrCreateSession(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Session&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateReferenceSpaces wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateReferenceSpaces(uint32_t spaceCapacityInput, uint32_t* spaceCountOutput,
                                  XrReferenceSpaceType* spaces,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReferenceSpaceType, Allocator>> enumerateReferenceSpacesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReferenceSpaceType, Allocator>> enumerateReferenceSpacesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReferenceSpaceType, Allocator> enumerateReferenceSpacesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReferenceSpaceType, Allocator> enumerateReferenceSpacesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateReferenceSpace wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo, Space& space,
                              Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateReferenceSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateReferenceSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateReferenceSpace wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createReferenceSpaceUnique(
      const ReferenceSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateReferenceSpace wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createReferenceSpaceUnique(
      const ReferenceSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetReferenceSpaceBoundsRect wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetReferenceSpaceBoundsRect>
   *
   * @xrentity{xrGetReferenceSpaceBoundsRect}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getReferenceSpaceBoundsRect(ReferenceSpaceType referenceSpaceType, Extent2Df& bounds,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetReferenceSpaceBoundsRect enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SpaceBoundsUnavailable, or an error code
   * if asserts are not active and exceptions are disabled)
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetReferenceSpaceBoundsRect>
   *
   * @xrentity{xrGetReferenceSpaceBoundsRect}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getReferenceSpaceBoundsRect(ReferenceSpaceType referenceSpaceType, Extent2Df& bounds,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateActionSpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createActionSpace(const ActionSpaceCreateInfo& createInfo, Space& space,
                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createActionSpace(const ActionSpaceCreateInfo& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createActionSpace(const ActionSpaceCreateInfo& createInfo,
                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSpace wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createActionSpaceUnique(
      const ActionSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSpace wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createActionSpaceUnique(
      const ActionSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateSwapchainFormats wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSwapchainFormats(uint32_t formatCapacityInput, uint32_t* formatCountOutput,
                                   int64_t* formats,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<int64_t, Allocator>> enumerateSwapchainFormatsToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<int64_t, Allocator>> enumerateSwapchainFormatsToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<int64_t, Allocator> enumerateSwapchainFormatsToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<int64_t, Allocator> enumerateSwapchainFormatsToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSwapchain wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSwapchain(const SwapchainCreateInfo& createInfo, Swapchain& swapchain,
                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchain enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Swapchain> createSwapchain(const SwapchainCreateInfo& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchain enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Swapchain createSwapchain(const SwapchainCreateInfo& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchain wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>> createSwapchainUnique(
      const SwapchainCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchain wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>> createSwapchainUnique(
      const SwapchainCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginSession(const SessionBeginInfo& beginInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrBeginSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginSession(const SessionBeginInfo& beginInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrBeginSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void beginSession(const SessionBeginInfo& beginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEndSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEndSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEndSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestExitSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestExitSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestExitSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrWaitFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitFrame(const FrameWaitInfo& frameWaitInfo, FrameState& frameState,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrWaitFrame enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FrameState
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FrameState> waitFrame(const FrameWaitInfo& frameWaitInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrWaitFrame enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FrameState
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FrameState waitFrame(const FrameWaitInfo& frameWaitInfo,
                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginFrame>
   *
   * @xrentity{xrBeginFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginFrame(const FrameBeginInfo& frameBeginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::FrameDiscarded, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginFrame>
   *
   * @xrentity{xrBeginFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginFrame(const FrameBeginInfo& frameBeginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEndFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endFrame(const FrameEndInfo& frameEndInfo,
                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEndFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endFrame(const FrameEndInfo& frameEndInfo,
                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEndFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void endFrame(const FrameEndInfo& frameEndInfo,
                Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrLocateViews wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateViews(const ViewLocateInfo& viewLocateInfo, XrViewState* viewState,
                     uint32_t viewCapacityInput, uint32_t* viewCountOutput, XrView* views,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<View, Allocator>> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, XrViewState* viewState,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<View, Allocator>> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, XrViewState* viewState,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<View, Allocator> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, XrViewState* viewState,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<View, Allocator> locateViewsToVector(const ViewLocateInfo& viewLocateInfo,
                                                   XrViewState* viewState,
                                                   Allocator const& vectorAllocator,
                                                   Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrAttachSessionActionSets wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrAttachSessionActionSets enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrAttachSessionActionSets enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetCurrentInteractionProfile wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getCurrentInteractionProfile(Path topLevelUserPath,
                                      InteractionProfileState& interactionProfile,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetCurrentInteractionProfile enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type InteractionProfileState
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<InteractionProfileState> getCurrentInteractionProfile(
      Path topLevelUserPath, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetCurrentInteractionProfile enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type InteractionProfileState
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  InteractionProfileState getCurrentInteractionProfile(
      Path topLevelUserPath, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateBoolean wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateBoolean(const ActionStateGetInfo& getInfo, ActionStateBoolean& state,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateBoolean enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateBoolean
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateBoolean> getActionStateBoolean(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateBoolean enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateBoolean
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateBoolean getActionStateBoolean(const ActionStateGetInfo& getInfo,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateFloat wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateFloat(const ActionStateGetInfo& getInfo, ActionStateFloat& state,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateFloat enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateFloat
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateFloat> getActionStateFloat(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateFloat enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateFloat
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateFloat getActionStateFloat(const ActionStateGetInfo& getInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateVector2f wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateVector2f(const ActionStateGetInfo& getInfo, ActionStateVector2f& state,
                                Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateVector2f enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateVector2f
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateVector2f> getActionStateVector2f(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateVector2f enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateVector2f
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateVector2f getActionStateVector2f(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStatePose wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStatePose(const ActionStateGetInfo& getInfo, ActionStatePose& state,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStatePose enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStatePose
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStatePose> getActionStatePose(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStatePose enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStatePose
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStatePose getActionStatePose(const ActionStateGetInfo& getInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSyncActions wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSyncActions>
   *
   * @xrentity{xrSyncActions}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result syncActions(const ActionsSyncInfo& syncInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSyncActions enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SessionNotFocused, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSyncActions>
   *
   * @xrentity{xrSyncActions}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result syncActions(const ActionsSyncInfo& syncInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateBoundSourcesForAction wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateBoundSourcesForAction(const BoundSourcesForActionEnumerateInfo& enumerateInfo,
                                        uint32_t sourceCapacityInput, uint32_t* sourceCountOutput,
                                        Path sources,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetInputSourceLocalizedName wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInputSourceLocalizedName(const InputSourceLocalizedNameGetInfo& getInfo,
                                     uint32_t bufferCapacityInput, uint32_t* bufferCountOutput,
                                     char* buffer,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrApplyHapticFeedback wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyHapticFeedback>
   *
   * @xrentity{xrApplyHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyHapticFeedback(const HapticActionInfo& hapticActionInfo,
                             const XrHapticBaseHeader* hapticFeedback,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrApplyHapticFeedback enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyHapticFeedback>
   *
   * @xrentity{xrApplyHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyHapticFeedback(const HapticActionInfo& hapticActionInfo,
                             const XrHapticBaseHeader* hapticFeedback,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrApplyHapticFeedback enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyHapticFeedback>
   *
   * @xrentity{xrApplyHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void applyHapticFeedback(const HapticActionInfo& hapticActionInfo,
                           const XrHapticBaseHeader* hapticFeedback,
                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStopHapticFeedback wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopHapticFeedback>
   *
   * @xrentity{xrStopHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopHapticFeedback(const HapticActionInfo& hapticActionInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStopHapticFeedback enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopHapticFeedback>
   *
   * @xrentity{xrStopHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopHapticFeedback(const HapticActionInfo& hapticActionInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStopHapticFeedback enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopHapticFeedback>
   *
   * @xrentity{xrStopHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void stopHapticFeedback(const HapticActionInfo& hapticActionInfo,
                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetAndroidApplicationThreadKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetAndroidApplicationThreadKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetAndroidApplicationThreadKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings

#ifdef XR_KHR_android_surface_swapchain
#if defined(XR_USE_PLATFORM_ANDROID)

  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSwapchainAndroidSurfaceKHR(const SwapchainCreateInfo& info, Swapchain& swapchain,
                                          jobject* surface,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Swapchain> createSwapchainAndroidSurfaceKHR(
      const SwapchainCreateInfo& info, jobject* surface,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Swapchain createSwapchainAndroidSurfaceKHR(const SwapchainCreateInfo& info, jobject* surface,
                                             Dispatch&& d
                                                 OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>>
  createSwapchainAndroidSurfaceUniqueKHR(const SwapchainCreateInfo& info, jobject* surface,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>> createSwapchainAndroidSurfaceUniqueKHR(
      const SwapchainCreateInfo& info, jobject* surface,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_surface_swapchain

#ifdef XR_KHR_visibility_mask

  /*!
   * @brief xrGetVisibilityMaskKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVisibilityMaskKHR(ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
                              VisibilityMaskTypeKHR visibilityMaskType,
                              VisibilityMaskKHR& visibilityMask,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVisibilityMaskKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VisibilityMaskKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VisibilityMaskKHR> getVisibilityMaskKHR(
      ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
      VisibilityMaskTypeKHR visibilityMaskType,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVisibilityMaskKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VisibilityMaskKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VisibilityMaskKHR getVisibilityMaskKHR(ViewConfigurationType viewConfigurationType,
                                         uint32_t viewIndex,
                                         VisibilityMaskTypeKHR visibilityMaskType,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_KHR_visibility_mask

#ifdef XR_EXT_performance_settings

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain,
                                            PerfSettingsLevelEXT level,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain,
                                            PerfSettingsLevelEXT level,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain, PerfSettingsLevelEXT level,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_thermal_query

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrThermalGetTemperatureTrendEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                       PerfSettingsNotificationLevelEXT& notificationLevel,
                                       float* tempHeadroom, float* tempSlope,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrThermalGetTemperatureTrendEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                       PerfSettingsNotificationLevelEXT& notificationLevel,
                                       float* tempHeadroom, float* tempSlope,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrThermalGetTemperatureTrendEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                     PerfSettingsNotificationLevelEXT& notificationLevel,
                                     float* tempHeadroom, float* tempSlope,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_thermal_query

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionBeginDebugUtilsLabelRegionEXT(
      const DebugUtilsLabelEXT& labelInfo, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionBeginDebugUtilsLabelRegionEXT(
      const DebugUtilsLabelEXT& labelInfo, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionBeginDebugUtilsLabelRegionEXT(const DebugUtilsLabelEXT& labelInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_MSFT_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                 SpatialAnchorMSFT& anchor,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorMSFT> createSpatialAnchorMSFT(
      const SpatialAnchorCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorMSFT createSpatialAnchorMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorUniqueMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>> createSpatialAnchorUniqueMSFT(
      const SpatialAnchorCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorSpaceMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                      Space& space,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createSpatialAnchorSpaceMSFT(
      const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createSpatialAnchorSpaceMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorSpaceUniqueMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createSpatialAnchorSpaceUniqueMSFT(
      const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceActiveEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, XrBool32 isActive,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceActiveEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, XrBool32 isActive,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceActiveEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, XrBool32 isActive,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateBoolEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, XrBool32 state,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateBoolEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, XrBool32 state,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateBoolEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, XrBool32 state,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateFloatEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateFloatEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateFloatEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, XrVector2f state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, XrVector2f state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, XrVector2f state,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceLocationEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space,
                                   XrPosef pose,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceLocationEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space,
                                   XrPosef pose,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceLocationEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space, XrPosef pose,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_hand_tracking

  /*!
   * @brief xrCreateHandTrackerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                              HandTrackerEXT& handTracker,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandTrackerEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandTrackerEXT> createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandTrackerEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandTrackerEXT createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandTrackerEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>>
  createHandTrackerUniqueEXT(const HandTrackerCreateInfoEXT& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandTrackerEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>> createHandTrackerUniqueEXT(
      const HandTrackerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, SpatialAnchorMSFT& anchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorMSFT> createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorMSFT createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorFromPerceptionAnchorUniqueMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>
  createSpatialAnchorFromPerceptionAnchorUniqueMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop

#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop

#ifdef XR_FB_display_refresh_rate

  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateDisplayRefreshRatesFB(uint32_t displayRefreshRateCapacityInput,
                                        uint32_t* displayRefreshRateCountOutput,
                                        float* displayRefreshRates,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<float, Allocator>> enumerateDisplayRefreshRatesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<float, Allocator>> enumerateDisplayRefreshRatesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<float, Allocator> enumerateDisplayRefreshRatesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<float, Allocator> enumerateDisplayRefreshRatesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_display_refresh_rate

  /*!
   * @brief xrGetDisplayRefreshRateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getDisplayRefreshRateFB(float* displayRefreshRate,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetDisplayRefreshRateFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<float> getDisplayRefreshRateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetDisplayRefreshRateFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  float getDisplayRefreshRateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_display_refresh_rate

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestDisplayRefreshRateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestDisplayRefreshRateFB(float displayRefreshRate,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestDisplayRefreshRateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestDisplayRefreshRateFB(float displayRefreshRate,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestDisplayRefreshRateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestDisplayRefreshRateFB(float displayRefreshRate,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_color_space

  /*!
   * @brief xrEnumerateColorSpacesFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateColorSpacesFB(uint32_t colorSpaceCapacityInput, uint32_t* colorSpaceCountOutput,
                                XrColorSpaceFB* colorSpaces,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ColorSpaceFB, Allocator>> enumerateColorSpacesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ColorSpaceFB, Allocator>> enumerateColorSpacesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ColorSpaceFB, Allocator> enumerateColorSpacesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ColorSpaceFB, Allocator> enumerateColorSpacesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_color_space

#ifdef XR_FB_color_space

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetColorSpaceFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setColorSpaceFB(ColorSpaceFB colorspace,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetColorSpaceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setColorSpaceFB(ColorSpaceFB colorspace,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetColorSpaceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setColorSpaceFB(ColorSpaceFB colorspace,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_color_space

  //! @}
private:
  XrSession val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSession) == sizeof(Session),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSession from an Session value.
 *
 * @found_by_adl
 * @see Session::get()
 * @relates Session
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSession get(Session const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrSession
 * handle in a Session (by reference).
 *
 * e.g.
 * ```
 * Session yourHandle;
 * auto result = d.xrCreateSession(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Session
 */
static OPENXR_HPP_INLINE XrSession* put(Session& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Session const& lhs,
                                                      Session const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Session const& lhs,
                                                      Session const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSession lhs, Session const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSession lhs, Session const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSession lhs, Session const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSession lhs, Session const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSession lhs, Session const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSession lhs, Session const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Session and nullptr: true if the handle is null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Session: true if the handle is null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Session const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Session and nullptr: true if the handle is not null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Session: true if the handle is not null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Session const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSpace without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpace>
 *
 * @xrentity{XrSpace}
 * @ingroup handles
 */
class Space {
public:
  using Type = Space;
  using RawHandleType = XrSpace;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Space() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpace type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Space(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Space(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpace
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpace type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Space value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Space value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpace manipulation
   * @{
   */
  //! Gets the raw XrSpace value.
  OPENXR_HPP_CONSTEXPR XrSpace get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Space yourHandle;
   * auto result = d.xrCreateSpace(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Space&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

  /*!
   * @brief xrLocateSpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSpace(Space baseSpace, Time time, SpaceLocation& location,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpaceLocation
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpaceLocation> locateSpace(Space baseSpace, Time time,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpaceLocation
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpaceLocation locateSpace(Space baseSpace, Time time,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpace enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpace enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpace val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpace) == sizeof(Space), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpace from an Space value.
 *
 * @found_by_adl
 * @see Space::get()
 * @relates Space
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpace get(Space const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrSpace
 * handle in a Space (by reference).
 *
 * e.g.
 * ```
 * Space yourHandle;
 * auto result = d.xrCreateSpace(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Space
 */
static OPENXR_HPP_INLINE XrSpace* put(Space& h, bool clear = true) noexcept { return h.put(clear); }

//! @brief `<` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Space const& lhs, Space const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Space const& lhs, Space const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpace lhs, Space const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpace lhs, Space const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpace lhs, Space const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Space and nullptr: true if the handle is null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Space: true if the handle is null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Space const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Space and nullptr: true if the handle is not null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Space: true if the handle is not null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Space const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrAction without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAction>
 *
 * @xrentity{XrAction}
 * @ingroup handles
 */
class Action {
public:
  using Type = Action;
  using RawHandleType = XrAction;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Action() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrAction type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Action(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Action(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrAction
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrAction type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Action value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Action value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrAction manipulation
   * @{
   */
  //! Gets the raw XrAction value.
  OPENXR_HPP_CONSTEXPR XrAction get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Action yourHandle;
   * auto result = d.xrCreateAction(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Action&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyAction wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyAction enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyAction enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrAction val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrAction) == sizeof(Action), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrAction from an Action value.
 *
 * @found_by_adl
 * @see Action::get()
 * @relates Action
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrAction get(Action const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrAction
 * handle in a Action (by reference).
 *
 * e.g.
 * ```
 * Action yourHandle;
 * auto result = d.xrCreateAction(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Action
 */
static OPENXR_HPP_INLINE XrAction* put(Action& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Action const& lhs,
                                                      Action const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Action const& lhs,
                                                      Action const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrAction lhs, Action const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrAction lhs, Action const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrAction lhs, Action const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrAction lhs, Action const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrAction lhs, Action const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrAction lhs, Action const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Action and nullptr: true if the handle is null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Action: true if the handle is null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Action const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Action and nullptr: true if the handle is not null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Action: true if the handle is not null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Action const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSwapchain without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchain>
 *
 * @xrentity{XrSwapchain}
 * @ingroup handles
 */
class Swapchain {
public:
  using Type = Swapchain;
  using RawHandleType = XrSwapchain;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Swapchain() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSwapchain type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Swapchain(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Swapchain(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSwapchain
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSwapchain type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Swapchain value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Swapchain value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSwapchain manipulation
   * @{
   */
  //! Gets the raw XrSwapchain value.
  OPENXR_HPP_CONSTEXPR XrSwapchain get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Swapchain yourHandle;
   * auto result = d.xrCreateSwapchain(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Swapchain&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySwapchain wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySwapchain enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySwapchain enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateSwapchainImages wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSwapchainImages(uint32_t imageCapacityInput, uint32_t* imageCountOutput,
                                  XrSwapchainImageBaseHeader* images,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ResultItemType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename ResultItemType, typename Allocator = std::allocator<ResultItemType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ResultItemType, Allocator>> enumerateSwapchainImagesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ResultItemType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename ResultItemType, typename Allocator = std::allocator<ResultItemType>,
            typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ResultItemType, Allocator>> enumerateSwapchainImagesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ResultItemType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename ResultItemType, typename Allocator = std::allocator<ResultItemType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ResultItemType, Allocator> enumerateSwapchainImagesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ResultItemType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename ResultItemType, typename Allocator = std::allocator<ResultItemType>,
            typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ResultItemType, Allocator> enumerateSwapchainImagesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrAcquireSwapchainImage wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo, uint32_t* index,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrAcquireSwapchainImage enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<uint32_t> acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrAcquireSwapchainImage enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  uint32_t acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrWaitSwapchainImage wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitSwapchainImage>
   *
   * @xrentity{xrWaitSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitSwapchainImage(const SwapchainImageWaitInfo& waitInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrWaitSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::TimeoutExpired, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitSwapchainImage>
   *
   * @xrentity{xrWaitSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitSwapchainImage(const SwapchainImageWaitInfo& waitInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrReleaseSwapchainImage wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrReleaseSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrReleaseSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSwapchain val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSwapchain) == sizeof(Swapchain),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSwapchain from an Swapchain value.
 *
 * @found_by_adl
 * @see Swapchain::get()
 * @relates Swapchain
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSwapchain get(Swapchain const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSwapchain handle in a Swapchain (by reference).
 *
 * e.g.
 * ```
 * Swapchain yourHandle;
 * auto result = d.xrCreateSwapchain(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Swapchain
 */
static OPENXR_HPP_INLINE XrSwapchain* put(Swapchain& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Swapchain const& lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Swapchain const& lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Swapchain const& lhs,
                                                      XrSwapchain rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSwapchain lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Swapchain const& lhs,
                                                      XrSwapchain rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSwapchain lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Swapchain and nullptr: true if the handle is null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Swapchain: true if the handle is null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Swapchain const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Swapchain and nullptr: true if the handle is not null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Swapchain: true if the handle is not null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Swapchain const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrActionSet without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSet>
 *
 * @xrentity{XrActionSet}
 * @ingroup handles
 */
class ActionSet {
public:
  using Type = ActionSet;
  using RawHandleType = XrActionSet;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR ActionSet() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrActionSet type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT ActionSet(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR ActionSet(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrActionSet
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrActionSet type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this ActionSet value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this ActionSet value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrActionSet manipulation
   * @{
   */
  //! Gets the raw XrActionSet value.
  OPENXR_HPP_CONSTEXPR XrActionSet get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * ActionSet yourHandle;
   * auto result = d.xrCreateActionSet(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(ActionSet&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyActionSet wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyActionSet enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyActionSet enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateAction wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createAction(const ActionCreateInfo& createInfo, Action& action,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Action> createAction(const ActionCreateInfo& createInfo,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Action createAction(const ActionCreateInfo& createInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateAction wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>> createActionUnique(
      const ActionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateAction wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Action, impl::RemoveRefConst<Dispatch>> createActionUnique(
      const ActionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrActionSet val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrActionSet) == sizeof(ActionSet),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrActionSet from an ActionSet value.
 *
 * @found_by_adl
 * @see ActionSet::get()
 * @relates ActionSet
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrActionSet get(ActionSet const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrActionSet handle in a ActionSet (by reference).
 *
 * e.g.
 * ```
 * ActionSet yourHandle;
 * auto result = d.xrCreateActionSet(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates ActionSet
 */
static OPENXR_HPP_INLINE XrActionSet* put(ActionSet& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(ActionSet const& lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(ActionSet const& lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(ActionSet const& lhs,
                                                      XrActionSet rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrActionSet lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(ActionSet const& lhs,
                                                      XrActionSet rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrActionSet lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between ActionSet and nullptr: true if the handle is null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and ActionSet: true if the handle is null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       ActionSet const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between ActionSet and nullptr: true if the handle is not null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and ActionSet: true if the handle is not null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       ActionSet const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrDebugUtilsMessengerEXT without indicating ownership.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerEXT>
 *
 * @xrentity{XrDebugUtilsMessengerEXT}
 * @ingroup handles
 */
class DebugUtilsMessengerEXT {
public:
  using Type = DebugUtilsMessengerEXT;
  using RawHandleType = XrDebugUtilsMessengerEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR DebugUtilsMessengerEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrDebugUtilsMessengerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT DebugUtilsMessengerEXT(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR DebugUtilsMessengerEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrDebugUtilsMessengerEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrDebugUtilsMessengerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this DebugUtilsMessengerEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this DebugUtilsMessengerEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrDebugUtilsMessengerEXT manipulation
   * @{
   */
  //! Gets the raw XrDebugUtilsMessengerEXT value.
  OPENXR_HPP_CONSTEXPR XrDebugUtilsMessengerEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * DebugUtilsMessengerEXT yourHandle;
   * auto result = d.xrCreateDebugUtilsMessengerEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(DebugUtilsMessengerEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

  //! @}
private:
  XrDebugUtilsMessengerEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrDebugUtilsMessengerEXT) == sizeof(DebugUtilsMessengerEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrDebugUtilsMessengerEXT from an DebugUtilsMessengerEXT
 * value.
 *
 * @found_by_adl
 * @see DebugUtilsMessengerEXT::get()
 * @relates DebugUtilsMessengerEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrDebugUtilsMessengerEXT
get(DebugUtilsMessengerEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrDebugUtilsMessengerEXT handle in a DebugUtilsMessengerEXT (by reference).
 *
 * e.g.
 * ```
 * DebugUtilsMessengerEXT yourHandle;
 * auto result = d.xrCreateDebugUtilsMessengerEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates DebugUtilsMessengerEXT
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerEXT* put(DebugUtilsMessengerEXT& h,
                                                       bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(DebugUtilsMessengerEXT const& lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(DebugUtilsMessengerEXT const& lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(DebugUtilsMessengerEXT const& lhs,
                                                      XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrDebugUtilsMessengerEXT lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(DebugUtilsMessengerEXT const& lhs,
                                                      XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrDebugUtilsMessengerEXT lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between DebugUtilsMessengerEXT and nullptr: true if the handle is
 * null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and DebugUtilsMessengerEXT: true if the handle is
 * null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between DebugUtilsMessengerEXT and nullptr: true if the handle is
 * not null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and DebugUtilsMessengerEXT: true if the handle is
 * not null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSpatialAnchorMSFT without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorMSFT>
 *
 * @xrentity{XrSpatialAnchorMSFT}
 * @ingroup handles
 */
class SpatialAnchorMSFT {
public:
  using Type = SpatialAnchorMSFT;
  using RawHandleType = XrSpatialAnchorMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialAnchorMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialAnchorMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialAnchorMSFT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialAnchorMSFT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialAnchorMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialAnchorMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialAnchorMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialAnchorMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialAnchorMSFT manipulation
   * @{
   */
  //! Gets the raw XrSpatialAnchorMSFT value.
  OPENXR_HPP_CONSTEXPR XrSpatialAnchorMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialAnchorMSFT yourHandle;
   * auto result = d.xrCreateSpatialAnchorMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialAnchorMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef XR_MSFT_spatial_anchor

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor

  //! @}
private:
  XrSpatialAnchorMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialAnchorMSFT) == sizeof(SpatialAnchorMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialAnchorMSFT from an SpatialAnchorMSFT value.
 *
 * @found_by_adl
 * @see SpatialAnchorMSFT::get()
 * @relates SpatialAnchorMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialAnchorMSFT
get(SpatialAnchorMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialAnchorMSFT handle in a SpatialAnchorMSFT (by reference).
 *
 * e.g.
 * ```
 * SpatialAnchorMSFT yourHandle;
 * auto result = d.xrCreateSpatialAnchorMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialAnchorMSFT
 */
static OPENXR_HPP_INLINE XrSpatialAnchorMSFT* put(SpatialAnchorMSFT& h,
                                                  bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialAnchorMSFT const& lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialAnchorMSFT const& lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialAnchorMSFT const& lhs,
                                                      XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpatialAnchorMSFT lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialAnchorMSFT const& lhs,
                                                      XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpatialAnchorMSFT lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialAnchorMSFT and nullptr: true if the handle is null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialAnchorMSFT: true if the handle is null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialAnchorMSFT and nullptr: true if the handle is not
 * null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialAnchorMSFT: true if the handle is not
 * null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrHandTrackerEXT without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackerEXT>
 *
 * @xrentity{XrHandTrackerEXT}
 * @ingroup handles
 */
class HandTrackerEXT {
public:
  using Type = HandTrackerEXT;
  using RawHandleType = XrHandTrackerEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR HandTrackerEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrHandTrackerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT HandTrackerEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR HandTrackerEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrHandTrackerEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrHandTrackerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this HandTrackerEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this HandTrackerEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrHandTrackerEXT manipulation
   * @{
   */
  //! Gets the raw XrHandTrackerEXT value.
  OPENXR_HPP_CONSTEXPR XrHandTrackerEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * HandTrackerEXT yourHandle;
   * auto result = d.xrCreateHandTrackerEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(HandTrackerEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef XR_EXT_hand_tracking

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyHandTrackerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyHandTrackerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyHandTrackerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking

  /*!
   * @brief xrLocateHandJointsEXT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateHandJointsEXT(const HandJointsLocateInfoEXT& locateInfo,
                             HandJointLocationsEXT& locations,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateHandJointsEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandJointLocationsEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandJointLocationsEXT> locateHandJointsEXT(
      const HandJointsLocateInfoEXT& locateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateHandJointsEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandJointLocationsEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandJointLocationsEXT locateHandJointsEXT(const HandJointsLocateInfoEXT& locateInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_hand_tracking_mesh

  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo, Space& space,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandMeshSpaceMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo,
                                             Dispatch&& d
                                                 OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandMeshSpaceMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createHandMeshSpaceUniqueMSFT(
      const HandMeshSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createHandMeshSpaceUniqueMSFT(
      const HandMeshSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh

  /*!
   * @brief xrUpdateHandMeshMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo, HandMeshMSFT& handMesh,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUpdateHandMeshMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandMeshMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandMeshMSFT> updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUpdateHandMeshMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandMeshMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandMeshMSFT updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_hand_tracking_mesh

  //! @}
private:
  XrHandTrackerEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrHandTrackerEXT) == sizeof(HandTrackerEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrHandTrackerEXT from an HandTrackerEXT value.
 *
 * @found_by_adl
 * @see HandTrackerEXT::get()
 * @relates HandTrackerEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrHandTrackerEXT get(HandTrackerEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrHandTrackerEXT handle in a HandTrackerEXT (by reference).
 *
 * e.g.
 * ```
 * HandTrackerEXT yourHandle;
 * auto result = d.xrCreateHandTrackerEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates HandTrackerEXT
 */
static OPENXR_HPP_INLINE XrHandTrackerEXT* put(HandTrackerEXT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(HandTrackerEXT const& lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(HandTrackerEXT const& lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(HandTrackerEXT const& lhs,
                                                      XrHandTrackerEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrHandTrackerEXT lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(HandTrackerEXT const& lhs,
                                                      XrHandTrackerEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrHandTrackerEXT lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between HandTrackerEXT and nullptr: true if the handle is null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and HandTrackerEXT: true if the handle is null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       HandTrackerEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between HandTrackerEXT and nullptr: true if the handle is not null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and HandTrackerEXT: true if the handle is not null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       HandTrackerEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @defgroup api_free_functions OpenXR API free functions
 * @ingroup wrappers
 *
 * Equivalent to the method wrappers in the handle classes,
 * but for the few functions that don't take (or don't require)
 * a handle as their first argument.
 * @{
 */
// Declarations - implementations are out of line.

/*!
 * @brief xrEnumerateApiLayerProperties wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result enumerateApiLayerProperties(uint32_t propertyCapacityInput, uint32_t* propertyCountOutput,
                                   XrApiLayerProperties* properties,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined. Performs two-call idiom. Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ApiLayerProperties, Allocator>> enumerateApiLayerPropertiesToVector(
    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ApiLayerProperties, Allocator>> enumerateApiLayerPropertiesToVector(
    Allocator const& vectorAllocator, Dispatch&& d);

#else
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 * Performs two-call idiom.
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector(
    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector(
    Allocator const& vectorAllocator, Dispatch&& d);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief xrEnumerateInstanceExtensionProperties wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result enumerateInstanceExtensionProperties(const char* layerName, uint32_t propertyCapacityInput,
                                            uint32_t* propertyCountOutput,
                                            XrExtensionProperties* properties,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined. Performs two-call idiom. Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ExtensionProperties, Allocator>>
enumerateInstanceExtensionPropertiesToVector(const char* layerName,
                                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ExtensionProperties, Allocator>>
enumerateInstanceExtensionPropertiesToVector(const char* layerName,
                                             Allocator const& vectorAllocator, Dispatch&& d);

#else
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 * Performs two-call idiom.
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ExtensionProperties, Allocator> enumerateInstanceExtensionPropertiesToVector(
    const char* layerName, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ExtensionProperties, Allocator> enumerateInstanceExtensionPropertiesToVector(
    const char* layerName, Allocator const& vectorAllocator, Dispatch&& d);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief xrCreateInstance wrapper (basic).
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result createInstance(const InstanceCreateInfo& createInfo, Instance& instance,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrCreateInstance enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<Instance> createInstance(const InstanceCreateInfo& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrCreateInstance enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Instance createInstance(const InstanceCreateInfo& createInfo,
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrCreateInstance wrapper returning a smart handle.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * -  a smart wrapper uniquely owning a Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>> createInstanceUnique(
    const InstanceCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrCreateInstance wrapper returning a smart handle.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @returns  a smart wrapper uniquely owning a Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>> createInstanceUnique(
    const InstanceCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_KHR_loader_init

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
/*!
 * @brief xrInitializeLoaderKHR wrapper (basic).
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result initializeLoaderKHR(const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrInitializeLoaderKHR enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns Result (which may be Result::Success, or an error code if asserts are not active )
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result initializeLoaderKHR(const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
/*!
 * @brief xrInitializeLoaderKHR enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
void initializeLoaderKHR(const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_KHR_loader_init

//! @}

}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_HANDLES_HPP_
