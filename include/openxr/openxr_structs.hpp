// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2021 The Khronos Group Inc.
** Copyright (c) 2019-2021 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_STRUCTS_HPP_
#define OPENXR_STRUCTS_HPP_
/**
 * @file
 * @brief C++ projections of OpenXR structure types.
 * @ingroup structs
 */

/*!
 * @defgroup structs Structures
 * @brief C++ projections of OpenXR structure types, with easier init but identical layout.
 * @ingroup wrappers
 *
 * These are all implicitly convertible to a reference-to-const to their corresponding raw C types,
 * so you can treat them as you otherwise might.
 */
/*!
 * @defgroup typedstructs Typed/chainable structures
 * @brief C++ projections of those OpenXR structure types with a `type` and `next` field.
 * @ingroup structs
 */
/*!
 * @defgroup abstracttypedstructs Abstract typed structures
 * @brief C++ projections of those OpenXR structure types with a `type` and `next` field,
 * but no specific type enum value of their own: these are the "base structs" in OpenXR.
 * @ingroup typedstructs
 */

// for strncpy_s
#ifndef __STDC_WANT_LIB_EXT1__
#define __STDC_WANT_LIB_EXT1__ 1
#endif
#include <string.h>

#include "openxr_enums.hpp"
#include "openxr_flags.hpp"
#include "openxr_version.hpp"
#include "openxr_time.hpp"
#include "openxr_atoms.hpp"
#include "openxr_handles.hpp"

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

namespace OPENXR_HPP_NAMESPACE {

using Bool32 = XrBool32;

namespace impl {

  class XR_MAY_ALIAS InputStructBase {
  protected:
    InputStructBase(StructureType type_, const void* next_ = nullptr) : type(type_), next(next_) {}

  public:
    StructureType type;
    const void* next;
  };
  static_assert(sizeof(::XrBaseInStructure) == sizeof(InputStructBase),
                "Original type and wrapper have different size!");

  class XR_MAY_ALIAS OutputStructBase {
  protected:
    OutputStructBase(StructureType type_, void* next_ = nullptr) : type(type_), next(next_) {}

  public:
    StructureType type;
    void* next;
  };
  static_assert(sizeof(::XrBaseOutStructure) == sizeof(OutputStructBase),
                "Original type and wrapper have different size!");
}  // namespace impl

/*!
 * @brief Wrapper for XrEventDataBuffer
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataBuffer>
 *
 * @xrentity{XrEventDataBuffer}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataBuffer : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  EventDataBuffer(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_), varying{} {}

public:
  //! Default constructor - use this one.
  EventDataBuffer() : Parent(StructureType::EventDataBuffer), varying{} { (void)varying; }
  //! @brief "Put" function for assigning as null then getting the address of the raw pointer to
  //! pass as function output parameter.
  XrEventDataBuffer* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = {};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataBuffer*>(this);
  }

  //! Gets a pointer to the underlying raw XrEventDataBuffer type.
  XrEventDataBuffer* get() noexcept { return reinterpret_cast<XrEventDataBuffer*>(this); }

  //! Gets a pointer to the underlying raw XrEventDataBuffer type.
  XrEventDataBuffer const* get() const noexcept {
    return reinterpret_cast<XrEventDataBuffer const*>(this);
  }

private:
  uint8_t varying[4000];
};
static_assert(sizeof(::XrEventDataBuffer) == sizeof(EventDataBuffer),
              "Original type and wrapper have different size!");

/*!
 * @brief Free "put" function for clearing and getting the address of the raw XrEventDataBuffer in
 * an EventDataBuffer.
 * @relates EventDataBuffer
 * @ingroup utility_accessors
 */
OPENXR_HPP_INLINE XrEventDataBuffer* put(EventDataBuffer& v, bool clear = true) noexcept {
  return v.put(clear);
}

/*!
 * C++ projection of XrApiLayerProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApiLayerProperties>
 * @xrentity{XrApiLayerProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ApiLayerProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ApiLayerProperties(

      void* next_ = nullptr)
      : Parent(StructureType::APILayerProperties, next_) {}

  //! Default copy constructor
  ApiLayerProperties(const ApiLayerProperties& rhs) = default;
  //! Default copy assignment
  ApiLayerProperties& operator=(const ApiLayerProperties& rhs) = default;
  //! Copy construct from raw
  ApiLayerProperties(const XrApiLayerProperties& rhs) : ApiLayerProperties() { *put() = rhs; }
  //! Copy assign from raw
  ApiLayerProperties& operator=(const XrApiLayerProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrApiLayerProperties&() const {
    return *reinterpret_cast<const XrApiLayerProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrApiLayerProperties&() { return *reinterpret_cast<XrApiLayerProperties*>(this); }

  //! Accessor for this as the address of a raw XrApiLayerProperties
  XrApiLayerProperties const* get() const noexcept {
    return reinterpret_cast<XrApiLayerProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrApiLayerProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrApiLayerProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ApiLayerProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrApiLayerProperties*>(this);
  }
  char layerName[XR_MAX_API_LAYER_NAME_SIZE];
  Version specVersion;
  uint32_t layerVersion;
  char description[XR_MAX_API_LAYER_DESCRIPTION_SIZE];
};
static_assert(sizeof(XrApiLayerProperties) == sizeof(ApiLayerProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrApiLayerProperties pointer to const from a
 * ApiLayerProperties reference to const.
 * @relates ApiLayerProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerProperties const* get(ApiLayerProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ApiLayerProperties as the
 * address of a raw XrApiLayerProperties
 * @relates ApiLayerProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerProperties* put(ApiLayerProperties& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtensionProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtensionProperties>
 * @xrentity{XrExtensionProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ExtensionProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ExtensionProperties(

      void* next_ = nullptr)
      : Parent(StructureType::ExtensionProperties, next_) {}

  //! Default copy constructor
  ExtensionProperties(const ExtensionProperties& rhs) = default;
  //! Default copy assignment
  ExtensionProperties& operator=(const ExtensionProperties& rhs) = default;
  //! Copy construct from raw
  ExtensionProperties(const XrExtensionProperties& rhs) : ExtensionProperties() { *put() = rhs; }
  //! Copy assign from raw
  ExtensionProperties& operator=(const XrExtensionProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtensionProperties&() const {
    return *reinterpret_cast<const XrExtensionProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtensionProperties&() { return *reinterpret_cast<XrExtensionProperties*>(this); }

  //! Accessor for this as the address of a raw XrExtensionProperties
  XrExtensionProperties const* get() const noexcept {
    return reinterpret_cast<XrExtensionProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtensionProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrExtensionProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ExtensionProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrExtensionProperties*>(this);
  }
  char extensionName[XR_MAX_EXTENSION_NAME_SIZE];
  uint32_t extensionVersion;
};
static_assert(sizeof(XrExtensionProperties) == sizeof(ExtensionProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtensionProperties pointer to const from a
 * ExtensionProperties reference to const.
 * @relates ExtensionProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtensionProperties const* get(ExtensionProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ExtensionProperties as the
 * address of a raw XrExtensionProperties
 * @relates ExtensionProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtensionProperties* put(ExtensionProperties& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrApplicationInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApplicationInfo>
 * @xrentity{XrApplicationInfo}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ApplicationInfo {
public:
  //! Constructor initializing all members.
  ApplicationInfo(const char* applicationName_, uint32_t applicationVersion_,
                  const char* engineName_, uint32_t engineVersion_, const Version& apiVersion_)
      : applicationVersion{applicationVersion_},
        engineVersion{engineVersion_},
        apiVersion{apiVersion_} {
    if (nullptr != applicationName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(applicationName, XR_MAX_APPLICATION_NAME_SIZE, applicationName_,
                XR_MAX_APPLICATION_NAME_SIZE);
#else
      strncpy(applicationName, applicationName_, XR_MAX_APPLICATION_NAME_SIZE - 1);
      applicationName[XR_MAX_APPLICATION_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != engineName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(engineName, XR_MAX_ENGINE_NAME_SIZE, engineName_, XR_MAX_ENGINE_NAME_SIZE);
#else
      strncpy(engineName, engineName_, XR_MAX_ENGINE_NAME_SIZE - 1);
      engineName[XR_MAX_ENGINE_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ApplicationInfo(

  ) {}

  //! Default copy constructor
  ApplicationInfo(const ApplicationInfo& rhs) = default;
  //! Default copy assignment
  ApplicationInfo& operator=(const ApplicationInfo& rhs) = default;
  //! Copy construct from raw
  ApplicationInfo(const XrApplicationInfo& rhs) : ApplicationInfo() { *put() = rhs; }
  //! Copy assign from raw
  ApplicationInfo& operator=(const XrApplicationInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrApplicationInfo&() const {
    return *reinterpret_cast<const XrApplicationInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrApplicationInfo&() { return *reinterpret_cast<XrApplicationInfo*>(this); }

  //! Accessor for this as the address of a raw XrApplicationInfo
  XrApplicationInfo const* get() const noexcept {
    return reinterpret_cast<XrApplicationInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrApplicationInfo.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrApplicationInfo* put(bool clear = true) noexcept {
    if (clear) {
      *this = ApplicationInfo{};
    }
    return reinterpret_cast<XrApplicationInfo*>(this);
  }
  char applicationName[XR_MAX_APPLICATION_NAME_SIZE];
  uint32_t applicationVersion;
  char engineName[XR_MAX_ENGINE_NAME_SIZE];
  uint32_t engineVersion;
  Version apiVersion;
};
static_assert(sizeof(XrApplicationInfo) == sizeof(ApplicationInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrApplicationInfo pointer to const from a ApplicationInfo
 * reference to const.
 * @relates ApplicationInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApplicationInfo const* get(ApplicationInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ApplicationInfo as the
 * address of a raw XrApplicationInfo
 * @relates ApplicationInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApplicationInfo* put(ApplicationInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInstanceCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceCreateInfo>
 * @xrentity{XrInstanceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InstanceCreateInfo(const InstanceCreateFlags& createFlags_,
                     const ApplicationInfo& applicationInfo_, uint32_t enabledApiLayerCount_,
                     const char* const* enabledApiLayerNames_, uint32_t enabledExtensionCount_,
                     const char* const* enabledExtensionNames_, const void* next_ = nullptr)
      : Parent(StructureType::InstanceCreateInfo, next_),
        createFlags{createFlags_},
        applicationInfo{applicationInfo_},
        enabledApiLayerCount{enabledApiLayerCount_},
        enabledApiLayerNames{enabledApiLayerNames_},
        enabledExtensionCount{enabledExtensionCount_},
        enabledExtensionNames{enabledExtensionNames_} {}

  //! Default/empty constructor
  InstanceCreateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::InstanceCreateInfo, next_) {}

  //! Default copy constructor
  InstanceCreateInfo(const InstanceCreateInfo& rhs) = default;
  //! Default copy assignment
  InstanceCreateInfo& operator=(const InstanceCreateInfo& rhs) = default;
  //! Copy construct from raw
  InstanceCreateInfo(const XrInstanceCreateInfo& rhs) : InstanceCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  InstanceCreateInfo& operator=(const XrInstanceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceCreateInfo&() const {
    return *reinterpret_cast<const XrInstanceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceCreateInfo&() { return *reinterpret_cast<XrInstanceCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrInstanceCreateInfo
  XrInstanceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrInstanceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrInstanceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceCreateInfo*>(this);
  }
  InstanceCreateFlags createFlags;
  ApplicationInfo applicationInfo;
  uint32_t enabledApiLayerCount;
  const char* const* enabledApiLayerNames;
  uint32_t enabledExtensionCount;
  const char* const* enabledExtensionNames;
};
static_assert(sizeof(XrInstanceCreateInfo) == sizeof(InstanceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceCreateInfo pointer to const from a
 * InstanceCreateInfo reference to const.
 * @relates InstanceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfo const* get(InstanceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceCreateInfo as the
 * address of a raw XrInstanceCreateInfo
 * @relates InstanceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfo* put(InstanceCreateInfo& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInstanceProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceProperties>
 * @xrentity{XrInstanceProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  InstanceProperties(

      void* next_ = nullptr)
      : Parent(StructureType::InstanceProperties, next_) {}

  //! Default copy constructor
  InstanceProperties(const InstanceProperties& rhs) = default;
  //! Default copy assignment
  InstanceProperties& operator=(const InstanceProperties& rhs) = default;
  //! Copy construct from raw
  InstanceProperties(const XrInstanceProperties& rhs) : InstanceProperties() { *put() = rhs; }
  //! Copy assign from raw
  InstanceProperties& operator=(const XrInstanceProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceProperties&() const {
    return *reinterpret_cast<const XrInstanceProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceProperties&() { return *reinterpret_cast<XrInstanceProperties*>(this); }

  //! Accessor for this as the address of a raw XrInstanceProperties
  XrInstanceProperties const* get() const noexcept {
    return reinterpret_cast<XrInstanceProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrInstanceProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceProperties*>(this);
  }
  Version runtimeVersion;
  char runtimeName[XR_MAX_RUNTIME_NAME_SIZE];
};
static_assert(sizeof(XrInstanceProperties) == sizeof(InstanceProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceProperties pointer to const from a
 * InstanceProperties reference to const.
 * @relates InstanceProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceProperties const* get(InstanceProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceProperties as the
 * address of a raw XrInstanceProperties
 * @relates InstanceProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceProperties* put(InstanceProperties& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemGetInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemGetInfo>
 * @xrentity{XrSystemGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SystemGetInfo(const FormFactor& formFactor_, const void* next_ = nullptr)
      : Parent(StructureType::SystemGetInfo, next_), formFactor{formFactor_} {}

  //! Default/empty constructor
  SystemGetInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::SystemGetInfo, next_) {}

  //! Default copy constructor
  SystemGetInfo(const SystemGetInfo& rhs) = default;
  //! Default copy assignment
  SystemGetInfo& operator=(const SystemGetInfo& rhs) = default;
  //! Copy construct from raw
  SystemGetInfo(const XrSystemGetInfo& rhs) : SystemGetInfo() { *put() = rhs; }
  //! Copy assign from raw
  SystemGetInfo& operator=(const XrSystemGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemGetInfo&() const {
    return *reinterpret_cast<const XrSystemGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemGetInfo&() { return *reinterpret_cast<XrSystemGetInfo*>(this); }

  //! Accessor for this as the address of a raw XrSystemGetInfo
  XrSystemGetInfo const* get() const noexcept {
    return reinterpret_cast<XrSystemGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSystemGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemGetInfo*>(this);
  }
  FormFactor formFactor;
};
static_assert(sizeof(XrSystemGetInfo) == sizeof(SystemGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemGetInfo pointer to const from a SystemGetInfo
 * reference to const.
 * @relates SystemGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGetInfo const* get(SystemGetInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemGetInfo as the address
 * of a raw XrSystemGetInfo
 * @relates SystemGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGetInfo* put(SystemGetInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemGraphicsProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemGraphicsProperties>
 * @xrentity{XrSystemGraphicsProperties}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SystemGraphicsProperties {
public:
  //! Constructor initializing all members.
  SystemGraphicsProperties(uint32_t maxSwapchainImageHeight_, uint32_t maxSwapchainImageWidth_,
                           uint32_t maxLayerCount_)
      : maxSwapchainImageHeight{maxSwapchainImageHeight_},
        maxSwapchainImageWidth{maxSwapchainImageWidth_},
        maxLayerCount{maxLayerCount_} {}

  //! Default/empty constructor
  SystemGraphicsProperties(

  ) {}

  //! Default copy constructor
  SystemGraphicsProperties(const SystemGraphicsProperties& rhs) = default;
  //! Default copy assignment
  SystemGraphicsProperties& operator=(const SystemGraphicsProperties& rhs) = default;
  //! Copy construct from raw
  SystemGraphicsProperties(const XrSystemGraphicsProperties& rhs) : SystemGraphicsProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemGraphicsProperties& operator=(const XrSystemGraphicsProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemGraphicsProperties&() const {
    return *reinterpret_cast<const XrSystemGraphicsProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemGraphicsProperties&() {
    return *reinterpret_cast<XrSystemGraphicsProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemGraphicsProperties
  XrSystemGraphicsProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemGraphicsProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemGraphicsProperties.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSystemGraphicsProperties* put(bool clear = true) noexcept {
    if (clear) {
      *this = SystemGraphicsProperties{};
    }
    return reinterpret_cast<XrSystemGraphicsProperties*>(this);
  }
  uint32_t maxSwapchainImageHeight;
  uint32_t maxSwapchainImageWidth;
  uint32_t maxLayerCount;
};
static_assert(sizeof(XrSystemGraphicsProperties) == sizeof(SystemGraphicsProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemGraphicsProperties pointer to const from a
 * SystemGraphicsProperties reference to const.
 * @relates SystemGraphicsProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGraphicsProperties const* get(SystemGraphicsProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemGraphicsProperties as
 * the address of a raw XrSystemGraphicsProperties
 * @relates SystemGraphicsProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGraphicsProperties* put(SystemGraphicsProperties& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemTrackingProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemTrackingProperties>
 * @xrentity{XrSystemTrackingProperties}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SystemTrackingProperties {
public:
  //! Constructor initializing all members.
  SystemTrackingProperties(const Bool32& orientationTracking_, const Bool32& positionTracking_)
      : orientationTracking{orientationTracking_}, positionTracking{positionTracking_} {}

  //! Default/empty constructor
  SystemTrackingProperties(

  ) {}

  //! Default copy constructor
  SystemTrackingProperties(const SystemTrackingProperties& rhs) = default;
  //! Default copy assignment
  SystemTrackingProperties& operator=(const SystemTrackingProperties& rhs) = default;
  //! Copy construct from raw
  SystemTrackingProperties(const XrSystemTrackingProperties& rhs) : SystemTrackingProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemTrackingProperties& operator=(const XrSystemTrackingProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemTrackingProperties&() const {
    return *reinterpret_cast<const XrSystemTrackingProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemTrackingProperties&() {
    return *reinterpret_cast<XrSystemTrackingProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemTrackingProperties
  XrSystemTrackingProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemTrackingProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemTrackingProperties.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSystemTrackingProperties* put(bool clear = true) noexcept {
    if (clear) {
      *this = SystemTrackingProperties{};
    }
    return reinterpret_cast<XrSystemTrackingProperties*>(this);
  }
  Bool32 orientationTracking;
  Bool32 positionTracking;
};
static_assert(sizeof(XrSystemTrackingProperties) == sizeof(SystemTrackingProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemTrackingProperties pointer to const from a
 * SystemTrackingProperties reference to const.
 * @relates SystemTrackingProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemTrackingProperties const* get(SystemTrackingProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemTrackingProperties as
 * the address of a raw XrSystemTrackingProperties
 * @relates SystemTrackingProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemTrackingProperties* put(SystemTrackingProperties& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemProperties>
 * @xrentity{XrSystemProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemProperties(

      void* next_ = nullptr)
      : Parent(StructureType::SystemProperties, next_) {}

  //! Default copy constructor
  SystemProperties(const SystemProperties& rhs) = default;
  //! Default copy assignment
  SystemProperties& operator=(const SystemProperties& rhs) = default;
  //! Copy construct from raw
  SystemProperties(const XrSystemProperties& rhs) : SystemProperties() { *put() = rhs; }
  //! Copy assign from raw
  SystemProperties& operator=(const XrSystemProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemProperties&() const {
    return *reinterpret_cast<const XrSystemProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemProperties&() { return *reinterpret_cast<XrSystemProperties*>(this); }

  //! Accessor for this as the address of a raw XrSystemProperties
  XrSystemProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSystemProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemProperties*>(this);
  }
  SystemId systemId;
  uint32_t vendorId;
  char systemName[XR_MAX_SYSTEM_NAME_SIZE];
  SystemGraphicsProperties graphicsProperties;
  SystemTrackingProperties trackingProperties;
};
static_assert(sizeof(XrSystemProperties) == sizeof(SystemProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemProperties pointer to const from a
 * SystemProperties reference to const.
 * @relates SystemProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemProperties const* get(SystemProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemProperties as the
 * address of a raw XrSystemProperties
 * @relates SystemProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemProperties* put(SystemProperties& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionCreateInfo>
 * @xrentity{XrSessionCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionCreateInfo(const SessionCreateFlags& createFlags_, const SystemId& systemId_,
                    const void* next_ = nullptr)
      : Parent(StructureType::SessionCreateInfo, next_),
        createFlags{createFlags_},
        systemId{systemId_} {}

  //! Default/empty constructor
  SessionCreateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::SessionCreateInfo, next_) {}

  //! Default copy constructor
  SessionCreateInfo(const SessionCreateInfo& rhs) = default;
  //! Default copy assignment
  SessionCreateInfo& operator=(const SessionCreateInfo& rhs) = default;
  //! Copy construct from raw
  SessionCreateInfo(const XrSessionCreateInfo& rhs) : SessionCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  SessionCreateInfo& operator=(const XrSessionCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionCreateInfo&() const {
    return *reinterpret_cast<const XrSessionCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionCreateInfo&() { return *reinterpret_cast<XrSessionCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrSessionCreateInfo
  XrSessionCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSessionCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionCreateInfo*>(this);
  }
  SessionCreateFlags createFlags;
  SystemId systemId;
};
static_assert(sizeof(XrSessionCreateInfo) == sizeof(SessionCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionCreateInfo pointer to const from a
 * SessionCreateInfo reference to const.
 * @relates SessionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfo const* get(SessionCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionCreateInfo as the
 * address of a raw XrSessionCreateInfo
 * @relates SessionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfo* put(SessionCreateInfo& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector3f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector3f>
 * @xrentity{XrVector3f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector3f {
public:
  //! Constructor initializing all members.
  Vector3f(float x_, float y_, float z_) : x{x_}, y{y_}, z{z_} {}

  //! Default/empty constructor
  Vector3f(

  ) {}

  //! Default copy constructor
  Vector3f(const Vector3f& rhs) = default;
  //! Default copy assignment
  Vector3f& operator=(const Vector3f& rhs) = default;
  //! Copy construct from raw
  Vector3f(const XrVector3f& rhs) : Vector3f() { *put() = rhs; }
  //! Copy assign from raw
  Vector3f& operator=(const XrVector3f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector3f&() const { return *reinterpret_cast<const XrVector3f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector3f&() { return *reinterpret_cast<XrVector3f*>(this); }

  //! Accessor for this as the address of a raw XrVector3f
  XrVector3f const* get() const noexcept { return reinterpret_cast<XrVector3f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector3f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector3f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector3f{};
    }
    return reinterpret_cast<XrVector3f*>(this);
  }
  float x;
  float y;
  float z;
};
static_assert(sizeof(XrVector3f) == sizeof(Vector3f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector3f pointer to const from a Vector3f reference to
 * const.
 * @relates Vector3f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector3f const* get(Vector3f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector3f as the address of a
 * raw XrVector3f
 * @relates Vector3f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector3f* put(Vector3f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceVelocity
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceVelocity>
 * @xrentity{XrSpaceVelocity}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceVelocity : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceVelocity(

      void* next_ = nullptr)
      : Parent(StructureType::SpaceVelocity, next_) {}

  //! Default copy constructor
  SpaceVelocity(const SpaceVelocity& rhs) = default;
  //! Default copy assignment
  SpaceVelocity& operator=(const SpaceVelocity& rhs) = default;
  //! Copy construct from raw
  SpaceVelocity(const XrSpaceVelocity& rhs) : SpaceVelocity() { *put() = rhs; }
  //! Copy assign from raw
  SpaceVelocity& operator=(const XrSpaceVelocity& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceVelocity&() const {
    return *reinterpret_cast<const XrSpaceVelocity*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceVelocity&() { return *reinterpret_cast<XrSpaceVelocity*>(this); }

  //! Accessor for this as the address of a raw XrSpaceVelocity
  XrSpaceVelocity const* get() const noexcept {
    return reinterpret_cast<XrSpaceVelocity const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceVelocity.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceVelocity* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceVelocity{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceVelocity*>(this);
  }
  SpaceVelocityFlags velocityFlags;
  Vector3f linearVelocity;
  Vector3f angularVelocity;
};
static_assert(sizeof(XrSpaceVelocity) == sizeof(SpaceVelocity),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceVelocity pointer to const from a SpaceVelocity
 * reference to const.
 * @relates SpaceVelocity
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocity const* get(SpaceVelocity const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceVelocity as the address
 * of a raw XrSpaceVelocity
 * @relates SpaceVelocity
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocity* put(SpaceVelocity& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrQuaternionf
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrQuaternionf>
 * @xrentity{XrQuaternionf}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Quaternionf {
public:
  //! Constructor initializing all members.
  Quaternionf(float x_, float y_, float z_, float w_) : x{x_}, y{y_}, z{z_}, w{w_} {}

  //! Default/empty constructor
  Quaternionf(

  ) {}

  //! Default copy constructor
  Quaternionf(const Quaternionf& rhs) = default;
  //! Default copy assignment
  Quaternionf& operator=(const Quaternionf& rhs) = default;
  //! Copy construct from raw
  Quaternionf(const XrQuaternionf& rhs) : Quaternionf() { *put() = rhs; }
  //! Copy assign from raw
  Quaternionf& operator=(const XrQuaternionf& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrQuaternionf&() const { return *reinterpret_cast<const XrQuaternionf*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrQuaternionf&() { return *reinterpret_cast<XrQuaternionf*>(this); }

  //! Accessor for this as the address of a raw XrQuaternionf
  XrQuaternionf const* get() const noexcept { return reinterpret_cast<XrQuaternionf const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrQuaternionf.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrQuaternionf* put(bool clear = true) noexcept {
    if (clear) {
      *this = Quaternionf{};
    }
    return reinterpret_cast<XrQuaternionf*>(this);
  }
  float x;
  float y;
  float z;
  float w;
};
static_assert(sizeof(XrQuaternionf) == sizeof(Quaternionf),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrQuaternionf pointer to const from a Quaternionf
 * reference to const.
 * @relates Quaternionf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQuaternionf const* get(Quaternionf const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Quaternionf as the address of
 * a raw XrQuaternionf
 * @relates Quaternionf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQuaternionf* put(Quaternionf& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrPosef
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPosef>
 * @xrentity{XrPosef}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Posef {
public:
  //! Constructor initializing all members.
  Posef(const Quaternionf& orientation_, const Vector3f& position_)
      : orientation{orientation_}, position{position_} {}

  //! Default/empty constructor
  Posef(

  ) {}

  //! Default copy constructor
  Posef(const Posef& rhs) = default;
  //! Default copy assignment
  Posef& operator=(const Posef& rhs) = default;
  //! Copy construct from raw
  Posef(const XrPosef& rhs) : Posef() { *put() = rhs; }
  //! Copy assign from raw
  Posef& operator=(const XrPosef& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPosef&() const { return *reinterpret_cast<const XrPosef*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPosef&() { return *reinterpret_cast<XrPosef*>(this); }

  //! Accessor for this as the address of a raw XrPosef
  XrPosef const* get() const noexcept { return reinterpret_cast<XrPosef const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrPosef.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrPosef* put(bool clear = true) noexcept {
    if (clear) {
      *this = Posef{};
    }
    return reinterpret_cast<XrPosef*>(this);
  }
  Quaternionf orientation;
  Vector3f position;
};
static_assert(sizeof(XrPosef) == sizeof(Posef), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPosef pointer to const from a Posef reference to const.
 * @relates Posef
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPosef const* get(Posef const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Posef as the address of a raw
 * XrPosef
 * @relates Posef
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPosef* put(Posef& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrReferenceSpaceCreateInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReferenceSpaceCreateInfo>
 * @xrentity{XrReferenceSpaceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ReferenceSpaceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ReferenceSpaceCreateInfo(const ReferenceSpaceType& referenceSpaceType_,
                           const Posef& poseInReferenceSpace_, const void* next_ = nullptr)
      : Parent(StructureType::ReferenceSpaceCreateInfo, next_),
        referenceSpaceType{referenceSpaceType_},
        poseInReferenceSpace{poseInReferenceSpace_} {}

  //! Default/empty constructor
  ReferenceSpaceCreateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::ReferenceSpaceCreateInfo, next_) {}

  //! Default copy constructor
  ReferenceSpaceCreateInfo(const ReferenceSpaceCreateInfo& rhs) = default;
  //! Default copy assignment
  ReferenceSpaceCreateInfo& operator=(const ReferenceSpaceCreateInfo& rhs) = default;
  //! Copy construct from raw
  ReferenceSpaceCreateInfo(const XrReferenceSpaceCreateInfo& rhs) : ReferenceSpaceCreateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ReferenceSpaceCreateInfo& operator=(const XrReferenceSpaceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrReferenceSpaceCreateInfo&() const {
    return *reinterpret_cast<const XrReferenceSpaceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrReferenceSpaceCreateInfo&() {
    return *reinterpret_cast<XrReferenceSpaceCreateInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrReferenceSpaceCreateInfo
  XrReferenceSpaceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrReferenceSpaceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrReferenceSpaceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrReferenceSpaceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ReferenceSpaceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrReferenceSpaceCreateInfo*>(this);
  }
  ReferenceSpaceType referenceSpaceType;
  Posef poseInReferenceSpace;
};
static_assert(sizeof(XrReferenceSpaceCreateInfo) == sizeof(ReferenceSpaceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrReferenceSpaceCreateInfo pointer to const from a
 * ReferenceSpaceCreateInfo reference to const.
 * @relates ReferenceSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrReferenceSpaceCreateInfo const* get(ReferenceSpaceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ReferenceSpaceCreateInfo as
 * the address of a raw XrReferenceSpaceCreateInfo
 * @relates ReferenceSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrReferenceSpaceCreateInfo* put(ReferenceSpaceCreateInfo& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtent2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent2Df>
 * @xrentity{XrExtent2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Extent2Df {
public:
  //! Constructor initializing all members.
  Extent2Df(float width_, float height_) : width{width_}, height{height_} {}

  //! Default/empty constructor
  Extent2Df(

  ) {}

  //! Default copy constructor
  Extent2Df(const Extent2Df& rhs) = default;
  //! Default copy assignment
  Extent2Df& operator=(const Extent2Df& rhs) = default;
  //! Copy construct from raw
  Extent2Df(const XrExtent2Df& rhs) : Extent2Df() { *put() = rhs; }
  //! Copy assign from raw
  Extent2Df& operator=(const XrExtent2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtent2Df&() const { return *reinterpret_cast<const XrExtent2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtent2Df&() { return *reinterpret_cast<XrExtent2Df*>(this); }

  //! Accessor for this as the address of a raw XrExtent2Df
  XrExtent2Df const* get() const noexcept { return reinterpret_cast<XrExtent2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtent2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExtent2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Extent2Df{};
    }
    return reinterpret_cast<XrExtent2Df*>(this);
  }
  float width;
  float height;
};
static_assert(sizeof(XrExtent2Df) == sizeof(Extent2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtent2Df pointer to const from a Extent2Df reference to
 * const.
 * @relates Extent2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Df const* get(Extent2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent2Df as the address of a
 * raw XrExtent2Df
 * @relates Extent2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Df* put(Extent2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionSpaceCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSpaceCreateInfo>
 * @xrentity{XrActionSpaceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionSpaceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionSpaceCreateInfo(const Action& action_, const Path& subactionPath_,
                        const Posef& poseInActionSpace_, const void* next_ = nullptr)
      : Parent(StructureType::ActionSpaceCreateInfo, next_),
        action{action_},
        subactionPath{subactionPath_},
        poseInActionSpace{poseInActionSpace_} {}

  //! Default/empty constructor
  ActionSpaceCreateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::ActionSpaceCreateInfo, next_) {}

  //! Default copy constructor
  ActionSpaceCreateInfo(const ActionSpaceCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionSpaceCreateInfo& operator=(const ActionSpaceCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionSpaceCreateInfo(const XrActionSpaceCreateInfo& rhs) : ActionSpaceCreateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ActionSpaceCreateInfo& operator=(const XrActionSpaceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSpaceCreateInfo&() const {
    return *reinterpret_cast<const XrActionSpaceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSpaceCreateInfo&() { return *reinterpret_cast<XrActionSpaceCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionSpaceCreateInfo
  XrActionSpaceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionSpaceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSpaceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionSpaceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionSpaceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionSpaceCreateInfo*>(this);
  }
  Action action;
  Path subactionPath;
  Posef poseInActionSpace;
};
static_assert(sizeof(XrActionSpaceCreateInfo) == sizeof(ActionSpaceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSpaceCreateInfo pointer to const from a
 * ActionSpaceCreateInfo reference to const.
 * @relates ActionSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSpaceCreateInfo const* get(ActionSpaceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSpaceCreateInfo as the
 * address of a raw XrActionSpaceCreateInfo
 * @relates ActionSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSpaceCreateInfo* put(ActionSpaceCreateInfo& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceLocation
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceLocation>
 * @xrentity{XrSpaceLocation}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceLocation : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceLocation(

      void* next_ = nullptr)
      : Parent(StructureType::SpaceLocation, next_) {}

  //! Default copy constructor
  SpaceLocation(const SpaceLocation& rhs) = default;
  //! Default copy assignment
  SpaceLocation& operator=(const SpaceLocation& rhs) = default;
  //! Copy construct from raw
  SpaceLocation(const XrSpaceLocation& rhs) : SpaceLocation() { *put() = rhs; }
  //! Copy assign from raw
  SpaceLocation& operator=(const XrSpaceLocation& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceLocation&() const {
    return *reinterpret_cast<const XrSpaceLocation*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceLocation&() { return *reinterpret_cast<XrSpaceLocation*>(this); }

  //! Accessor for this as the address of a raw XrSpaceLocation
  XrSpaceLocation const* get() const noexcept {
    return reinterpret_cast<XrSpaceLocation const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceLocation.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceLocation* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceLocation{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceLocation*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
};
static_assert(sizeof(XrSpaceLocation) == sizeof(SpaceLocation),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceLocation pointer to const from a SpaceLocation
 * reference to const.
 * @relates SpaceLocation
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocation const* get(SpaceLocation const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceLocation as the address
 * of a raw XrSpaceLocation
 * @relates SpaceLocation
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocation* put(SpaceLocation& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewConfigurationProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationProperties>
 * @xrentity{XrViewConfigurationProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationProperties(

      void* next_ = nullptr)
      : Parent(StructureType::ViewConfigurationProperties, next_) {}

  //! Default copy constructor
  ViewConfigurationProperties(const ViewConfigurationProperties& rhs) = default;
  //! Default copy assignment
  ViewConfigurationProperties& operator=(const ViewConfigurationProperties& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationProperties(const XrViewConfigurationProperties& rhs)
      : ViewConfigurationProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationProperties& operator=(const XrViewConfigurationProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationProperties&() const {
    return *reinterpret_cast<const XrViewConfigurationProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationProperties&() {
    return *reinterpret_cast<XrViewConfigurationProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationProperties
  XrViewConfigurationProperties const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationProperties*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Bool32 fovMutable;
};
static_assert(sizeof(XrViewConfigurationProperties) == sizeof(ViewConfigurationProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationProperties pointer to const from a
 * ViewConfigurationProperties reference to const.
 * @relates ViewConfigurationProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationProperties const* get(
    ViewConfigurationProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationProperties
 * as the address of a raw XrViewConfigurationProperties
 * @relates ViewConfigurationProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationProperties* put(ViewConfigurationProperties& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewConfigurationView
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationView>
 * @xrentity{XrViewConfigurationView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationView : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationView(

      void* next_ = nullptr)
      : Parent(StructureType::ViewConfigurationView, next_) {}

  //! Default copy constructor
  ViewConfigurationView(const ViewConfigurationView& rhs) = default;
  //! Default copy assignment
  ViewConfigurationView& operator=(const ViewConfigurationView& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationView(const XrViewConfigurationView& rhs) : ViewConfigurationView() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationView& operator=(const XrViewConfigurationView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationView&() const {
    return *reinterpret_cast<const XrViewConfigurationView*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationView&() { return *reinterpret_cast<XrViewConfigurationView*>(this); }

  //! Accessor for this as the address of a raw XrViewConfigurationView
  XrViewConfigurationView const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationView const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewConfigurationView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationView{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationView*>(this);
  }
  uint32_t recommendedImageRectWidth;
  uint32_t maxImageRectWidth;
  uint32_t recommendedImageRectHeight;
  uint32_t maxImageRectHeight;
  uint32_t recommendedSwapchainSampleCount;
  uint32_t maxSwapchainSampleCount;
};
static_assert(sizeof(XrViewConfigurationView) == sizeof(ViewConfigurationView),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationView pointer to const from a
 * ViewConfigurationView reference to const.
 * @relates ViewConfigurationView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationView const* get(ViewConfigurationView const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationView as the
 * address of a raw XrViewConfigurationView
 * @relates ViewConfigurationView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationView* put(ViewConfigurationView& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainCreateInfo>
 * @xrentity{XrSwapchainCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SwapchainCreateInfo(const SwapchainCreateFlags& createFlags_,
                      const SwapchainUsageFlags& usageFlags_, int64_t format_,
                      uint32_t sampleCount_, uint32_t width_, uint32_t height_, uint32_t faceCount_,
                      uint32_t arraySize_, uint32_t mipCount_, const void* next_ = nullptr)
      : Parent(StructureType::SwapchainCreateInfo, next_),
        createFlags{createFlags_},
        usageFlags{usageFlags_},
        format{format_},
        sampleCount{sampleCount_},
        width{width_},
        height{height_},
        faceCount{faceCount_},
        arraySize{arraySize_},
        mipCount{mipCount_} {}

  //! Default/empty constructor
  SwapchainCreateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::SwapchainCreateInfo, next_) {}

  //! Default copy constructor
  SwapchainCreateInfo(const SwapchainCreateInfo& rhs) = default;
  //! Default copy assignment
  SwapchainCreateInfo& operator=(const SwapchainCreateInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainCreateInfo(const XrSwapchainCreateInfo& rhs) : SwapchainCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  SwapchainCreateInfo& operator=(const XrSwapchainCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainCreateInfo&() const {
    return *reinterpret_cast<const XrSwapchainCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainCreateInfo&() { return *reinterpret_cast<XrSwapchainCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrSwapchainCreateInfo
  XrSwapchainCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainCreateInfo*>(this);
  }
  SwapchainCreateFlags createFlags;
  SwapchainUsageFlags usageFlags;
  int64_t format;
  uint32_t sampleCount;
  uint32_t width;
  uint32_t height;
  uint32_t faceCount;
  uint32_t arraySize;
  uint32_t mipCount;
};
static_assert(sizeof(XrSwapchainCreateInfo) == sizeof(SwapchainCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainCreateInfo pointer to const from a
 * SwapchainCreateInfo reference to const.
 * @relates SwapchainCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfo const* get(SwapchainCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainCreateInfo as the
 * address of a raw XrSwapchainCreateInfo
 * @relates SwapchainCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfo* put(SwapchainCreateInfo& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageBaseHeader
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageBaseHeader>
 * @xrentity{XrSwapchainImageBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SwapchainImageBaseHeader : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SwapchainImageBaseHeader(StructureType type_, void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageBaseHeader&() const {
    return *reinterpret_cast<const XrSwapchainImageBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageBaseHeader&() {
    return *reinterpret_cast<XrSwapchainImageBaseHeader*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageBaseHeader
  XrSwapchainImageBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageBaseHeader) == sizeof(SwapchainImageBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageBaseHeader pointer to const from a
 * SwapchainImageBaseHeader reference to const.
 * @relates SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get(SwapchainImageBaseHeader const& s) {
  return s.get();
}

/*!
 * C++ projection of XrSwapchainImageAcquireInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageAcquireInfo>
 * @xrentity{XrSwapchainImageAcquireInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageAcquireInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SwapchainImageAcquireInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageAcquireInfo, next_) {}

  //! Default copy constructor
  SwapchainImageAcquireInfo(const SwapchainImageAcquireInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageAcquireInfo& operator=(const SwapchainImageAcquireInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageAcquireInfo(const XrSwapchainImageAcquireInfo& rhs) : SwapchainImageAcquireInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageAcquireInfo& operator=(const XrSwapchainImageAcquireInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageAcquireInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageAcquireInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageAcquireInfo&() {
    return *reinterpret_cast<XrSwapchainImageAcquireInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageAcquireInfo
  XrSwapchainImageAcquireInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageAcquireInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageAcquireInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageAcquireInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageAcquireInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageAcquireInfo*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageAcquireInfo) == sizeof(SwapchainImageAcquireInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageAcquireInfo pointer to const from a
 * SwapchainImageAcquireInfo reference to const.
 * @relates SwapchainImageAcquireInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageAcquireInfo const* get(
    SwapchainImageAcquireInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageAcquireInfo as
 * the address of a raw XrSwapchainImageAcquireInfo
 * @relates SwapchainImageAcquireInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageAcquireInfo* put(SwapchainImageAcquireInfo& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageWaitInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageWaitInfo>
 * @xrentity{XrSwapchainImageWaitInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageWaitInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SwapchainImageWaitInfo(const Duration& timeout_, const void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageWaitInfo, next_), timeout{timeout_} {}

  //! Default/empty constructor
  SwapchainImageWaitInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageWaitInfo, next_) {}

  //! Default copy constructor
  SwapchainImageWaitInfo(const SwapchainImageWaitInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageWaitInfo& operator=(const SwapchainImageWaitInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageWaitInfo(const XrSwapchainImageWaitInfo& rhs) : SwapchainImageWaitInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageWaitInfo& operator=(const XrSwapchainImageWaitInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageWaitInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageWaitInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageWaitInfo&() {
    return *reinterpret_cast<XrSwapchainImageWaitInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageWaitInfo
  XrSwapchainImageWaitInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageWaitInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageWaitInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageWaitInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageWaitInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageWaitInfo*>(this);
  }
  Duration timeout;
};
static_assert(sizeof(XrSwapchainImageWaitInfo) == sizeof(SwapchainImageWaitInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageWaitInfo pointer to const from a
 * SwapchainImageWaitInfo reference to const.
 * @relates SwapchainImageWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageWaitInfo const* get(SwapchainImageWaitInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageWaitInfo as the
 * address of a raw XrSwapchainImageWaitInfo
 * @relates SwapchainImageWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageWaitInfo* put(SwapchainImageWaitInfo& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageReleaseInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageReleaseInfo>
 * @xrentity{XrSwapchainImageReleaseInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageReleaseInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SwapchainImageReleaseInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageReleaseInfo, next_) {}

  //! Default copy constructor
  SwapchainImageReleaseInfo(const SwapchainImageReleaseInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageReleaseInfo& operator=(const SwapchainImageReleaseInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageReleaseInfo(const XrSwapchainImageReleaseInfo& rhs) : SwapchainImageReleaseInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageReleaseInfo& operator=(const XrSwapchainImageReleaseInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageReleaseInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageReleaseInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageReleaseInfo&() {
    return *reinterpret_cast<XrSwapchainImageReleaseInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageReleaseInfo
  XrSwapchainImageReleaseInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageReleaseInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageReleaseInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageReleaseInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageReleaseInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageReleaseInfo*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageReleaseInfo) == sizeof(SwapchainImageReleaseInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageReleaseInfo pointer to const from a
 * SwapchainImageReleaseInfo reference to const.
 * @relates SwapchainImageReleaseInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageReleaseInfo const* get(
    SwapchainImageReleaseInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageReleaseInfo as
 * the address of a raw XrSwapchainImageReleaseInfo
 * @relates SwapchainImageReleaseInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageReleaseInfo* put(SwapchainImageReleaseInfo& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionBeginInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionBeginInfo>
 * @xrentity{XrSessionBeginInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionBeginInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionBeginInfo(const ViewConfigurationType& primaryViewConfigurationType_,
                   const void* next_ = nullptr)
      : Parent(StructureType::SessionBeginInfo, next_),
        primaryViewConfigurationType{primaryViewConfigurationType_} {}

  //! Default/empty constructor
  SessionBeginInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::SessionBeginInfo, next_) {}

  //! Default copy constructor
  SessionBeginInfo(const SessionBeginInfo& rhs) = default;
  //! Default copy assignment
  SessionBeginInfo& operator=(const SessionBeginInfo& rhs) = default;
  //! Copy construct from raw
  SessionBeginInfo(const XrSessionBeginInfo& rhs) : SessionBeginInfo() { *put() = rhs; }
  //! Copy assign from raw
  SessionBeginInfo& operator=(const XrSessionBeginInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionBeginInfo&() const {
    return *reinterpret_cast<const XrSessionBeginInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionBeginInfo&() { return *reinterpret_cast<XrSessionBeginInfo*>(this); }

  //! Accessor for this as the address of a raw XrSessionBeginInfo
  XrSessionBeginInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionBeginInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSessionBeginInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionBeginInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionBeginInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionBeginInfo*>(this);
  }
  ViewConfigurationType primaryViewConfigurationType;
};
static_assert(sizeof(XrSessionBeginInfo) == sizeof(SessionBeginInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionBeginInfo pointer to const from a
 * SessionBeginInfo reference to const.
 * @relates SessionBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionBeginInfo const* get(SessionBeginInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionBeginInfo as the
 * address of a raw XrSessionBeginInfo
 * @relates SessionBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionBeginInfo* put(SessionBeginInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameWaitInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameWaitInfo>
 * @xrentity{XrFrameWaitInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameWaitInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  FrameWaitInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::FrameWaitInfo, next_) {}

  //! Default copy constructor
  FrameWaitInfo(const FrameWaitInfo& rhs) = default;
  //! Default copy assignment
  FrameWaitInfo& operator=(const FrameWaitInfo& rhs) = default;
  //! Copy construct from raw
  FrameWaitInfo(const XrFrameWaitInfo& rhs) : FrameWaitInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameWaitInfo& operator=(const XrFrameWaitInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameWaitInfo&() const {
    return *reinterpret_cast<const XrFrameWaitInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameWaitInfo&() { return *reinterpret_cast<XrFrameWaitInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameWaitInfo
  XrFrameWaitInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameWaitInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameWaitInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameWaitInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameWaitInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameWaitInfo*>(this);
  }
};
static_assert(sizeof(XrFrameWaitInfo) == sizeof(FrameWaitInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameWaitInfo pointer to const from a FrameWaitInfo
 * reference to const.
 * @relates FrameWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameWaitInfo const* get(FrameWaitInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameWaitInfo as the address
 * of a raw XrFrameWaitInfo
 * @relates FrameWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameWaitInfo* put(FrameWaitInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameState
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameState>
 * @xrentity{XrFrameState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FrameState(

      void* next_ = nullptr)
      : Parent(StructureType::FrameState, next_) {}

  //! Default copy constructor
  FrameState(const FrameState& rhs) = default;
  //! Default copy assignment
  FrameState& operator=(const FrameState& rhs) = default;
  //! Copy construct from raw
  FrameState(const XrFrameState& rhs) : FrameState() { *put() = rhs; }
  //! Copy assign from raw
  FrameState& operator=(const XrFrameState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameState&() const { return *reinterpret_cast<const XrFrameState*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameState&() { return *reinterpret_cast<XrFrameState*>(this); }

  //! Accessor for this as the address of a raw XrFrameState
  XrFrameState const* get() const noexcept { return reinterpret_cast<XrFrameState const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameState{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameState*>(this);
  }
  Time predictedDisplayTime;
  Duration predictedDisplayPeriod;
  Bool32 shouldRender;
};
static_assert(sizeof(XrFrameState) == sizeof(FrameState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameState pointer to const from a FrameState reference
 * to const.
 * @relates FrameState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameState const* get(FrameState const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameState as the address of
 * a raw XrFrameState
 * @relates FrameState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameState* put(FrameState& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameBeginInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameBeginInfo>
 * @xrentity{XrFrameBeginInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameBeginInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  FrameBeginInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::FrameBeginInfo, next_) {}

  //! Default copy constructor
  FrameBeginInfo(const FrameBeginInfo& rhs) = default;
  //! Default copy assignment
  FrameBeginInfo& operator=(const FrameBeginInfo& rhs) = default;
  //! Copy construct from raw
  FrameBeginInfo(const XrFrameBeginInfo& rhs) : FrameBeginInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameBeginInfo& operator=(const XrFrameBeginInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameBeginInfo&() const {
    return *reinterpret_cast<const XrFrameBeginInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameBeginInfo&() { return *reinterpret_cast<XrFrameBeginInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameBeginInfo
  XrFrameBeginInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameBeginInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameBeginInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameBeginInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameBeginInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameBeginInfo*>(this);
  }
};
static_assert(sizeof(XrFrameBeginInfo) == sizeof(FrameBeginInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameBeginInfo pointer to const from a FrameBeginInfo
 * reference to const.
 * @relates FrameBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameBeginInfo const* get(FrameBeginInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameBeginInfo as the address
 * of a raw XrFrameBeginInfo
 * @relates FrameBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameBeginInfo* put(FrameBeginInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerBaseHeader
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerBaseHeader>
 * @xrentity{XrCompositionLayerBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS CompositionLayerBaseHeader : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  CompositionLayerBaseHeader(StructureType type_, const CompositionLayerFlags& layerFlags_,
                             const Space& space_, const void* next_ = nullptr)
      : Parent(type_, next_), layerFlags{layerFlags_}, space{space_} {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerBaseHeader&() const {
    return *reinterpret_cast<const XrCompositionLayerBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerBaseHeader&() {
    return *reinterpret_cast<XrCompositionLayerBaseHeader*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerBaseHeader
  XrCompositionLayerBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }

  CompositionLayerFlags layerFlags;
  Space space;
};
static_assert(sizeof(XrCompositionLayerBaseHeader) == sizeof(CompositionLayerBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerBaseHeader pointer to const from a
 * CompositionLayerBaseHeader reference to const.
 * @relates CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get(
    CompositionLayerBaseHeader const& s) {
  return s.get();
}

/*!
 * C++ projection of XrFrameEndInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameEndInfo>
 * @xrentity{XrFrameEndInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameEndInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FrameEndInfo(const Time& displayTime_, const EnvironmentBlendMode& environmentBlendMode_,
               uint32_t layerCount_, const CompositionLayerBaseHeader* const* layers_,
               const void* next_ = nullptr)
      : Parent(StructureType::FrameEndInfo, next_),
        displayTime{displayTime_},
        environmentBlendMode{environmentBlendMode_},
        layerCount{layerCount_},
        layers{layers_} {}

  //! Default/empty constructor
  FrameEndInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::FrameEndInfo, next_) {}

  //! Default copy constructor
  FrameEndInfo(const FrameEndInfo& rhs) = default;
  //! Default copy assignment
  FrameEndInfo& operator=(const FrameEndInfo& rhs) = default;
  //! Copy construct from raw
  FrameEndInfo(const XrFrameEndInfo& rhs) : FrameEndInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameEndInfo& operator=(const XrFrameEndInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameEndInfo&() const { return *reinterpret_cast<const XrFrameEndInfo*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameEndInfo&() { return *reinterpret_cast<XrFrameEndInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameEndInfo
  XrFrameEndInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameEndInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameEndInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameEndInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameEndInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameEndInfo*>(this);
  }
  Time displayTime;
  EnvironmentBlendMode environmentBlendMode;
  uint32_t layerCount;
  const CompositionLayerBaseHeader* const* layers;
};
static_assert(sizeof(XrFrameEndInfo) == sizeof(FrameEndInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameEndInfo pointer to const from a FrameEndInfo
 * reference to const.
 * @relates FrameEndInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameEndInfo const* get(FrameEndInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameEndInfo as the address
 * of a raw XrFrameEndInfo
 * @relates FrameEndInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameEndInfo* put(FrameEndInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewLocateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewLocateInfo>
 * @xrentity{XrViewLocateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewLocateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ViewLocateInfo(const ViewConfigurationType& viewConfigurationType_, const Time& displayTime_,
                 const Space& space_, const void* next_ = nullptr)
      : Parent(StructureType::ViewLocateInfo, next_),
        viewConfigurationType{viewConfigurationType_},
        displayTime{displayTime_},
        space{space_} {}

  //! Default/empty constructor
  ViewLocateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::ViewLocateInfo, next_) {}

  //! Default copy constructor
  ViewLocateInfo(const ViewLocateInfo& rhs) = default;
  //! Default copy assignment
  ViewLocateInfo& operator=(const ViewLocateInfo& rhs) = default;
  //! Copy construct from raw
  ViewLocateInfo(const XrViewLocateInfo& rhs) : ViewLocateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ViewLocateInfo& operator=(const XrViewLocateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewLocateInfo&() const {
    return *reinterpret_cast<const XrViewLocateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewLocateInfo&() { return *reinterpret_cast<XrViewLocateInfo*>(this); }

  //! Accessor for this as the address of a raw XrViewLocateInfo
  XrViewLocateInfo const* get() const noexcept {
    return reinterpret_cast<XrViewLocateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewLocateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewLocateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewLocateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewLocateInfo*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Time displayTime;
  Space space;
};
static_assert(sizeof(XrViewLocateInfo) == sizeof(ViewLocateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewLocateInfo pointer to const from a ViewLocateInfo
 * reference to const.
 * @relates ViewLocateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateInfo const* get(ViewLocateInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewLocateInfo as the address
 * of a raw XrViewLocateInfo
 * @relates ViewLocateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateInfo* put(ViewLocateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewState
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewState>
 * @xrentity{XrViewState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewState(

      void* next_ = nullptr)
      : Parent(StructureType::ViewState, next_) {}

  //! Default copy constructor
  ViewState(const ViewState& rhs) = default;
  //! Default copy assignment
  ViewState& operator=(const ViewState& rhs) = default;
  //! Copy construct from raw
  ViewState(const XrViewState& rhs) : ViewState() { *put() = rhs; }
  //! Copy assign from raw
  ViewState& operator=(const XrViewState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewState&() const { return *reinterpret_cast<const XrViewState*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewState&() { return *reinterpret_cast<XrViewState*>(this); }

  //! Accessor for this as the address of a raw XrViewState
  XrViewState const* get() const noexcept { return reinterpret_cast<XrViewState const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewState{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewState*>(this);
  }
  ViewStateFlags viewStateFlags;
};
static_assert(sizeof(XrViewState) == sizeof(ViewState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewState pointer to const from a ViewState reference to
 * const.
 * @relates ViewState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewState const* get(ViewState const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewState as the address of a
 * raw XrViewState
 * @relates ViewState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewState* put(ViewState& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFovf
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFovf>
 * @xrentity{XrFovf}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Fovf {
public:
  //! Constructor initializing all members.
  Fovf(float angleLeft_, float angleRight_, float angleUp_, float angleDown_)
      : angleLeft{angleLeft_}, angleRight{angleRight_}, angleUp{angleUp_}, angleDown{angleDown_} {}

  //! Default/empty constructor
  Fovf(

  ) {}

  //! Default copy constructor
  Fovf(const Fovf& rhs) = default;
  //! Default copy assignment
  Fovf& operator=(const Fovf& rhs) = default;
  //! Copy construct from raw
  Fovf(const XrFovf& rhs) : Fovf() { *put() = rhs; }
  //! Copy assign from raw
  Fovf& operator=(const XrFovf& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFovf&() const { return *reinterpret_cast<const XrFovf*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFovf&() { return *reinterpret_cast<XrFovf*>(this); }

  //! Accessor for this as the address of a raw XrFovf
  XrFovf const* get() const noexcept { return reinterpret_cast<XrFovf const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFovf.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrFovf* put(bool clear = true) noexcept {
    if (clear) {
      *this = Fovf{};
    }
    return reinterpret_cast<XrFovf*>(this);
  }
  float angleLeft;
  float angleRight;
  float angleUp;
  float angleDown;
};
static_assert(sizeof(XrFovf) == sizeof(Fovf), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFovf pointer to const from a Fovf reference to const.
 * @relates Fovf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFovf const* get(Fovf const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Fovf as the address of a raw
 * XrFovf
 * @relates Fovf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFovf* put(Fovf& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrView
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrView>
 * @xrentity{XrView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS View : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  View(

      void* next_ = nullptr)
      : Parent(StructureType::View, next_) {}

  //! Default copy constructor
  View(const View& rhs) = default;
  //! Default copy assignment
  View& operator=(const View& rhs) = default;
  //! Copy construct from raw
  View(const XrView& rhs) : View() { *put() = rhs; }
  //! Copy assign from raw
  View& operator=(const XrView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrView&() const { return *reinterpret_cast<const XrView*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrView&() { return *reinterpret_cast<XrView*>(this); }

  //! Accessor for this as the address of a raw XrView
  XrView const* get() const noexcept { return reinterpret_cast<XrView const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = View{};
      next = oldNext;
    }
    return reinterpret_cast<XrView*>(this);
  }
  Posef pose;
  Fovf fov;
};
static_assert(sizeof(XrView) == sizeof(View), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrView pointer to const from a View reference to const.
 * @relates View
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrView const* get(View const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing View as the address of a raw
 * XrView
 * @relates View
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrView* put(View& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrActionSetCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSetCreateInfo>
 * @xrentity{XrActionSetCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionSetCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionSetCreateInfo(const char* actionSetName_, const char* localizedActionSetName_,
                      uint32_t priority_, const void* next_ = nullptr)
      : Parent(StructureType::ActionSetCreateInfo, next_), priority{priority_} {
    if (nullptr != actionSetName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(actionSetName, XR_MAX_ACTION_SET_NAME_SIZE, actionSetName_,
                XR_MAX_ACTION_SET_NAME_SIZE);
#else
      strncpy(actionSetName, actionSetName_, XR_MAX_ACTION_SET_NAME_SIZE - 1);
      actionSetName[XR_MAX_ACTION_SET_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != localizedActionSetName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(localizedActionSetName, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE,
                localizedActionSetName_, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE);
#else
      strncpy(localizedActionSetName, localizedActionSetName_,
              XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE - 1);
      localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ActionSetCreateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::ActionSetCreateInfo, next_) {}

  //! Default copy constructor
  ActionSetCreateInfo(const ActionSetCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionSetCreateInfo& operator=(const ActionSetCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionSetCreateInfo(const XrActionSetCreateInfo& rhs) : ActionSetCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionSetCreateInfo& operator=(const XrActionSetCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSetCreateInfo&() const {
    return *reinterpret_cast<const XrActionSetCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSetCreateInfo&() { return *reinterpret_cast<XrActionSetCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionSetCreateInfo
  XrActionSetCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionSetCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSetCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionSetCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionSetCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionSetCreateInfo*>(this);
  }
  char actionSetName[XR_MAX_ACTION_SET_NAME_SIZE];
  char localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE];
  uint32_t priority;
};
static_assert(sizeof(XrActionSetCreateInfo) == sizeof(ActionSetCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSetCreateInfo pointer to const from a
 * ActionSetCreateInfo reference to const.
 * @relates ActionSetCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSetCreateInfo const* get(ActionSetCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSetCreateInfo as the
 * address of a raw XrActionSetCreateInfo
 * @relates ActionSetCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSetCreateInfo* put(ActionSetCreateInfo& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionCreateInfo>
 * @xrentity{XrActionCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionCreateInfo(const char* actionName_, const ActionType& actionType_,
                   uint32_t countSubactionPaths_, const Path* subactionPaths_,
                   const char* localizedActionName_, const void* next_ = nullptr)
      : Parent(StructureType::ActionCreateInfo, next_),
        actionType{actionType_},
        countSubactionPaths{countSubactionPaths_},
        subactionPaths{subactionPaths_} {
    if (nullptr != actionName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(actionName, XR_MAX_ACTION_NAME_SIZE, actionName_, XR_MAX_ACTION_NAME_SIZE);
#else
      strncpy(actionName, actionName_, XR_MAX_ACTION_NAME_SIZE - 1);
      actionName[XR_MAX_ACTION_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != localizedActionName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(localizedActionName, XR_MAX_LOCALIZED_ACTION_NAME_SIZE, localizedActionName_,
                XR_MAX_LOCALIZED_ACTION_NAME_SIZE);
#else
      strncpy(localizedActionName, localizedActionName_, XR_MAX_LOCALIZED_ACTION_NAME_SIZE - 1);
      localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ActionCreateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::ActionCreateInfo, next_) {}

  //! Default copy constructor
  ActionCreateInfo(const ActionCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionCreateInfo& operator=(const ActionCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionCreateInfo(const XrActionCreateInfo& rhs) : ActionCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionCreateInfo& operator=(const XrActionCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionCreateInfo&() const {
    return *reinterpret_cast<const XrActionCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionCreateInfo&() { return *reinterpret_cast<XrActionCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionCreateInfo
  XrActionCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionCreateInfo*>(this);
  }
  char actionName[XR_MAX_ACTION_NAME_SIZE];
  ActionType actionType;
  uint32_t countSubactionPaths;
  const Path* subactionPaths;
  char localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE];
};
static_assert(sizeof(XrActionCreateInfo) == sizeof(ActionCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionCreateInfo pointer to const from a
 * ActionCreateInfo reference to const.
 * @relates ActionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionCreateInfo const* get(ActionCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionCreateInfo as the
 * address of a raw XrActionCreateInfo
 * @relates ActionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionCreateInfo* put(ActionCreateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionSuggestedBinding
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSuggestedBinding>
 * @xrentity{XrActionSuggestedBinding}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ActionSuggestedBinding {
public:
  //! Constructor initializing all members.
  ActionSuggestedBinding(const Action& action_, const Path& binding_)
      : action{action_}, binding{binding_} {}

  //! Default/empty constructor
  ActionSuggestedBinding(

  ) {}

  //! Default copy constructor
  ActionSuggestedBinding(const ActionSuggestedBinding& rhs) = default;
  //! Default copy assignment
  ActionSuggestedBinding& operator=(const ActionSuggestedBinding& rhs) = default;
  //! Copy construct from raw
  ActionSuggestedBinding(const XrActionSuggestedBinding& rhs) : ActionSuggestedBinding() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ActionSuggestedBinding& operator=(const XrActionSuggestedBinding& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSuggestedBinding&() const {
    return *reinterpret_cast<const XrActionSuggestedBinding*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSuggestedBinding&() {
    return *reinterpret_cast<XrActionSuggestedBinding*>(this);
  }

  //! Accessor for this as the address of a raw XrActionSuggestedBinding
  XrActionSuggestedBinding const* get() const noexcept {
    return reinterpret_cast<XrActionSuggestedBinding const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSuggestedBinding.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrActionSuggestedBinding* put(bool clear = true) noexcept {
    if (clear) {
      *this = ActionSuggestedBinding{};
    }
    return reinterpret_cast<XrActionSuggestedBinding*>(this);
  }
  Action action;
  Path binding;
};
static_assert(sizeof(XrActionSuggestedBinding) == sizeof(ActionSuggestedBinding),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSuggestedBinding pointer to const from a
 * ActionSuggestedBinding reference to const.
 * @relates ActionSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSuggestedBinding const* get(ActionSuggestedBinding const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSuggestedBinding as the
 * address of a raw XrActionSuggestedBinding
 * @relates ActionSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSuggestedBinding* put(ActionSuggestedBinding& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInteractionProfileSuggestedBinding
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileSuggestedBinding>
 * @xrentity{XrInteractionProfileSuggestedBinding}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileSuggestedBinding : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InteractionProfileSuggestedBinding(const Path& interactionProfile_,
                                     uint32_t countSuggestedBindings_,
                                     const ActionSuggestedBinding* suggestedBindings_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileSuggestedBinding, next_),
        interactionProfile{interactionProfile_},
        countSuggestedBindings{countSuggestedBindings_},
        suggestedBindings{suggestedBindings_} {}

  //! Default/empty constructor
  InteractionProfileSuggestedBinding(

      const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileSuggestedBinding, next_) {}

  //! Default copy constructor
  InteractionProfileSuggestedBinding(const InteractionProfileSuggestedBinding& rhs) = default;
  //! Default copy assignment
  InteractionProfileSuggestedBinding& operator=(const InteractionProfileSuggestedBinding& rhs) =
      default;
  //! Copy construct from raw
  InteractionProfileSuggestedBinding(const XrInteractionProfileSuggestedBinding& rhs)
      : InteractionProfileSuggestedBinding() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileSuggestedBinding& operator=(const XrInteractionProfileSuggestedBinding& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileSuggestedBinding&() const {
    return *reinterpret_cast<const XrInteractionProfileSuggestedBinding*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileSuggestedBinding&() {
    return *reinterpret_cast<XrInteractionProfileSuggestedBinding*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionProfileSuggestedBinding
  XrInteractionProfileSuggestedBinding const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileSuggestedBinding const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileSuggestedBinding.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileSuggestedBinding* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileSuggestedBinding{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileSuggestedBinding*>(this);
  }
  Path interactionProfile;
  uint32_t countSuggestedBindings;
  const ActionSuggestedBinding* suggestedBindings;
};
static_assert(sizeof(XrInteractionProfileSuggestedBinding) ==
                  sizeof(InteractionProfileSuggestedBinding),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileSuggestedBinding pointer to const from
 * a InteractionProfileSuggestedBinding reference to const.
 * @relates InteractionProfileSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileSuggestedBinding const* get(
    InteractionProfileSuggestedBinding const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionProfileSuggestedBinding as the address of a raw XrInteractionProfileSuggestedBinding
 * @relates InteractionProfileSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileSuggestedBinding* put(
    InteractionProfileSuggestedBinding& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionActionSetsAttachInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionActionSetsAttachInfo>
 * @xrentity{XrSessionActionSetsAttachInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionActionSetsAttachInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionActionSetsAttachInfo(uint32_t countActionSets_, const ActionSet* actionSets_,
                              const void* next_ = nullptr)
      : Parent(StructureType::SessionActionSetsAttachInfo, next_),
        countActionSets{countActionSets_},
        actionSets{actionSets_} {}

  //! Default/empty constructor
  SessionActionSetsAttachInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::SessionActionSetsAttachInfo, next_) {}

  //! Default copy constructor
  SessionActionSetsAttachInfo(const SessionActionSetsAttachInfo& rhs) = default;
  //! Default copy assignment
  SessionActionSetsAttachInfo& operator=(const SessionActionSetsAttachInfo& rhs) = default;
  //! Copy construct from raw
  SessionActionSetsAttachInfo(const XrSessionActionSetsAttachInfo& rhs)
      : SessionActionSetsAttachInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SessionActionSetsAttachInfo& operator=(const XrSessionActionSetsAttachInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionActionSetsAttachInfo&() const {
    return *reinterpret_cast<const XrSessionActionSetsAttachInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionActionSetsAttachInfo&() {
    return *reinterpret_cast<XrSessionActionSetsAttachInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSessionActionSetsAttachInfo
  XrSessionActionSetsAttachInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionActionSetsAttachInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSessionActionSetsAttachInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionActionSetsAttachInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionActionSetsAttachInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionActionSetsAttachInfo*>(this);
  }
  uint32_t countActionSets;
  const ActionSet* actionSets;
};
static_assert(sizeof(XrSessionActionSetsAttachInfo) == sizeof(SessionActionSetsAttachInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionActionSetsAttachInfo pointer to const from a
 * SessionActionSetsAttachInfo reference to const.
 * @relates SessionActionSetsAttachInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionActionSetsAttachInfo const* get(
    SessionActionSetsAttachInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionActionSetsAttachInfo
 * as the address of a raw XrSessionActionSetsAttachInfo
 * @relates SessionActionSetsAttachInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionActionSetsAttachInfo* put(SessionActionSetsAttachInfo& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInteractionProfileState
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileState>
 * @xrentity{XrInteractionProfileState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  InteractionProfileState(

      void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileState, next_) {}

  //! Default copy constructor
  InteractionProfileState(const InteractionProfileState& rhs) = default;
  //! Default copy assignment
  InteractionProfileState& operator=(const InteractionProfileState& rhs) = default;
  //! Copy construct from raw
  InteractionProfileState(const XrInteractionProfileState& rhs) : InteractionProfileState() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileState& operator=(const XrInteractionProfileState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileState&() const {
    return *reinterpret_cast<const XrInteractionProfileState*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileState&() {
    return *reinterpret_cast<XrInteractionProfileState*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionProfileState
  XrInteractionProfileState const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileState const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileState{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileState*>(this);
  }
  Path interactionProfile;
};
static_assert(sizeof(XrInteractionProfileState) == sizeof(InteractionProfileState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileState pointer to const from a
 * InteractionProfileState reference to const.
 * @relates InteractionProfileState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileState const* get(InteractionProfileState const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InteractionProfileState as
 * the address of a raw XrInteractionProfileState
 * @relates InteractionProfileState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileState* put(InteractionProfileState& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateGetInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateGetInfo>
 * @xrentity{XrActionStateGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionStateGetInfo(const Action& action_, const Path& subactionPath_, const void* next_ = nullptr)
      : Parent(StructureType::ActionStateGetInfo, next_),
        action{action_},
        subactionPath{subactionPath_} {}

  //! Default/empty constructor
  ActionStateGetInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::ActionStateGetInfo, next_) {}

  //! Default copy constructor
  ActionStateGetInfo(const ActionStateGetInfo& rhs) = default;
  //! Default copy assignment
  ActionStateGetInfo& operator=(const ActionStateGetInfo& rhs) = default;
  //! Copy construct from raw
  ActionStateGetInfo(const XrActionStateGetInfo& rhs) : ActionStateGetInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateGetInfo& operator=(const XrActionStateGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateGetInfo&() const {
    return *reinterpret_cast<const XrActionStateGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateGetInfo&() { return *reinterpret_cast<XrActionStateGetInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionStateGetInfo
  XrActionStateGetInfo const* get() const noexcept {
    return reinterpret_cast<XrActionStateGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateGetInfo*>(this);
  }
  Action action;
  Path subactionPath;
};
static_assert(sizeof(XrActionStateGetInfo) == sizeof(ActionStateGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateGetInfo pointer to const from a
 * ActionStateGetInfo reference to const.
 * @relates ActionStateGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateGetInfo const* get(ActionStateGetInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateGetInfo as the
 * address of a raw XrActionStateGetInfo
 * @relates ActionStateGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateGetInfo* put(ActionStateGetInfo& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateBoolean
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateBoolean>
 * @xrentity{XrActionStateBoolean}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateBoolean : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateBoolean(

      void* next_ = nullptr)
      : Parent(StructureType::ActionStateBoolean, next_) {}

  //! Default copy constructor
  ActionStateBoolean(const ActionStateBoolean& rhs) = default;
  //! Default copy assignment
  ActionStateBoolean& operator=(const ActionStateBoolean& rhs) = default;
  //! Copy construct from raw
  ActionStateBoolean(const XrActionStateBoolean& rhs) : ActionStateBoolean() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateBoolean& operator=(const XrActionStateBoolean& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateBoolean&() const {
    return *reinterpret_cast<const XrActionStateBoolean*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateBoolean&() { return *reinterpret_cast<XrActionStateBoolean*>(this); }

  //! Accessor for this as the address of a raw XrActionStateBoolean
  XrActionStateBoolean const* get() const noexcept {
    return reinterpret_cast<XrActionStateBoolean const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateBoolean.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateBoolean* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateBoolean{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateBoolean*>(this);
  }
  Bool32 currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateBoolean) == sizeof(ActionStateBoolean),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateBoolean pointer to const from a
 * ActionStateBoolean reference to const.
 * @relates ActionStateBoolean
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateBoolean const* get(ActionStateBoolean const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateBoolean as the
 * address of a raw XrActionStateBoolean
 * @relates ActionStateBoolean
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateBoolean* put(ActionStateBoolean& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateFloat
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateFloat>
 * @xrentity{XrActionStateFloat}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateFloat : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateFloat(

      void* next_ = nullptr)
      : Parent(StructureType::ActionStateFloat, next_) {}

  //! Default copy constructor
  ActionStateFloat(const ActionStateFloat& rhs) = default;
  //! Default copy assignment
  ActionStateFloat& operator=(const ActionStateFloat& rhs) = default;
  //! Copy construct from raw
  ActionStateFloat(const XrActionStateFloat& rhs) : ActionStateFloat() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateFloat& operator=(const XrActionStateFloat& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateFloat&() const {
    return *reinterpret_cast<const XrActionStateFloat*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateFloat&() { return *reinterpret_cast<XrActionStateFloat*>(this); }

  //! Accessor for this as the address of a raw XrActionStateFloat
  XrActionStateFloat const* get() const noexcept {
    return reinterpret_cast<XrActionStateFloat const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateFloat.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateFloat* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateFloat{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateFloat*>(this);
  }
  float currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateFloat) == sizeof(ActionStateFloat),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateFloat pointer to const from a
 * ActionStateFloat reference to const.
 * @relates ActionStateFloat
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateFloat const* get(ActionStateFloat const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateFloat as the
 * address of a raw XrActionStateFloat
 * @relates ActionStateFloat
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateFloat* put(ActionStateFloat& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector2f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector2f>
 * @xrentity{XrVector2f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector2f {
public:
  //! Constructor initializing all members.
  Vector2f(float x_, float y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Vector2f(

  ) {}

  //! Default copy constructor
  Vector2f(const Vector2f& rhs) = default;
  //! Default copy assignment
  Vector2f& operator=(const Vector2f& rhs) = default;
  //! Copy construct from raw
  Vector2f(const XrVector2f& rhs) : Vector2f() { *put() = rhs; }
  //! Copy assign from raw
  Vector2f& operator=(const XrVector2f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector2f&() const { return *reinterpret_cast<const XrVector2f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector2f&() { return *reinterpret_cast<XrVector2f*>(this); }

  //! Accessor for this as the address of a raw XrVector2f
  XrVector2f const* get() const noexcept { return reinterpret_cast<XrVector2f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector2f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector2f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector2f{};
    }
    return reinterpret_cast<XrVector2f*>(this);
  }
  float x;
  float y;
};
static_assert(sizeof(XrVector2f) == sizeof(Vector2f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector2f pointer to const from a Vector2f reference to
 * const.
 * @relates Vector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector2f const* get(Vector2f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector2f as the address of a
 * raw XrVector2f
 * @relates Vector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector2f* put(Vector2f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateVector2f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateVector2f>
 * @xrentity{XrActionStateVector2f}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateVector2f : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateVector2f(

      void* next_ = nullptr)
      : Parent(StructureType::ActionStateVector2F, next_) {}

  //! Default copy constructor
  ActionStateVector2f(const ActionStateVector2f& rhs) = default;
  //! Default copy assignment
  ActionStateVector2f& operator=(const ActionStateVector2f& rhs) = default;
  //! Copy construct from raw
  ActionStateVector2f(const XrActionStateVector2f& rhs) : ActionStateVector2f() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateVector2f& operator=(const XrActionStateVector2f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateVector2f&() const {
    return *reinterpret_cast<const XrActionStateVector2f*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateVector2f&() { return *reinterpret_cast<XrActionStateVector2f*>(this); }

  //! Accessor for this as the address of a raw XrActionStateVector2f
  XrActionStateVector2f const* get() const noexcept {
    return reinterpret_cast<XrActionStateVector2f const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateVector2f.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateVector2f* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateVector2f{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateVector2f*>(this);
  }
  Vector2f currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateVector2f) == sizeof(ActionStateVector2f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateVector2f pointer to const from a
 * ActionStateVector2f reference to const.
 * @relates ActionStateVector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateVector2f const* get(ActionStateVector2f const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateVector2f as the
 * address of a raw XrActionStateVector2f
 * @relates ActionStateVector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateVector2f* put(ActionStateVector2f& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStatePose
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStatePose>
 * @xrentity{XrActionStatePose}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStatePose : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStatePose(

      void* next_ = nullptr)
      : Parent(StructureType::ActionStatePose, next_) {}

  //! Default copy constructor
  ActionStatePose(const ActionStatePose& rhs) = default;
  //! Default copy assignment
  ActionStatePose& operator=(const ActionStatePose& rhs) = default;
  //! Copy construct from raw
  ActionStatePose(const XrActionStatePose& rhs) : ActionStatePose() { *put() = rhs; }
  //! Copy assign from raw
  ActionStatePose& operator=(const XrActionStatePose& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStatePose&() const {
    return *reinterpret_cast<const XrActionStatePose*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStatePose&() { return *reinterpret_cast<XrActionStatePose*>(this); }

  //! Accessor for this as the address of a raw XrActionStatePose
  XrActionStatePose const* get() const noexcept {
    return reinterpret_cast<XrActionStatePose const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStatePose.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStatePose* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStatePose{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStatePose*>(this);
  }
  Bool32 isActive;
};
static_assert(sizeof(XrActionStatePose) == sizeof(ActionStatePose),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStatePose pointer to const from a ActionStatePose
 * reference to const.
 * @relates ActionStatePose
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStatePose const* get(ActionStatePose const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStatePose as the
 * address of a raw XrActionStatePose
 * @relates ActionStatePose
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStatePose* put(ActionStatePose& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActiveActionSet
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActiveActionSet>
 * @xrentity{XrActiveActionSet}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ActiveActionSet {
public:
  //! Constructor initializing all members.
  ActiveActionSet(const ActionSet& actionSet_, const Path& subactionPath_)
      : actionSet{actionSet_}, subactionPath{subactionPath_} {}

  //! Default/empty constructor
  ActiveActionSet(

  ) {}

  //! Default copy constructor
  ActiveActionSet(const ActiveActionSet& rhs) = default;
  //! Default copy assignment
  ActiveActionSet& operator=(const ActiveActionSet& rhs) = default;
  //! Copy construct from raw
  ActiveActionSet(const XrActiveActionSet& rhs) : ActiveActionSet() { *put() = rhs; }
  //! Copy assign from raw
  ActiveActionSet& operator=(const XrActiveActionSet& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActiveActionSet&() const {
    return *reinterpret_cast<const XrActiveActionSet*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActiveActionSet&() { return *reinterpret_cast<XrActiveActionSet*>(this); }

  //! Accessor for this as the address of a raw XrActiveActionSet
  XrActiveActionSet const* get() const noexcept {
    return reinterpret_cast<XrActiveActionSet const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActiveActionSet.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrActiveActionSet* put(bool clear = true) noexcept {
    if (clear) {
      *this = ActiveActionSet{};
    }
    return reinterpret_cast<XrActiveActionSet*>(this);
  }
  ActionSet actionSet;
  Path subactionPath;
};
static_assert(sizeof(XrActiveActionSet) == sizeof(ActiveActionSet),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActiveActionSet pointer to const from a ActiveActionSet
 * reference to const.
 * @relates ActiveActionSet
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSet const* get(ActiveActionSet const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActiveActionSet as the
 * address of a raw XrActiveActionSet
 * @relates ActiveActionSet
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSet* put(ActiveActionSet& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionsSyncInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionsSyncInfo>
 * @xrentity{XrActionsSyncInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionsSyncInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionsSyncInfo(uint32_t countActiveActionSets_, const ActiveActionSet* activeActionSets_,
                  const void* next_ = nullptr)
      : Parent(StructureType::ActionsSyncInfo, next_),
        countActiveActionSets{countActiveActionSets_},
        activeActionSets{activeActionSets_} {}

  //! Default/empty constructor
  ActionsSyncInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::ActionsSyncInfo, next_) {}

  //! Default copy constructor
  ActionsSyncInfo(const ActionsSyncInfo& rhs) = default;
  //! Default copy assignment
  ActionsSyncInfo& operator=(const ActionsSyncInfo& rhs) = default;
  //! Copy construct from raw
  ActionsSyncInfo(const XrActionsSyncInfo& rhs) : ActionsSyncInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionsSyncInfo& operator=(const XrActionsSyncInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionsSyncInfo&() const {
    return *reinterpret_cast<const XrActionsSyncInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionsSyncInfo&() { return *reinterpret_cast<XrActionsSyncInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionsSyncInfo
  XrActionsSyncInfo const* get() const noexcept {
    return reinterpret_cast<XrActionsSyncInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionsSyncInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionsSyncInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionsSyncInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionsSyncInfo*>(this);
  }
  uint32_t countActiveActionSets;
  const ActiveActionSet* activeActionSets;
};
static_assert(sizeof(XrActionsSyncInfo) == sizeof(ActionsSyncInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionsSyncInfo pointer to const from a ActionsSyncInfo
 * reference to const.
 * @relates ActionsSyncInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionsSyncInfo const* get(ActionsSyncInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionsSyncInfo as the
 * address of a raw XrActionsSyncInfo
 * @relates ActionsSyncInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionsSyncInfo* put(ActionsSyncInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrBoundSourcesForActionEnumerateInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBoundSourcesForActionEnumerateInfo>
 * @xrentity{XrBoundSourcesForActionEnumerateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BoundSourcesForActionEnumerateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BoundSourcesForActionEnumerateInfo(const Action& action_, const void* next_ = nullptr)
      : Parent(StructureType::BoundSourcesForActionEnumerateInfo, next_), action{action_} {}

  //! Default/empty constructor
  BoundSourcesForActionEnumerateInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::BoundSourcesForActionEnumerateInfo, next_) {}

  //! Default copy constructor
  BoundSourcesForActionEnumerateInfo(const BoundSourcesForActionEnumerateInfo& rhs) = default;
  //! Default copy assignment
  BoundSourcesForActionEnumerateInfo& operator=(const BoundSourcesForActionEnumerateInfo& rhs) =
      default;
  //! Copy construct from raw
  BoundSourcesForActionEnumerateInfo(const XrBoundSourcesForActionEnumerateInfo& rhs)
      : BoundSourcesForActionEnumerateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BoundSourcesForActionEnumerateInfo& operator=(const XrBoundSourcesForActionEnumerateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBoundSourcesForActionEnumerateInfo&() const {
    return *reinterpret_cast<const XrBoundSourcesForActionEnumerateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBoundSourcesForActionEnumerateInfo&() {
    return *reinterpret_cast<XrBoundSourcesForActionEnumerateInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrBoundSourcesForActionEnumerateInfo
  XrBoundSourcesForActionEnumerateInfo const* get() const noexcept {
    return reinterpret_cast<XrBoundSourcesForActionEnumerateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBoundSourcesForActionEnumerateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBoundSourcesForActionEnumerateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BoundSourcesForActionEnumerateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrBoundSourcesForActionEnumerateInfo*>(this);
  }
  Action action;
};
static_assert(sizeof(XrBoundSourcesForActionEnumerateInfo) ==
                  sizeof(BoundSourcesForActionEnumerateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBoundSourcesForActionEnumerateInfo pointer to const from
 * a BoundSourcesForActionEnumerateInfo reference to const.
 * @relates BoundSourcesForActionEnumerateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoundSourcesForActionEnumerateInfo const* get(
    BoundSourcesForActionEnumerateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * BoundSourcesForActionEnumerateInfo as the address of a raw XrBoundSourcesForActionEnumerateInfo
 * @relates BoundSourcesForActionEnumerateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoundSourcesForActionEnumerateInfo* put(
    BoundSourcesForActionEnumerateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInputSourceLocalizedNameGetInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInputSourceLocalizedNameGetInfo>
 * @xrentity{XrInputSourceLocalizedNameGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InputSourceLocalizedNameGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InputSourceLocalizedNameGetInfo(const Path& sourcePath_,
                                  const InputSourceLocalizedNameFlags& whichComponents_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::InputSourceLocalizedNameGetInfo, next_),
        sourcePath{sourcePath_},
        whichComponents{whichComponents_} {}

  //! Default/empty constructor
  InputSourceLocalizedNameGetInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::InputSourceLocalizedNameGetInfo, next_) {}

  //! Default copy constructor
  InputSourceLocalizedNameGetInfo(const InputSourceLocalizedNameGetInfo& rhs) = default;
  //! Default copy assignment
  InputSourceLocalizedNameGetInfo& operator=(const InputSourceLocalizedNameGetInfo& rhs) = default;
  //! Copy construct from raw
  InputSourceLocalizedNameGetInfo(const XrInputSourceLocalizedNameGetInfo& rhs)
      : InputSourceLocalizedNameGetInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InputSourceLocalizedNameGetInfo& operator=(const XrInputSourceLocalizedNameGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInputSourceLocalizedNameGetInfo&() const {
    return *reinterpret_cast<const XrInputSourceLocalizedNameGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInputSourceLocalizedNameGetInfo&() {
    return *reinterpret_cast<XrInputSourceLocalizedNameGetInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrInputSourceLocalizedNameGetInfo
  XrInputSourceLocalizedNameGetInfo const* get() const noexcept {
    return reinterpret_cast<XrInputSourceLocalizedNameGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInputSourceLocalizedNameGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInputSourceLocalizedNameGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InputSourceLocalizedNameGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrInputSourceLocalizedNameGetInfo*>(this);
  }
  Path sourcePath;
  InputSourceLocalizedNameFlags whichComponents;
};
static_assert(sizeof(XrInputSourceLocalizedNameGetInfo) == sizeof(InputSourceLocalizedNameGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInputSourceLocalizedNameGetInfo pointer to const from a
 * InputSourceLocalizedNameGetInfo reference to const.
 * @relates InputSourceLocalizedNameGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInputSourceLocalizedNameGetInfo const* get(
    InputSourceLocalizedNameGetInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InputSourceLocalizedNameGetInfo as the address of a raw XrInputSourceLocalizedNameGetInfo
 * @relates InputSourceLocalizedNameGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInputSourceLocalizedNameGetInfo* put(InputSourceLocalizedNameGetInfo& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrHapticActionInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticActionInfo>
 * @xrentity{XrHapticActionInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HapticActionInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HapticActionInfo(const Action& action_, const Path& subactionPath_, const void* next_ = nullptr)
      : Parent(StructureType::HapticActionInfo, next_),
        action{action_},
        subactionPath{subactionPath_} {}

  //! Default/empty constructor
  HapticActionInfo(

      const void* next_ = nullptr)
      : Parent(StructureType::HapticActionInfo, next_) {}

  //! Default copy constructor
  HapticActionInfo(const HapticActionInfo& rhs) = default;
  //! Default copy assignment
  HapticActionInfo& operator=(const HapticActionInfo& rhs) = default;
  //! Copy construct from raw
  HapticActionInfo(const XrHapticActionInfo& rhs) : HapticActionInfo() { *put() = rhs; }
  //! Copy assign from raw
  HapticActionInfo& operator=(const XrHapticActionInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticActionInfo&() const {
    return *reinterpret_cast<const XrHapticActionInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticActionInfo&() { return *reinterpret_cast<XrHapticActionInfo*>(this); }

  //! Accessor for this as the address of a raw XrHapticActionInfo
  XrHapticActionInfo const* get() const noexcept {
    return reinterpret_cast<XrHapticActionInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHapticActionInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHapticActionInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HapticActionInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrHapticActionInfo*>(this);
  }
  Action action;
  Path subactionPath;
};
static_assert(sizeof(XrHapticActionInfo) == sizeof(HapticActionInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticActionInfo pointer to const from a
 * HapticActionInfo reference to const.
 * @relates HapticActionInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticActionInfo const* get(HapticActionInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticActionInfo as the
 * address of a raw XrHapticActionInfo
 * @relates HapticActionInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticActionInfo* put(HapticActionInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrHapticBaseHeader
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticBaseHeader>
 * @xrentity{XrHapticBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS HapticBaseHeader : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  HapticBaseHeader(StructureType type_, const void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticBaseHeader&() const {
    return *reinterpret_cast<const XrHapticBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticBaseHeader&() { return *reinterpret_cast<XrHapticBaseHeader*>(this); }

  //! Accessor for this as the address of a raw XrHapticBaseHeader
  XrHapticBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrHapticBaseHeader const*>(this);
  }
};
static_assert(sizeof(XrHapticBaseHeader) == sizeof(HapticBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticBaseHeader pointer to const from a
 * HapticBaseHeader reference to const.
 * @relates HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader const* get(HapticBaseHeader const& s) {
  return s.get();
}

/*!
 * C++ projection of XrBaseInStructure
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBaseInStructure>
 * @xrentity{XrBaseInStructure}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS BaseInStructure : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  BaseInStructure(StructureType type_, const void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBaseInStructure&() const {
    return *reinterpret_cast<const XrBaseInStructure*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBaseInStructure&() { return *reinterpret_cast<XrBaseInStructure*>(this); }

  //! Accessor for this as the address of a raw XrBaseInStructure
  XrBaseInStructure const* get() const noexcept {
    return reinterpret_cast<XrBaseInStructure const*>(this);
  }
};
static_assert(sizeof(XrBaseInStructure) == sizeof(BaseInStructure),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBaseInStructure pointer to const from a BaseInStructure
 * reference to const.
 * @relates BaseInStructure
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBaseInStructure const* get(BaseInStructure const& s) { return s.get(); }

/*!
 * C++ projection of XrBaseOutStructure
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBaseOutStructure>
 * @xrentity{XrBaseOutStructure}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS BaseOutStructure : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  BaseOutStructure(StructureType type_, void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBaseOutStructure&() const {
    return *reinterpret_cast<const XrBaseOutStructure*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBaseOutStructure&() { return *reinterpret_cast<XrBaseOutStructure*>(this); }

  //! Accessor for this as the address of a raw XrBaseOutStructure
  XrBaseOutStructure const* get() const noexcept {
    return reinterpret_cast<XrBaseOutStructure const*>(this);
  }
};
static_assert(sizeof(XrBaseOutStructure) == sizeof(BaseOutStructure),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBaseOutStructure pointer to const from a
 * BaseOutStructure reference to const.
 * @relates BaseOutStructure
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBaseOutStructure const* get(BaseOutStructure const& s) {
  return s.get();
}

/*!
 * C++ projection of XrOffset2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset2Di>
 * @xrentity{XrOffset2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Offset2Di {
public:
  //! Constructor initializing all members.
  Offset2Di(int32_t x_, int32_t y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Offset2Di(

  ) {}

  //! Default copy constructor
  Offset2Di(const Offset2Di& rhs) = default;
  //! Default copy assignment
  Offset2Di& operator=(const Offset2Di& rhs) = default;
  //! Copy construct from raw
  Offset2Di(const XrOffset2Di& rhs) : Offset2Di() { *put() = rhs; }
  //! Copy assign from raw
  Offset2Di& operator=(const XrOffset2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrOffset2Di&() const { return *reinterpret_cast<const XrOffset2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrOffset2Di&() { return *reinterpret_cast<XrOffset2Di*>(this); }

  //! Accessor for this as the address of a raw XrOffset2Di
  XrOffset2Di const* get() const noexcept { return reinterpret_cast<XrOffset2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrOffset2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrOffset2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Offset2Di{};
    }
    return reinterpret_cast<XrOffset2Di*>(this);
  }
  int32_t x;
  int32_t y;
};
static_assert(sizeof(XrOffset2Di) == sizeof(Offset2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrOffset2Di pointer to const from a Offset2Di reference to
 * const.
 * @relates Offset2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Di const* get(Offset2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset2Di as the address of a
 * raw XrOffset2Di
 * @relates Offset2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Di* put(Offset2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtent2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent2Di>
 * @xrentity{XrExtent2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Extent2Di {
public:
  //! Constructor initializing all members.
  Extent2Di(int32_t width_, int32_t height_) : width{width_}, height{height_} {}

  //! Default/empty constructor
  Extent2Di(

  ) {}

  //! Default copy constructor
  Extent2Di(const Extent2Di& rhs) = default;
  //! Default copy assignment
  Extent2Di& operator=(const Extent2Di& rhs) = default;
  //! Copy construct from raw
  Extent2Di(const XrExtent2Di& rhs) : Extent2Di() { *put() = rhs; }
  //! Copy assign from raw
  Extent2Di& operator=(const XrExtent2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtent2Di&() const { return *reinterpret_cast<const XrExtent2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtent2Di&() { return *reinterpret_cast<XrExtent2Di*>(this); }

  //! Accessor for this as the address of a raw XrExtent2Di
  XrExtent2Di const* get() const noexcept { return reinterpret_cast<XrExtent2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtent2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExtent2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Extent2Di{};
    }
    return reinterpret_cast<XrExtent2Di*>(this);
  }
  int32_t width;
  int32_t height;
};
static_assert(sizeof(XrExtent2Di) == sizeof(Extent2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtent2Di pointer to const from a Extent2Di reference to
 * const.
 * @relates Extent2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Di const* get(Extent2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent2Di as the address of a
 * raw XrExtent2Di
 * @relates Extent2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Di* put(Extent2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrRect2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect2Di>
 * @xrentity{XrRect2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Rect2Di {
public:
  //! Constructor initializing all members.
  Rect2Di(const Offset2Di& offset_, const Extent2Di& extent_) : offset{offset_}, extent{extent_} {}

  //! Default/empty constructor
  Rect2Di(

  ) {}

  //! Default copy constructor
  Rect2Di(const Rect2Di& rhs) = default;
  //! Default copy assignment
  Rect2Di& operator=(const Rect2Di& rhs) = default;
  //! Copy construct from raw
  Rect2Di(const XrRect2Di& rhs) : Rect2Di() { *put() = rhs; }
  //! Copy assign from raw
  Rect2Di& operator=(const XrRect2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRect2Di&() const { return *reinterpret_cast<const XrRect2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRect2Di&() { return *reinterpret_cast<XrRect2Di*>(this); }

  //! Accessor for this as the address of a raw XrRect2Di
  XrRect2Di const* get() const noexcept { return reinterpret_cast<XrRect2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRect2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRect2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Rect2Di{};
    }
    return reinterpret_cast<XrRect2Di*>(this);
  }
  Offset2Di offset;
  Extent2Di extent;
};
static_assert(sizeof(XrRect2Di) == sizeof(Rect2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRect2Di pointer to const from a Rect2Di reference to
 * const.
 * @relates Rect2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Di const* get(Rect2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect2Di as the address of a
 * raw XrRect2Di
 * @relates Rect2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Di* put(Rect2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainSubImage
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainSubImage>
 * @xrentity{XrSwapchainSubImage}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SwapchainSubImage {
public:
  //! Constructor initializing all members.
  SwapchainSubImage(const Swapchain& swapchain_, const Rect2Di& imageRect_,
                    uint32_t imageArrayIndex_)
      : swapchain{swapchain_}, imageRect{imageRect_}, imageArrayIndex{imageArrayIndex_} {}

  //! Default/empty constructor
  SwapchainSubImage(

  ) {}

  //! Default copy constructor
  SwapchainSubImage(const SwapchainSubImage& rhs) = default;
  //! Default copy assignment
  SwapchainSubImage& operator=(const SwapchainSubImage& rhs) = default;
  //! Copy construct from raw
  SwapchainSubImage(const XrSwapchainSubImage& rhs) : SwapchainSubImage() { *put() = rhs; }
  //! Copy assign from raw
  SwapchainSubImage& operator=(const XrSwapchainSubImage& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainSubImage&() const {
    return *reinterpret_cast<const XrSwapchainSubImage*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainSubImage&() { return *reinterpret_cast<XrSwapchainSubImage*>(this); }

  //! Accessor for this as the address of a raw XrSwapchainSubImage
  XrSwapchainSubImage const* get() const noexcept {
    return reinterpret_cast<XrSwapchainSubImage const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainSubImage.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSwapchainSubImage* put(bool clear = true) noexcept {
    if (clear) {
      *this = SwapchainSubImage{};
    }
    return reinterpret_cast<XrSwapchainSubImage*>(this);
  }
  Swapchain swapchain;
  Rect2Di imageRect;
  uint32_t imageArrayIndex;
};
static_assert(sizeof(XrSwapchainSubImage) == sizeof(SwapchainSubImage),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainSubImage pointer to const from a
 * SwapchainSubImage reference to const.
 * @relates SwapchainSubImage
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainSubImage const* get(SwapchainSubImage const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainSubImage as the
 * address of a raw XrSwapchainSubImage
 * @relates SwapchainSubImage
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainSubImage* put(SwapchainSubImage& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerProjectionView
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerProjectionView>
 * @xrentity{XrCompositionLayerProjectionView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerProjectionView : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerProjectionView(const Posef& pose_, const Fovf& fov_,
                                 const SwapchainSubImage& subImage_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerProjectionView, next_),
        pose{pose_},
        fov{fov_},
        subImage{subImage_} {}

  //! Default/empty constructor
  CompositionLayerProjectionView(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerProjectionView, next_) {}

  //! Default copy constructor
  CompositionLayerProjectionView(const CompositionLayerProjectionView& rhs) = default;
  //! Default copy assignment
  CompositionLayerProjectionView& operator=(const CompositionLayerProjectionView& rhs) = default;
  //! Copy construct from raw
  CompositionLayerProjectionView(const XrCompositionLayerProjectionView& rhs)
      : CompositionLayerProjectionView() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerProjectionView& operator=(const XrCompositionLayerProjectionView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerProjectionView&() const {
    return *reinterpret_cast<const XrCompositionLayerProjectionView*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerProjectionView&() {
    return *reinterpret_cast<XrCompositionLayerProjectionView*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerProjectionView
  XrCompositionLayerProjectionView const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerProjectionView const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerProjectionView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerProjectionView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerProjectionView{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerProjectionView*>(this);
  }
  Posef pose;
  Fovf fov;
  SwapchainSubImage subImage;
};
static_assert(sizeof(XrCompositionLayerProjectionView) == sizeof(CompositionLayerProjectionView),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerProjectionView pointer to const from a
 * CompositionLayerProjectionView reference to const.
 * @relates CompositionLayerProjectionView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjectionView const* get(
    CompositionLayerProjectionView const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerProjectionView as the address of a raw XrCompositionLayerProjectionView
 * @relates CompositionLayerProjectionView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjectionView* put(CompositionLayerProjectionView& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerProjection
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerProjection>
 * @xrentity{XrCompositionLayerProjection}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerProjection : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerProjection(const CompositionLayerFlags& layerFlags_, const Space& space_,
                             uint32_t viewCount_, const CompositionLayerProjectionView* views_,
                             const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerProjection, layerFlags_, space_, next_),
        viewCount{viewCount_},
        views{views_} {}

  //! Default/empty constructor
  CompositionLayerProjection(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerProjection, {}, {}, next_) {}

  //! Default copy constructor
  CompositionLayerProjection(const CompositionLayerProjection& rhs) = default;
  //! Default copy assignment
  CompositionLayerProjection& operator=(const CompositionLayerProjection& rhs) = default;
  //! Copy construct from raw
  CompositionLayerProjection(const XrCompositionLayerProjection& rhs)
      : CompositionLayerProjection() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerProjection& operator=(const XrCompositionLayerProjection& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerProjection&() const {
    return *reinterpret_cast<const XrCompositionLayerProjection*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerProjection&() {
    return *reinterpret_cast<XrCompositionLayerProjection*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerProjection
  XrCompositionLayerProjection const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerProjection const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerProjection.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerProjection* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerProjection{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerProjection*>(this);
  }
  uint32_t viewCount;
  const CompositionLayerProjectionView* views;
};
static_assert(sizeof(XrCompositionLayerProjection) == sizeof(CompositionLayerProjection),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerProjection pointer to const from a
 * CompositionLayerProjection reference to const.
 * @relates CompositionLayerProjection
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjection const* get(
    CompositionLayerProjection const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerProjection as
 * the address of a raw XrCompositionLayerProjection
 * @relates CompositionLayerProjection
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjection* put(CompositionLayerProjection& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerProjection as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerProjection
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerProjection const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrCompositionLayerQuad
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerQuad>
 * @xrentity{XrCompositionLayerQuad}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerQuad : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerQuad(const CompositionLayerFlags& layerFlags_, const Space& space_,
                       const EyeVisibility& eyeVisibility_, const SwapchainSubImage& subImage_,
                       const Posef& pose_, const Extent2Df& size_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerQuad, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        size{size_} {}

  //! Default/empty constructor
  CompositionLayerQuad(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerQuad, {}, {}, next_) {}

  //! Default copy constructor
  CompositionLayerQuad(const CompositionLayerQuad& rhs) = default;
  //! Default copy assignment
  CompositionLayerQuad& operator=(const CompositionLayerQuad& rhs) = default;
  //! Copy construct from raw
  CompositionLayerQuad(const XrCompositionLayerQuad& rhs) : CompositionLayerQuad() { *put() = rhs; }
  //! Copy assign from raw
  CompositionLayerQuad& operator=(const XrCompositionLayerQuad& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerQuad&() const {
    return *reinterpret_cast<const XrCompositionLayerQuad*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerQuad&() { return *reinterpret_cast<XrCompositionLayerQuad*>(this); }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerQuad
  XrCompositionLayerQuad const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerQuad const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerQuad.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerQuad* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerQuad{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerQuad*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  Extent2Df size;
};
static_assert(sizeof(XrCompositionLayerQuad) == sizeof(CompositionLayerQuad),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerQuad pointer to const from a
 * CompositionLayerQuad reference to const.
 * @relates CompositionLayerQuad
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerQuad const* get(CompositionLayerQuad const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerQuad as the
 * address of a raw XrCompositionLayerQuad
 * @relates CompositionLayerQuad
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerQuad* put(CompositionLayerQuad& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerQuad as a raw, pointer to
 * const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerQuad
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerQuad const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataBaseHeader
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataBaseHeader>
 * @xrentity{XrEventDataBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS EventDataBaseHeader : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  EventDataBaseHeader(StructureType type_, const void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataBaseHeader&() const {
    return *reinterpret_cast<const XrEventDataBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataBaseHeader&() { return *reinterpret_cast<XrEventDataBaseHeader*>(this); }

  //! Accessor for this as the address of a raw XrEventDataBaseHeader
  XrEventDataBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
};
static_assert(sizeof(XrEventDataBaseHeader) == sizeof(EventDataBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataBaseHeader pointer to const from a
 * EventDataBaseHeader reference to const.
 * @relates EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get(EventDataBaseHeader const& s) {
  return s.get();
}

/*!
 * C++ projection of XrEventDataEventsLost
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataEventsLost>
 * @xrentity{XrEventDataEventsLost}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataEventsLost : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataEventsLost(uint32_t lostEventCount_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataEventsLost, next_), lostEventCount{lostEventCount_} {}

  //! Default/empty constructor
  EventDataEventsLost(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataEventsLost, next_) {}

  //! Default copy constructor
  EventDataEventsLost(const EventDataEventsLost& rhs) = default;
  //! Default copy assignment
  EventDataEventsLost& operator=(const EventDataEventsLost& rhs) = default;
  //! Copy construct from raw
  EventDataEventsLost(const XrEventDataEventsLost& rhs) : EventDataEventsLost() { *put() = rhs; }
  //! Copy assign from raw
  EventDataEventsLost& operator=(const XrEventDataEventsLost& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataEventsLost&() const {
    return *reinterpret_cast<const XrEventDataEventsLost*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataEventsLost&() { return *reinterpret_cast<XrEventDataEventsLost*>(this); }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataEventsLost
  XrEventDataEventsLost const* get() const noexcept {
    return reinterpret_cast<XrEventDataEventsLost const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEventDataEventsLost.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataEventsLost* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataEventsLost{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataEventsLost*>(this);
  }
  uint32_t lostEventCount;
};
static_assert(sizeof(XrEventDataEventsLost) == sizeof(EventDataEventsLost),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataEventsLost pointer to const from a
 * EventDataEventsLost reference to const.
 * @relates EventDataEventsLost
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataEventsLost const* get(EventDataEventsLost const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataEventsLost as the
 * address of a raw XrEventDataEventsLost
 * @relates EventDataEventsLost
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataEventsLost* put(EventDataEventsLost& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataEventsLost as a raw, pointer to
 * const XrEventDataBaseHeader (the base type)
 * @relates EventDataEventsLost
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataEventsLost const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataInstanceLossPending
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInstanceLossPending>
 * @xrentity{XrEventDataInstanceLossPending}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataInstanceLossPending : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataInstanceLossPending(const Time& lossTime_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataInstanceLossPending, next_), lossTime{lossTime_} {}

  //! Default/empty constructor
  EventDataInstanceLossPending(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataInstanceLossPending, next_) {}

  //! Default copy constructor
  EventDataInstanceLossPending(const EventDataInstanceLossPending& rhs) = default;
  //! Default copy assignment
  EventDataInstanceLossPending& operator=(const EventDataInstanceLossPending& rhs) = default;
  //! Copy construct from raw
  EventDataInstanceLossPending(const XrEventDataInstanceLossPending& rhs)
      : EventDataInstanceLossPending() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataInstanceLossPending& operator=(const XrEventDataInstanceLossPending& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataInstanceLossPending&() const {
    return *reinterpret_cast<const XrEventDataInstanceLossPending*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataInstanceLossPending&() {
    return *reinterpret_cast<XrEventDataInstanceLossPending*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataInstanceLossPending
  XrEventDataInstanceLossPending const* get() const noexcept {
    return reinterpret_cast<XrEventDataInstanceLossPending const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataInstanceLossPending.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataInstanceLossPending* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataInstanceLossPending{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataInstanceLossPending*>(this);
  }
  Time lossTime;
};
static_assert(sizeof(XrEventDataInstanceLossPending) == sizeof(EventDataInstanceLossPending),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataInstanceLossPending pointer to const from a
 * EventDataInstanceLossPending reference to const.
 * @relates EventDataInstanceLossPending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInstanceLossPending const* get(
    EventDataInstanceLossPending const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataInstanceLossPending
 * as the address of a raw XrEventDataInstanceLossPending
 * @relates EventDataInstanceLossPending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInstanceLossPending* put(EventDataInstanceLossPending& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataInstanceLossPending as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataInstanceLossPending
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataInstanceLossPending const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataSessionStateChanged
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSessionStateChanged>
 * @xrentity{XrEventDataSessionStateChanged}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSessionStateChanged : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataSessionStateChanged(const Session& session_, const SessionState& state_,
                               const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataSessionStateChanged, next_),
        session{session_},
        state{state_},
        time{time_} {}

  //! Default/empty constructor
  EventDataSessionStateChanged(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataSessionStateChanged, next_) {}

  //! Default copy constructor
  EventDataSessionStateChanged(const EventDataSessionStateChanged& rhs) = default;
  //! Default copy assignment
  EventDataSessionStateChanged& operator=(const EventDataSessionStateChanged& rhs) = default;
  //! Copy construct from raw
  EventDataSessionStateChanged(const XrEventDataSessionStateChanged& rhs)
      : EventDataSessionStateChanged() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSessionStateChanged& operator=(const XrEventDataSessionStateChanged& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSessionStateChanged&() const {
    return *reinterpret_cast<const XrEventDataSessionStateChanged*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSessionStateChanged&() {
    return *reinterpret_cast<XrEventDataSessionStateChanged*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSessionStateChanged
  XrEventDataSessionStateChanged const* get() const noexcept {
    return reinterpret_cast<XrEventDataSessionStateChanged const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSessionStateChanged.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSessionStateChanged* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSessionStateChanged{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSessionStateChanged*>(this);
  }
  Session session;
  SessionState state;
  Time time;
};
static_assert(sizeof(XrEventDataSessionStateChanged) == sizeof(EventDataSessionStateChanged),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSessionStateChanged pointer to const from a
 * EventDataSessionStateChanged reference to const.
 * @relates EventDataSessionStateChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSessionStateChanged const* get(
    EventDataSessionStateChanged const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSessionStateChanged
 * as the address of a raw XrEventDataSessionStateChanged
 * @relates EventDataSessionStateChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSessionStateChanged* put(EventDataSessionStateChanged& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSessionStateChanged as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSessionStateChanged
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSessionStateChanged const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataReferenceSpaceChangePending
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataReferenceSpaceChangePending>
 * @xrentity{XrEventDataReferenceSpaceChangePending}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataReferenceSpaceChangePending : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataReferenceSpaceChangePending(const Session& session_,
                                       const ReferenceSpaceType& referenceSpaceType_,
                                       const Time& changeTime_, const Bool32& poseValid_,
                                       const Posef& poseInPreviousSpace_,
                                       const void* next_ = nullptr)
      : Parent(StructureType::EventDataReferenceSpaceChangePending, next_),
        session{session_},
        referenceSpaceType{referenceSpaceType_},
        changeTime{changeTime_},
        poseValid{poseValid_},
        poseInPreviousSpace{poseInPreviousSpace_} {}

  //! Default/empty constructor
  EventDataReferenceSpaceChangePending(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataReferenceSpaceChangePending, next_) {}

  //! Default copy constructor
  EventDataReferenceSpaceChangePending(const EventDataReferenceSpaceChangePending& rhs) = default;
  //! Default copy assignment
  EventDataReferenceSpaceChangePending& operator=(const EventDataReferenceSpaceChangePending& rhs) =
      default;
  //! Copy construct from raw
  EventDataReferenceSpaceChangePending(const XrEventDataReferenceSpaceChangePending& rhs)
      : EventDataReferenceSpaceChangePending() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataReferenceSpaceChangePending& operator=(
      const XrEventDataReferenceSpaceChangePending& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataReferenceSpaceChangePending&() const {
    return *reinterpret_cast<const XrEventDataReferenceSpaceChangePending*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataReferenceSpaceChangePending&() {
    return *reinterpret_cast<XrEventDataReferenceSpaceChangePending*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataReferenceSpaceChangePending
  XrEventDataReferenceSpaceChangePending const* get() const noexcept {
    return reinterpret_cast<XrEventDataReferenceSpaceChangePending const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataReferenceSpaceChangePending.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataReferenceSpaceChangePending* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataReferenceSpaceChangePending{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataReferenceSpaceChangePending*>(this);
  }
  Session session;
  ReferenceSpaceType referenceSpaceType;
  Time changeTime;
  Bool32 poseValid;
  Posef poseInPreviousSpace;
};
static_assert(sizeof(XrEventDataReferenceSpaceChangePending) ==
                  sizeof(EventDataReferenceSpaceChangePending),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataReferenceSpaceChangePending pointer to const
 * from a EventDataReferenceSpaceChangePending reference to const.
 * @relates EventDataReferenceSpaceChangePending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataReferenceSpaceChangePending const* get(
    EventDataReferenceSpaceChangePending const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataReferenceSpaceChangePending as the address of a raw
 * XrEventDataReferenceSpaceChangePending
 * @relates EventDataReferenceSpaceChangePending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataReferenceSpaceChangePending* put(
    EventDataReferenceSpaceChangePending& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataReferenceSpaceChangePending as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataReferenceSpaceChangePending
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataReferenceSpaceChangePending const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataInteractionProfileChanged
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInteractionProfileChanged>
 * @xrentity{XrEventDataInteractionProfileChanged}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataInteractionProfileChanged : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataInteractionProfileChanged(const Session& session_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataInteractionProfileChanged, next_), session{session_} {}

  //! Default/empty constructor
  EventDataInteractionProfileChanged(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataInteractionProfileChanged, next_) {}

  //! Default copy constructor
  EventDataInteractionProfileChanged(const EventDataInteractionProfileChanged& rhs) = default;
  //! Default copy assignment
  EventDataInteractionProfileChanged& operator=(const EventDataInteractionProfileChanged& rhs) =
      default;
  //! Copy construct from raw
  EventDataInteractionProfileChanged(const XrEventDataInteractionProfileChanged& rhs)
      : EventDataInteractionProfileChanged() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataInteractionProfileChanged& operator=(const XrEventDataInteractionProfileChanged& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataInteractionProfileChanged&() const {
    return *reinterpret_cast<const XrEventDataInteractionProfileChanged*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataInteractionProfileChanged&() {
    return *reinterpret_cast<XrEventDataInteractionProfileChanged*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataInteractionProfileChanged
  XrEventDataInteractionProfileChanged const* get() const noexcept {
    return reinterpret_cast<XrEventDataInteractionProfileChanged const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataInteractionProfileChanged.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataInteractionProfileChanged* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataInteractionProfileChanged{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataInteractionProfileChanged*>(this);
  }
  Session session;
};
static_assert(sizeof(XrEventDataInteractionProfileChanged) ==
                  sizeof(EventDataInteractionProfileChanged),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataInteractionProfileChanged pointer to const from
 * a EventDataInteractionProfileChanged reference to const.
 * @relates EventDataInteractionProfileChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInteractionProfileChanged const* get(
    EventDataInteractionProfileChanged const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataInteractionProfileChanged as the address of a raw XrEventDataInteractionProfileChanged
 * @relates EventDataInteractionProfileChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInteractionProfileChanged* put(
    EventDataInteractionProfileChanged& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataInteractionProfileChanged as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataInteractionProfileChanged
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataInteractionProfileChanged const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrHapticVibration
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticVibration>
 * @xrentity{XrHapticVibration}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HapticVibration : public HapticBaseHeader {
private:
  using Parent = HapticBaseHeader;

public:
  //! Constructor initializing all members.
  HapticVibration(const Duration& duration_, float frequency_, float amplitude_,
                  const void* next_ = nullptr)
      : Parent(StructureType::HapticVibration, next_),
        duration{duration_},
        frequency{frequency_},
        amplitude{amplitude_} {}

  //! Default/empty constructor
  HapticVibration(

      const void* next_ = nullptr)
      : Parent(StructureType::HapticVibration, next_) {}

  //! Default copy constructor
  HapticVibration(const HapticVibration& rhs) = default;
  //! Default copy assignment
  HapticVibration& operator=(const HapticVibration& rhs) = default;
  //! Copy construct from raw
  HapticVibration(const XrHapticVibration& rhs) : HapticVibration() { *put() = rhs; }
  //! Copy assign from raw
  HapticVibration& operator=(const XrHapticVibration& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticVibration&() const {
    return *reinterpret_cast<const XrHapticVibration*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticVibration&() { return *reinterpret_cast<XrHapticVibration*>(this); }

  //! Accessor for this as a raw, base XrHapticBaseHeader const pointer
  XrHapticBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrHapticBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrHapticVibration
  XrHapticVibration const* get() const noexcept {
    return reinterpret_cast<XrHapticVibration const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHapticVibration.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHapticVibration* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HapticVibration{};
      next = oldNext;
    }
    return reinterpret_cast<XrHapticVibration*>(this);
  }
  Duration duration;
  float frequency;
  float amplitude;
};
static_assert(sizeof(XrHapticVibration) == sizeof(HapticVibration),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticVibration pointer to const from a HapticVibration
 * reference to const.
 * @relates HapticVibration
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticVibration const* get(HapticVibration const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticVibration as the
 * address of a raw XrHapticVibration
 * @relates HapticVibration
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticVibration* put(HapticVibration& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const HapticVibration as a raw, pointer to const
 * XrHapticBaseHeader (the base type)
 * @relates HapticVibration
 * @relatesalso HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader const* get_base(HapticVibration const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrOffset2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset2Df>
 * @xrentity{XrOffset2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Offset2Df {
public:
  //! Constructor initializing all members.
  Offset2Df(float x_, float y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Offset2Df(

  ) {}

  //! Default copy constructor
  Offset2Df(const Offset2Df& rhs) = default;
  //! Default copy assignment
  Offset2Df& operator=(const Offset2Df& rhs) = default;
  //! Copy construct from raw
  Offset2Df(const XrOffset2Df& rhs) : Offset2Df() { *put() = rhs; }
  //! Copy assign from raw
  Offset2Df& operator=(const XrOffset2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrOffset2Df&() const { return *reinterpret_cast<const XrOffset2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrOffset2Df&() { return *reinterpret_cast<XrOffset2Df*>(this); }

  //! Accessor for this as the address of a raw XrOffset2Df
  XrOffset2Df const* get() const noexcept { return reinterpret_cast<XrOffset2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrOffset2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrOffset2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Offset2Df{};
    }
    return reinterpret_cast<XrOffset2Df*>(this);
  }
  float x;
  float y;
};
static_assert(sizeof(XrOffset2Df) == sizeof(Offset2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrOffset2Df pointer to const from a Offset2Df reference to
 * const.
 * @relates Offset2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Df const* get(Offset2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset2Df as the address of a
 * raw XrOffset2Df
 * @relates Offset2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Df* put(Offset2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrRect2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect2Df>
 * @xrentity{XrRect2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Rect2Df {
public:
  //! Constructor initializing all members.
  Rect2Df(const Offset2Df& offset_, const Extent2Df& extent_) : offset{offset_}, extent{extent_} {}

  //! Default/empty constructor
  Rect2Df(

  ) {}

  //! Default copy constructor
  Rect2Df(const Rect2Df& rhs) = default;
  //! Default copy assignment
  Rect2Df& operator=(const Rect2Df& rhs) = default;
  //! Copy construct from raw
  Rect2Df(const XrRect2Df& rhs) : Rect2Df() { *put() = rhs; }
  //! Copy assign from raw
  Rect2Df& operator=(const XrRect2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRect2Df&() const { return *reinterpret_cast<const XrRect2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRect2Df&() { return *reinterpret_cast<XrRect2Df*>(this); }

  //! Accessor for this as the address of a raw XrRect2Df
  XrRect2Df const* get() const noexcept { return reinterpret_cast<XrRect2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRect2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRect2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Rect2Df{};
    }
    return reinterpret_cast<XrRect2Df*>(this);
  }
  Offset2Df offset;
  Extent2Df extent;
};
static_assert(sizeof(XrRect2Df) == sizeof(Rect2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRect2Df pointer to const from a Rect2Df reference to
 * const.
 * @relates Rect2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Df const* get(Rect2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect2Df as the address of a
 * raw XrRect2Df
 * @relates Rect2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Df* put(Rect2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector4f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector4f>
 * @xrentity{XrVector4f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector4f {
public:
  //! Constructor initializing all members.
  Vector4f(float x_, float y_, float z_, float w_) : x{x_}, y{y_}, z{z_}, w{w_} {}

  //! Default/empty constructor
  Vector4f(

  ) {}

  //! Default copy constructor
  Vector4f(const Vector4f& rhs) = default;
  //! Default copy assignment
  Vector4f& operator=(const Vector4f& rhs) = default;
  //! Copy construct from raw
  Vector4f(const XrVector4f& rhs) : Vector4f() { *put() = rhs; }
  //! Copy assign from raw
  Vector4f& operator=(const XrVector4f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector4f&() const { return *reinterpret_cast<const XrVector4f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector4f&() { return *reinterpret_cast<XrVector4f*>(this); }

  //! Accessor for this as the address of a raw XrVector4f
  XrVector4f const* get() const noexcept { return reinterpret_cast<XrVector4f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector4f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector4f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector4f{};
    }
    return reinterpret_cast<XrVector4f*>(this);
  }
  float x;
  float y;
  float z;
  float w;
};
static_assert(sizeof(XrVector4f) == sizeof(Vector4f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector4f pointer to const from a Vector4f reference to
 * const.
 * @relates Vector4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4f const* get(Vector4f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector4f as the address of a
 * raw XrVector4f
 * @relates Vector4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4f* put(Vector4f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrColor4f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColor4f>
 * @xrentity{XrColor4f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Color4f {
public:
  //! Constructor initializing all members.
  Color4f(float r_, float g_, float b_, float a_) : r{r_}, g{g_}, b{b_}, a{a_} {}

  //! Default/empty constructor
  Color4f(

  ) {}

  //! Default copy constructor
  Color4f(const Color4f& rhs) = default;
  //! Default copy assignment
  Color4f& operator=(const Color4f& rhs) = default;
  //! Copy construct from raw
  Color4f(const XrColor4f& rhs) : Color4f() { *put() = rhs; }
  //! Copy assign from raw
  Color4f& operator=(const XrColor4f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrColor4f&() const { return *reinterpret_cast<const XrColor4f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrColor4f&() { return *reinterpret_cast<XrColor4f*>(this); }

  //! Accessor for this as the address of a raw XrColor4f
  XrColor4f const* get() const noexcept { return reinterpret_cast<XrColor4f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrColor4f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrColor4f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Color4f{};
    }
    return reinterpret_cast<XrColor4f*>(this);
  }
  float r;
  float g;
  float b;
  float a;
};
static_assert(sizeof(XrColor4f) == sizeof(Color4f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrColor4f pointer to const from a Color4f reference to
 * const.
 * @relates Color4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColor4f const* get(Color4f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Color4f as the address of a
 * raw XrColor4f
 * @relates Color4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColor4f* put(Color4f& s, bool clear = true) noexcept {
  return s.put(clear);
}

#ifdef XR_KHR_composition_layer_cube
/*!
 * C++ projection of XrCompositionLayerCubeKHR
 *
 * Provided by the `XR_KHR_composition_layer_cube` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerCubeKHR>
 * @xrentity{XrCompositionLayerCubeKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerCubeKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerCubeKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                          const EyeVisibility& eyeVisibility_, const Swapchain& swapchain_,
                          uint32_t imageArrayIndex_, const Quaternionf& orientation_,
                          const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerCubeKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        swapchain{swapchain_},
        imageArrayIndex{imageArrayIndex_},
        orientation{orientation_} {}

  //! Default/empty constructor
  CompositionLayerCubeKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerCubeKHR, {}, {}, next_) {}

  //! Default copy constructor
  CompositionLayerCubeKHR(const CompositionLayerCubeKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerCubeKHR& operator=(const CompositionLayerCubeKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerCubeKHR(const XrCompositionLayerCubeKHR& rhs) : CompositionLayerCubeKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerCubeKHR& operator=(const XrCompositionLayerCubeKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerCubeKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerCubeKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerCubeKHR&() {
    return *reinterpret_cast<XrCompositionLayerCubeKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerCubeKHR
  XrCompositionLayerCubeKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerCubeKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerCubeKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerCubeKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerCubeKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerCubeKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  Swapchain swapchain;
  uint32_t imageArrayIndex;
  Quaternionf orientation;
};
static_assert(sizeof(XrCompositionLayerCubeKHR) == sizeof(CompositionLayerCubeKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerCubeKHR pointer to const from a
 * CompositionLayerCubeKHR reference to const.
 * @relates CompositionLayerCubeKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCubeKHR const* get(CompositionLayerCubeKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerCubeKHR as
 * the address of a raw XrCompositionLayerCubeKHR
 * @relates CompositionLayerCubeKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCubeKHR* put(CompositionLayerCubeKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerCubeKHR as a raw, pointer
 * to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerCubeKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerCubeKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_cube

#ifdef XR_KHR_android_create_instance
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrInstanceCreateInfoAndroidKHR
 *
 * Provided by the `XR_KHR_android_create_instance` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceCreateInfoAndroidKHR>
 * @xrentity{XrInstanceCreateInfoAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceCreateInfoAndroidKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InstanceCreateInfoAndroidKHR(void* XR_MAY_ALIAS applicationVM_,
                               void* XR_MAY_ALIAS applicationActivity_, const void* next_ = nullptr)
      : Parent(StructureType::InstanceCreateInfoAndroidKHR, next_),
        applicationVM{applicationVM_},
        applicationActivity{applicationActivity_} {}

  //! Default/empty constructor
  InstanceCreateInfoAndroidKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::InstanceCreateInfoAndroidKHR, next_) {}

  //! Default copy constructor
  InstanceCreateInfoAndroidKHR(const InstanceCreateInfoAndroidKHR& rhs) = default;
  //! Default copy assignment
  InstanceCreateInfoAndroidKHR& operator=(const InstanceCreateInfoAndroidKHR& rhs) = default;
  //! Copy construct from raw
  InstanceCreateInfoAndroidKHR(const XrInstanceCreateInfoAndroidKHR& rhs)
      : InstanceCreateInfoAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InstanceCreateInfoAndroidKHR& operator=(const XrInstanceCreateInfoAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceCreateInfoAndroidKHR&() const {
    return *reinterpret_cast<const XrInstanceCreateInfoAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceCreateInfoAndroidKHR&() {
    return *reinterpret_cast<XrInstanceCreateInfoAndroidKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrInstanceCreateInfoAndroidKHR
  XrInstanceCreateInfoAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrInstanceCreateInfoAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInstanceCreateInfoAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceCreateInfoAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceCreateInfoAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceCreateInfoAndroidKHR*>(this);
  }
  void* XR_MAY_ALIAS applicationVM;
  void* XR_MAY_ALIAS applicationActivity;
};
static_assert(sizeof(XrInstanceCreateInfoAndroidKHR) == sizeof(InstanceCreateInfoAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceCreateInfoAndroidKHR pointer to const from a
 * InstanceCreateInfoAndroidKHR reference to const.
 * @relates InstanceCreateInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfoAndroidKHR const* get(
    InstanceCreateInfoAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceCreateInfoAndroidKHR
 * as the address of a raw XrInstanceCreateInfoAndroidKHR
 * @relates InstanceCreateInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfoAndroidKHR* put(InstanceCreateInfoAndroidKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_create_instance

#ifdef XR_KHR_composition_layer_depth
/*!
 * C++ projection of XrCompositionLayerDepthInfoKHR
 *
 * Provided by the `XR_KHR_composition_layer_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthInfoKHR>
 * @xrentity{XrCompositionLayerDepthInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerDepthInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerDepthInfoKHR(const SwapchainSubImage& subImage_, float minDepth_, float maxDepth_,
                               float nearZ_, float farZ_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerDepthInfoKHR, next_),
        subImage{subImage_},
        minDepth{minDepth_},
        maxDepth{maxDepth_},
        nearZ{nearZ_},
        farZ{farZ_} {}

  //! Default/empty constructor
  CompositionLayerDepthInfoKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerDepthInfoKHR, next_) {}

  //! Default copy constructor
  CompositionLayerDepthInfoKHR(const CompositionLayerDepthInfoKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerDepthInfoKHR& operator=(const CompositionLayerDepthInfoKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerDepthInfoKHR(const XrCompositionLayerDepthInfoKHR& rhs)
      : CompositionLayerDepthInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerDepthInfoKHR& operator=(const XrCompositionLayerDepthInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerDepthInfoKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerDepthInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerDepthInfoKHR&() {
    return *reinterpret_cast<XrCompositionLayerDepthInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerDepthInfoKHR
  XrCompositionLayerDepthInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerDepthInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerDepthInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerDepthInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerDepthInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerDepthInfoKHR*>(this);
  }
  SwapchainSubImage subImage;
  float minDepth;
  float maxDepth;
  float nearZ;
  float farZ;
};
static_assert(sizeof(XrCompositionLayerDepthInfoKHR) == sizeof(CompositionLayerDepthInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthInfoKHR pointer to const from a
 * CompositionLayerDepthInfoKHR reference to const.
 * @relates CompositionLayerDepthInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthInfoKHR const* get(
    CompositionLayerDepthInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerDepthInfoKHR
 * as the address of a raw XrCompositionLayerDepthInfoKHR
 * @relates CompositionLayerDepthInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthInfoKHR* put(CompositionLayerDepthInfoKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_composition_layer_depth

#ifdef XR_KHR_vulkan_swapchain_format_list
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanSwapchainFormatListCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_swapchain_format_list` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanSwapchainFormatListCreateInfoKHR>
 * @xrentity{XrVulkanSwapchainFormatListCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanSwapchainFormatListCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanSwapchainFormatListCreateInfoKHR(uint32_t viewFormatCount_, const VkFormat* viewFormats_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::VulkanSwapchainFormatListCreateInfoKHR, next_),
        viewFormatCount{viewFormatCount_},
        viewFormats{viewFormats_} {}

  //! Default/empty constructor
  VulkanSwapchainFormatListCreateInfoKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::VulkanSwapchainFormatListCreateInfoKHR, next_) {}

  //! Default copy constructor
  VulkanSwapchainFormatListCreateInfoKHR(const VulkanSwapchainFormatListCreateInfoKHR& rhs) =
      default;
  //! Default copy assignment
  VulkanSwapchainFormatListCreateInfoKHR& operator=(
      const VulkanSwapchainFormatListCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanSwapchainFormatListCreateInfoKHR(const XrVulkanSwapchainFormatListCreateInfoKHR& rhs)
      : VulkanSwapchainFormatListCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanSwapchainFormatListCreateInfoKHR& operator=(
      const XrVulkanSwapchainFormatListCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanSwapchainFormatListCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanSwapchainFormatListCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanSwapchainFormatListCreateInfoKHR
  XrVulkanSwapchainFormatListCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanSwapchainFormatListCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanSwapchainFormatListCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanSwapchainFormatListCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }
  uint32_t viewFormatCount;
  const VkFormat* viewFormats;
};
static_assert(sizeof(XrVulkanSwapchainFormatListCreateInfoKHR) ==
                  sizeof(VulkanSwapchainFormatListCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanSwapchainFormatListCreateInfoKHR pointer to const
 * from a VulkanSwapchainFormatListCreateInfoKHR reference to const.
 * @relates VulkanSwapchainFormatListCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanSwapchainFormatListCreateInfoKHR const* get(
    VulkanSwapchainFormatListCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VulkanSwapchainFormatListCreateInfoKHR as the address of a raw
 * XrVulkanSwapchainFormatListCreateInfoKHR
 * @relates VulkanSwapchainFormatListCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanSwapchainFormatListCreateInfoKHR* put(
    VulkanSwapchainFormatListCreateInfoKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_swapchain_format_list

#ifdef XR_KHR_composition_layer_cylinder
/*!
 * C++ projection of XrCompositionLayerCylinderKHR
 *
 * Provided by the `XR_KHR_composition_layer_cylinder` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerCylinderKHR>
 * @xrentity{XrCompositionLayerCylinderKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerCylinderKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerCylinderKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                              const EyeVisibility& eyeVisibility_,
                              const SwapchainSubImage& subImage_, const Posef& pose_, float radius_,
                              float centralAngle_, float aspectRatio_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerCylinderKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        centralAngle{centralAngle_},
        aspectRatio{aspectRatio_} {}

  //! Default/empty constructor
  CompositionLayerCylinderKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerCylinderKHR, {}, {}, next_) {}

  //! Default copy constructor
  CompositionLayerCylinderKHR(const CompositionLayerCylinderKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerCylinderKHR& operator=(const CompositionLayerCylinderKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerCylinderKHR(const XrCompositionLayerCylinderKHR& rhs)
      : CompositionLayerCylinderKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerCylinderKHR& operator=(const XrCompositionLayerCylinderKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerCylinderKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerCylinderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerCylinderKHR&() {
    return *reinterpret_cast<XrCompositionLayerCylinderKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerCylinderKHR
  XrCompositionLayerCylinderKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerCylinderKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerCylinderKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerCylinderKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerCylinderKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerCylinderKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  float centralAngle;
  float aspectRatio;
};
static_assert(sizeof(XrCompositionLayerCylinderKHR) == sizeof(CompositionLayerCylinderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerCylinderKHR pointer to const from a
 * CompositionLayerCylinderKHR reference to const.
 * @relates CompositionLayerCylinderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCylinderKHR const* get(
    CompositionLayerCylinderKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerCylinderKHR
 * as the address of a raw XrCompositionLayerCylinderKHR
 * @relates CompositionLayerCylinderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCylinderKHR* put(CompositionLayerCylinderKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerCylinderKHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerCylinderKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerCylinderKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_cylinder

#ifdef XR_KHR_composition_layer_equirect
/*!
 * C++ projection of XrCompositionLayerEquirectKHR
 *
 * Provided by the `XR_KHR_composition_layer_equirect` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerEquirectKHR>
 * @xrentity{XrCompositionLayerEquirectKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerEquirectKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerEquirectKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                              const EyeVisibility& eyeVisibility_,
                              const SwapchainSubImage& subImage_, const Posef& pose_, float radius_,
                              const Vector2f& scale_, const Vector2f& bias_,
                              const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerEquirectKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        scale{scale_},
        bias{bias_} {}

  //! Default/empty constructor
  CompositionLayerEquirectKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerEquirectKHR, {}, {}, next_) {}

  //! Default copy constructor
  CompositionLayerEquirectKHR(const CompositionLayerEquirectKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerEquirectKHR& operator=(const CompositionLayerEquirectKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerEquirectKHR(const XrCompositionLayerEquirectKHR& rhs)
      : CompositionLayerEquirectKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerEquirectKHR& operator=(const XrCompositionLayerEquirectKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerEquirectKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerEquirectKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerEquirectKHR&() {
    return *reinterpret_cast<XrCompositionLayerEquirectKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerEquirectKHR
  XrCompositionLayerEquirectKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerEquirectKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerEquirectKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerEquirectKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerEquirectKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerEquirectKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  Vector2f scale;
  Vector2f bias;
};
static_assert(sizeof(XrCompositionLayerEquirectKHR) == sizeof(CompositionLayerEquirectKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerEquirectKHR pointer to const from a
 * CompositionLayerEquirectKHR reference to const.
 * @relates CompositionLayerEquirectKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirectKHR const* get(
    CompositionLayerEquirectKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerEquirectKHR
 * as the address of a raw XrCompositionLayerEquirectKHR
 * @relates CompositionLayerEquirectKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirectKHR* put(CompositionLayerEquirectKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerEquirectKHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerEquirectKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerEquirectKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_equirect

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
/*!
 * C++ projection of XrGraphicsBindingOpenGLWin32KHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLWin32KHR>
 * @xrentity{XrGraphicsBindingOpenGLWin32KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLWin32KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLWin32KHR(HDC hDC_, HGLRC hGLRC_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLWin32KHR, next_), hDC{hDC_}, hGLRC{hGLRC_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLWin32KHR(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLWin32KHR, next_) {}

  //! Default copy constructor
  GraphicsBindingOpenGLWin32KHR(const GraphicsBindingOpenGLWin32KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLWin32KHR& operator=(const GraphicsBindingOpenGLWin32KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLWin32KHR(const XrGraphicsBindingOpenGLWin32KHR& rhs)
      : GraphicsBindingOpenGLWin32KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLWin32KHR& operator=(const XrGraphicsBindingOpenGLWin32KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLWin32KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLWin32KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLWin32KHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLWin32KHR
  XrGraphicsBindingOpenGLWin32KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLWin32KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLWin32KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLWin32KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR*>(this);
  }
  HDC hDC;
  HGLRC hGLRC;
};
static_assert(sizeof(XrGraphicsBindingOpenGLWin32KHR) == sizeof(GraphicsBindingOpenGLWin32KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLWin32KHR pointer to const from a
 * GraphicsBindingOpenGLWin32KHR reference to const.
 * @relates GraphicsBindingOpenGLWin32KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWin32KHR const* get(
    GraphicsBindingOpenGLWin32KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLWin32KHR
 * as the address of a raw XrGraphicsBindingOpenGLWin32KHR
 * @relates GraphicsBindingOpenGLWin32KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWin32KHR* put(GraphicsBindingOpenGLWin32KHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
/*!
 * C++ projection of XrGraphicsBindingOpenGLXlibKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLXlibKHR>
 * @xrentity{XrGraphicsBindingOpenGLXlibKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLXlibKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLXlibKHR(Display* xDisplay_, uint32_t visualid_, GLXFBConfig glxFBConfig_,
                               GLXDrawable glxDrawable_, GLXContext glxContext_,
                               const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLXlibKHR, next_),
        xDisplay{xDisplay_},
        visualid{visualid_},
        glxFBConfig{glxFBConfig_},
        glxDrawable{glxDrawable_},
        glxContext{glxContext_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLXlibKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLXlibKHR, next_) {}

  //! Default copy constructor
  GraphicsBindingOpenGLXlibKHR(const GraphicsBindingOpenGLXlibKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLXlibKHR& operator=(const GraphicsBindingOpenGLXlibKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLXlibKHR(const XrGraphicsBindingOpenGLXlibKHR& rhs)
      : GraphicsBindingOpenGLXlibKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLXlibKHR& operator=(const XrGraphicsBindingOpenGLXlibKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLXlibKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLXlibKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLXlibKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLXlibKHR
  XrGraphicsBindingOpenGLXlibKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLXlibKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLXlibKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLXlibKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR*>(this);
  }
  Display* xDisplay;
  uint32_t visualid;
  GLXFBConfig glxFBConfig;
  GLXDrawable glxDrawable;
  GLXContext glxContext;
};
static_assert(sizeof(XrGraphicsBindingOpenGLXlibKHR) == sizeof(GraphicsBindingOpenGLXlibKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLXlibKHR pointer to const from a
 * GraphicsBindingOpenGLXlibKHR reference to const.
 * @relates GraphicsBindingOpenGLXlibKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXlibKHR const* get(
    GraphicsBindingOpenGLXlibKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLXlibKHR
 * as the address of a raw XrGraphicsBindingOpenGLXlibKHR
 * @relates GraphicsBindingOpenGLXlibKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXlibKHR* put(GraphicsBindingOpenGLXlibKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
/*!
 * C++ projection of XrGraphicsBindingOpenGLXcbKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLXcbKHR>
 * @xrentity{XrGraphicsBindingOpenGLXcbKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLXcbKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLXcbKHR(xcb_connection_t* connection_, uint32_t screenNumber_,
                              xcb_glx_fbconfig_t fbconfigid_, xcb_visualid_t visualid_,
                              xcb_glx_drawable_t glxDrawable_, xcb_glx_context_t glxContext_,
                              const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLXcbKHR, next_),
        connection{connection_},
        screenNumber{screenNumber_},
        fbconfigid{fbconfigid_},
        visualid{visualid_},
        glxDrawable{glxDrawable_},
        glxContext{glxContext_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLXcbKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLXcbKHR, next_) {}

  //! Default copy constructor
  GraphicsBindingOpenGLXcbKHR(const GraphicsBindingOpenGLXcbKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLXcbKHR& operator=(const GraphicsBindingOpenGLXcbKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLXcbKHR(const XrGraphicsBindingOpenGLXcbKHR& rhs)
      : GraphicsBindingOpenGLXcbKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLXcbKHR& operator=(const XrGraphicsBindingOpenGLXcbKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLXcbKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLXcbKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLXcbKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLXcbKHR
  XrGraphicsBindingOpenGLXcbKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLXcbKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLXcbKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLXcbKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR*>(this);
  }
  xcb_connection_t* connection;
  uint32_t screenNumber;
  xcb_glx_fbconfig_t fbconfigid;
  xcb_visualid_t visualid;
  xcb_glx_drawable_t glxDrawable;
  xcb_glx_context_t glxContext;
};
static_assert(sizeof(XrGraphicsBindingOpenGLXcbKHR) == sizeof(GraphicsBindingOpenGLXcbKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLXcbKHR pointer to const from a
 * GraphicsBindingOpenGLXcbKHR reference to const.
 * @relates GraphicsBindingOpenGLXcbKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXcbKHR const* get(
    GraphicsBindingOpenGLXcbKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLXcbKHR
 * as the address of a raw XrGraphicsBindingOpenGLXcbKHR
 * @relates GraphicsBindingOpenGLXcbKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXcbKHR* put(GraphicsBindingOpenGLXcbKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
/*!
 * C++ projection of XrGraphicsBindingOpenGLWaylandKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLWaylandKHR>
 * @xrentity{XrGraphicsBindingOpenGLWaylandKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLWaylandKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLWaylandKHR(struct wl_display* display_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLWaylandKHR, next_), display{display_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLWaylandKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLWaylandKHR, next_) {}

  //! Default copy constructor
  GraphicsBindingOpenGLWaylandKHR(const GraphicsBindingOpenGLWaylandKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLWaylandKHR& operator=(const GraphicsBindingOpenGLWaylandKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLWaylandKHR(const XrGraphicsBindingOpenGLWaylandKHR& rhs)
      : GraphicsBindingOpenGLWaylandKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLWaylandKHR& operator=(const XrGraphicsBindingOpenGLWaylandKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLWaylandKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLWaylandKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLWaylandKHR
  XrGraphicsBindingOpenGLWaylandKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLWaylandKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLWaylandKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLWaylandKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }
  struct wl_display* display;
};
static_assert(sizeof(XrGraphicsBindingOpenGLWaylandKHR) == sizeof(GraphicsBindingOpenGLWaylandKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLWaylandKHR pointer to const from a
 * GraphicsBindingOpenGLWaylandKHR reference to const.
 * @relates GraphicsBindingOpenGLWaylandKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWaylandKHR const* get(
    GraphicsBindingOpenGLWaylandKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsBindingOpenGLWaylandKHR as the address of a raw XrGraphicsBindingOpenGLWaylandKHR
 * @relates GraphicsBindingOpenGLWaylandKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWaylandKHR* put(GraphicsBindingOpenGLWaylandKHR& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)
/*!
 * C++ projection of XrSwapchainImageOpenGLKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageOpenGLKHR>
 * @xrentity{XrSwapchainImageOpenGLKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageOpenGLKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageOpenGLKHR(

      void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageOpenGLKHR, next_) {}

  //! Default copy constructor
  SwapchainImageOpenGLKHR(const SwapchainImageOpenGLKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageOpenGLKHR& operator=(const SwapchainImageOpenGLKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageOpenGLKHR(const XrSwapchainImageOpenGLKHR& rhs) : SwapchainImageOpenGLKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageOpenGLKHR& operator=(const XrSwapchainImageOpenGLKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageOpenGLKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageOpenGLKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageOpenGLKHR&() {
    return *reinterpret_cast<XrSwapchainImageOpenGLKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageOpenGLKHR
  XrSwapchainImageOpenGLKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageOpenGLKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageOpenGLKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageOpenGLKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageOpenGLKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageOpenGLKHR*>(this);
  }
  uint32_t image;
};
static_assert(sizeof(XrSwapchainImageOpenGLKHR) == sizeof(SwapchainImageOpenGLKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageOpenGLKHR pointer to const from a
 * SwapchainImageOpenGLKHR reference to const.
 * @relates SwapchainImageOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLKHR const* get(SwapchainImageOpenGLKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageOpenGLKHR as
 * the address of a raw XrSwapchainImageOpenGLKHR
 * @relates SwapchainImageOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLKHR* put(SwapchainImageOpenGLKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageOpenGLKHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageOpenGLKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageOpenGLKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)
/*!
 * C++ projection of XrGraphicsRequirementsOpenGLKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsOpenGLKHR>
 * @xrentity{XrGraphicsRequirementsOpenGLKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsOpenGLKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsOpenGLKHR(

      void* next_ = nullptr)
      : Parent(StructureType::GraphicsRequirementsOpenGLKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsOpenGLKHR(const GraphicsRequirementsOpenGLKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsOpenGLKHR& operator=(const GraphicsRequirementsOpenGLKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsOpenGLKHR(const XrGraphicsRequirementsOpenGLKHR& rhs)
      : GraphicsRequirementsOpenGLKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsOpenGLKHR& operator=(const XrGraphicsRequirementsOpenGLKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsOpenGLKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsOpenGLKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsOpenGLKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsOpenGLKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsOpenGLKHR
  XrGraphicsRequirementsOpenGLKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsOpenGLKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsOpenGLKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsOpenGLKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsOpenGLKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsOpenGLKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsOpenGLKHR) == sizeof(GraphicsRequirementsOpenGLKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsOpenGLKHR pointer to const from a
 * GraphicsRequirementsOpenGLKHR reference to const.
 * @relates GraphicsRequirementsOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLKHR const* get(
    GraphicsRequirementsOpenGLKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsOpenGLKHR
 * as the address of a raw XrGraphicsRequirementsOpenGLKHR
 * @relates GraphicsRequirementsOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLKHR* put(GraphicsRequirementsOpenGLKHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrGraphicsBindingOpenGLESAndroidKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLESAndroidKHR>
 * @xrentity{XrGraphicsBindingOpenGLESAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLESAndroidKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLESAndroidKHR(EGLDisplay display_, EGLConfig config_, EGLContext context_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLESAndroidKHR, next_),
        display{display_},
        config{config_},
        context{context_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLESAndroidKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLESAndroidKHR, next_) {}

  //! Default copy constructor
  GraphicsBindingOpenGLESAndroidKHR(const GraphicsBindingOpenGLESAndroidKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLESAndroidKHR& operator=(const GraphicsBindingOpenGLESAndroidKHR& rhs) =
      default;
  //! Copy construct from raw
  GraphicsBindingOpenGLESAndroidKHR(const XrGraphicsBindingOpenGLESAndroidKHR& rhs)
      : GraphicsBindingOpenGLESAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLESAndroidKHR& operator=(const XrGraphicsBindingOpenGLESAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLESAndroidKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLESAndroidKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR
  XrGraphicsBindingOpenGLESAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLESAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLESAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLESAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }
  EGLDisplay display;
  EGLConfig config;
  EGLContext context;
};
static_assert(sizeof(XrGraphicsBindingOpenGLESAndroidKHR) ==
                  sizeof(GraphicsBindingOpenGLESAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLESAndroidKHR pointer to const from
 * a GraphicsBindingOpenGLESAndroidKHR reference to const.
 * @relates GraphicsBindingOpenGLESAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLESAndroidKHR const* get(
    GraphicsBindingOpenGLESAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsBindingOpenGLESAndroidKHR as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR
 * @relates GraphicsBindingOpenGLESAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLESAndroidKHR* put(
    GraphicsBindingOpenGLESAndroidKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrSwapchainImageOpenGLESKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageOpenGLESKHR>
 * @xrentity{XrSwapchainImageOpenGLESKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageOpenGLESKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageOpenGLESKHR(

      void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageOpenGLESKHR, next_) {}

  //! Default copy constructor
  SwapchainImageOpenGLESKHR(const SwapchainImageOpenGLESKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageOpenGLESKHR& operator=(const SwapchainImageOpenGLESKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageOpenGLESKHR(const XrSwapchainImageOpenGLESKHR& rhs) : SwapchainImageOpenGLESKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageOpenGLESKHR& operator=(const XrSwapchainImageOpenGLESKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageOpenGLESKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageOpenGLESKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageOpenGLESKHR&() {
    return *reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageOpenGLESKHR
  XrSwapchainImageOpenGLESKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageOpenGLESKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageOpenGLESKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageOpenGLESKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageOpenGLESKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(this);
  }
  uint32_t image;
};
static_assert(sizeof(XrSwapchainImageOpenGLESKHR) == sizeof(SwapchainImageOpenGLESKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageOpenGLESKHR pointer to const from a
 * SwapchainImageOpenGLESKHR reference to const.
 * @relates SwapchainImageOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLESKHR const* get(
    SwapchainImageOpenGLESKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageOpenGLESKHR as
 * the address of a raw XrSwapchainImageOpenGLESKHR
 * @relates SwapchainImageOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLESKHR* put(SwapchainImageOpenGLESKHR& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageOpenGLESKHR as a raw,
 * pointer to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageOpenGLESKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageOpenGLESKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrGraphicsRequirementsOpenGLESKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsOpenGLESKHR>
 * @xrentity{XrGraphicsRequirementsOpenGLESKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsOpenGLESKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsOpenGLESKHR(

      void* next_ = nullptr)
      : Parent(StructureType::GraphicsRequirementsOpenGLESKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsOpenGLESKHR(const GraphicsRequirementsOpenGLESKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsOpenGLESKHR& operator=(const GraphicsRequirementsOpenGLESKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsOpenGLESKHR(const XrGraphicsRequirementsOpenGLESKHR& rhs)
      : GraphicsRequirementsOpenGLESKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsOpenGLESKHR& operator=(const XrGraphicsRequirementsOpenGLESKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsOpenGLESKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsOpenGLESKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsOpenGLESKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsOpenGLESKHR
  XrGraphicsRequirementsOpenGLESKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsOpenGLESKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsOpenGLESKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsOpenGLESKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsOpenGLESKHR) == sizeof(GraphicsRequirementsOpenGLESKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsOpenGLESKHR pointer to const from a
 * GraphicsRequirementsOpenGLESKHR reference to const.
 * @relates GraphicsRequirementsOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLESKHR const* get(
    GraphicsRequirementsOpenGLESKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsRequirementsOpenGLESKHR as the address of a raw XrGraphicsRequirementsOpenGLESKHR
 * @relates GraphicsRequirementsOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLESKHR* put(GraphicsRequirementsOpenGLESKHR& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrGraphicsBindingVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingVulkanKHR>
 * @xrentity{XrGraphicsBindingVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingVulkanKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingVulkanKHR(VkInstance instance_, VkPhysicalDevice physicalDevice_, VkDevice device_,
                           uint32_t queueFamilyIndex_, uint32_t queueIndex_,
                           const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingVulkanKHR, next_),
        instance{instance_},
        physicalDevice{physicalDevice_},
        device{device_},
        queueFamilyIndex{queueFamilyIndex_},
        queueIndex{queueIndex_} {}

  //! Default/empty constructor
  GraphicsBindingVulkanKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingVulkanKHR, next_) {}

  //! Default copy constructor
  GraphicsBindingVulkanKHR(const GraphicsBindingVulkanKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingVulkanKHR& operator=(const GraphicsBindingVulkanKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingVulkanKHR(const XrGraphicsBindingVulkanKHR& rhs) : GraphicsBindingVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingVulkanKHR& operator=(const XrGraphicsBindingVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingVulkanKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingVulkanKHR&() {
    return *reinterpret_cast<XrGraphicsBindingVulkanKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingVulkanKHR
  XrGraphicsBindingVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingVulkanKHR*>(this);
  }
  VkInstance instance;
  VkPhysicalDevice physicalDevice;
  VkDevice device;
  uint32_t queueFamilyIndex;
  uint32_t queueIndex;
};
static_assert(sizeof(XrGraphicsBindingVulkanKHR) == sizeof(GraphicsBindingVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingVulkanKHR pointer to const from a
 * GraphicsBindingVulkanKHR reference to const.
 * @relates GraphicsBindingVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingVulkanKHR const* get(GraphicsBindingVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingVulkanKHR as
 * the address of a raw XrGraphicsBindingVulkanKHR
 * @relates GraphicsBindingVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingVulkanKHR* put(GraphicsBindingVulkanKHR& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainImageVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageVulkanKHR>
 * @xrentity{XrSwapchainImageVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageVulkanKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageVulkanKHR(

      void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageVulkanKHR, next_) {}

  //! Default copy constructor
  SwapchainImageVulkanKHR(const SwapchainImageVulkanKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageVulkanKHR& operator=(const SwapchainImageVulkanKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageVulkanKHR(const XrSwapchainImageVulkanKHR& rhs) : SwapchainImageVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageVulkanKHR& operator=(const XrSwapchainImageVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageVulkanKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageVulkanKHR&() {
    return *reinterpret_cast<XrSwapchainImageVulkanKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageVulkanKHR
  XrSwapchainImageVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageVulkanKHR*>(this);
  }
  VkImage image;
};
static_assert(sizeof(XrSwapchainImageVulkanKHR) == sizeof(SwapchainImageVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageVulkanKHR pointer to const from a
 * SwapchainImageVulkanKHR reference to const.
 * @relates SwapchainImageVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageVulkanKHR const* get(SwapchainImageVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageVulkanKHR as
 * the address of a raw XrSwapchainImageVulkanKHR
 * @relates SwapchainImageVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageVulkanKHR* put(SwapchainImageVulkanKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageVulkanKHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageVulkanKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageVulkanKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrGraphicsRequirementsVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsVulkanKHR>
 * @xrentity{XrGraphicsRequirementsVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsVulkanKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsVulkanKHR(

      void* next_ = nullptr)
      : Parent(StructureType::GraphicsRequirementsVulkanKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsVulkanKHR(const GraphicsRequirementsVulkanKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsVulkanKHR& operator=(const GraphicsRequirementsVulkanKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsVulkanKHR(const XrGraphicsRequirementsVulkanKHR& rhs)
      : GraphicsRequirementsVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsVulkanKHR& operator=(const XrGraphicsRequirementsVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsVulkanKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsVulkanKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsVulkanKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsVulkanKHR
  XrGraphicsRequirementsVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsVulkanKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsVulkanKHR) == sizeof(GraphicsRequirementsVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsVulkanKHR pointer to const from a
 * GraphicsRequirementsVulkanKHR reference to const.
 * @relates GraphicsRequirementsVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsVulkanKHR const* get(
    GraphicsRequirementsVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsVulkanKHR
 * as the address of a raw XrGraphicsRequirementsVulkanKHR
 * @relates GraphicsRequirementsVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsVulkanKHR* put(GraphicsRequirementsVulkanKHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrGraphicsBindingD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingD3D11KHR>
 * @xrentity{XrGraphicsBindingD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingD3D11KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingD3D11KHR(ID3D11Device* device_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingD3D11KHR, next_), device{device_} {}

  //! Default/empty constructor
  GraphicsBindingD3D11KHR(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingD3D11KHR, next_) {}

  //! Default copy constructor
  GraphicsBindingD3D11KHR(const GraphicsBindingD3D11KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingD3D11KHR& operator=(const GraphicsBindingD3D11KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingD3D11KHR(const XrGraphicsBindingD3D11KHR& rhs) : GraphicsBindingD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingD3D11KHR& operator=(const XrGraphicsBindingD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingD3D11KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingD3D11KHR&() {
    return *reinterpret_cast<XrGraphicsBindingD3D11KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingD3D11KHR
  XrGraphicsBindingD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingD3D11KHR*>(this);
  }
  ID3D11Device* device;
};
static_assert(sizeof(XrGraphicsBindingD3D11KHR) == sizeof(GraphicsBindingD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingD3D11KHR pointer to const from a
 * GraphicsBindingD3D11KHR reference to const.
 * @relates GraphicsBindingD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D11KHR const* get(GraphicsBindingD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingD3D11KHR as
 * the address of a raw XrGraphicsBindingD3D11KHR
 * @relates GraphicsBindingD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D11KHR* put(GraphicsBindingD3D11KHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrSwapchainImageD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageD3D11KHR>
 * @xrentity{XrSwapchainImageD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageD3D11KHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageD3D11KHR(

      void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageD3D11KHR, next_) {}

  //! Default copy constructor
  SwapchainImageD3D11KHR(const SwapchainImageD3D11KHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageD3D11KHR& operator=(const SwapchainImageD3D11KHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageD3D11KHR(const XrSwapchainImageD3D11KHR& rhs) : SwapchainImageD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageD3D11KHR& operator=(const XrSwapchainImageD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageD3D11KHR&() const {
    return *reinterpret_cast<const XrSwapchainImageD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageD3D11KHR&() {
    return *reinterpret_cast<XrSwapchainImageD3D11KHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageD3D11KHR
  XrSwapchainImageD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageD3D11KHR*>(this);
  }
  ID3D11Texture2D* texture;
};
static_assert(sizeof(XrSwapchainImageD3D11KHR) == sizeof(SwapchainImageD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageD3D11KHR pointer to const from a
 * SwapchainImageD3D11KHR reference to const.
 * @relates SwapchainImageD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D11KHR const* get(SwapchainImageD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageD3D11KHR as the
 * address of a raw XrSwapchainImageD3D11KHR
 * @relates SwapchainImageD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D11KHR* put(SwapchainImageD3D11KHR& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageD3D11KHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageD3D11KHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageD3D11KHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrGraphicsRequirementsD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsD3D11KHR>
 * @xrentity{XrGraphicsRequirementsD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsD3D11KHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsD3D11KHR(

      void* next_ = nullptr)
      : Parent(StructureType::GraphicsRequirementsD3D11KHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsD3D11KHR(const GraphicsRequirementsD3D11KHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsD3D11KHR& operator=(const GraphicsRequirementsD3D11KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsD3D11KHR(const XrGraphicsRequirementsD3D11KHR& rhs)
      : GraphicsRequirementsD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsD3D11KHR& operator=(const XrGraphicsRequirementsD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsD3D11KHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsD3D11KHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsD3D11KHR
  XrGraphicsRequirementsD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(this);
  }
  LUID adapterLuid;
  D3D_FEATURE_LEVEL minFeatureLevel;
};
static_assert(sizeof(XrGraphicsRequirementsD3D11KHR) == sizeof(GraphicsRequirementsD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsD3D11KHR pointer to const from a
 * GraphicsRequirementsD3D11KHR reference to const.
 * @relates GraphicsRequirementsD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D11KHR const* get(
    GraphicsRequirementsD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsD3D11KHR
 * as the address of a raw XrGraphicsRequirementsD3D11KHR
 * @relates GraphicsRequirementsD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D11KHR* put(GraphicsRequirementsD3D11KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrGraphicsBindingD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingD3D12KHR>
 * @xrentity{XrGraphicsBindingD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingD3D12KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingD3D12KHR(ID3D12Device* device_, ID3D12CommandQueue* queue_,
                          const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingD3D12KHR, next_), device{device_}, queue{queue_} {}

  //! Default/empty constructor
  GraphicsBindingD3D12KHR(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingD3D12KHR, next_) {}

  //! Default copy constructor
  GraphicsBindingD3D12KHR(const GraphicsBindingD3D12KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingD3D12KHR& operator=(const GraphicsBindingD3D12KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingD3D12KHR(const XrGraphicsBindingD3D12KHR& rhs) : GraphicsBindingD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingD3D12KHR& operator=(const XrGraphicsBindingD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingD3D12KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingD3D12KHR&() {
    return *reinterpret_cast<XrGraphicsBindingD3D12KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingD3D12KHR
  XrGraphicsBindingD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingD3D12KHR*>(this);
  }
  ID3D12Device* device;
  ID3D12CommandQueue* queue;
};
static_assert(sizeof(XrGraphicsBindingD3D12KHR) == sizeof(GraphicsBindingD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingD3D12KHR pointer to const from a
 * GraphicsBindingD3D12KHR reference to const.
 * @relates GraphicsBindingD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D12KHR const* get(GraphicsBindingD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingD3D12KHR as
 * the address of a raw XrGraphicsBindingD3D12KHR
 * @relates GraphicsBindingD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D12KHR* put(GraphicsBindingD3D12KHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrSwapchainImageD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageD3D12KHR>
 * @xrentity{XrSwapchainImageD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageD3D12KHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageD3D12KHR(

      void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageD3D12KHR, next_) {}

  //! Default copy constructor
  SwapchainImageD3D12KHR(const SwapchainImageD3D12KHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageD3D12KHR& operator=(const SwapchainImageD3D12KHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageD3D12KHR(const XrSwapchainImageD3D12KHR& rhs) : SwapchainImageD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageD3D12KHR& operator=(const XrSwapchainImageD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageD3D12KHR&() const {
    return *reinterpret_cast<const XrSwapchainImageD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageD3D12KHR&() {
    return *reinterpret_cast<XrSwapchainImageD3D12KHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageD3D12KHR
  XrSwapchainImageD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageD3D12KHR*>(this);
  }
  ID3D12Resource* texture;
};
static_assert(sizeof(XrSwapchainImageD3D12KHR) == sizeof(SwapchainImageD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageD3D12KHR pointer to const from a
 * SwapchainImageD3D12KHR reference to const.
 * @relates SwapchainImageD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D12KHR const* get(SwapchainImageD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageD3D12KHR as the
 * address of a raw XrSwapchainImageD3D12KHR
 * @relates SwapchainImageD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D12KHR* put(SwapchainImageD3D12KHR& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageD3D12KHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageD3D12KHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageD3D12KHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrGraphicsRequirementsD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsD3D12KHR>
 * @xrentity{XrGraphicsRequirementsD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsD3D12KHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsD3D12KHR(

      void* next_ = nullptr)
      : Parent(StructureType::GraphicsRequirementsD3D12KHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsD3D12KHR(const GraphicsRequirementsD3D12KHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsD3D12KHR& operator=(const GraphicsRequirementsD3D12KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsD3D12KHR(const XrGraphicsRequirementsD3D12KHR& rhs)
      : GraphicsRequirementsD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsD3D12KHR& operator=(const XrGraphicsRequirementsD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsD3D12KHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsD3D12KHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsD3D12KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsD3D12KHR
  XrGraphicsRequirementsD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsD3D12KHR*>(this);
  }
  LUID adapterLuid;
  D3D_FEATURE_LEVEL minFeatureLevel;
};
static_assert(sizeof(XrGraphicsRequirementsD3D12KHR) == sizeof(GraphicsRequirementsD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsD3D12KHR pointer to const from a
 * GraphicsRequirementsD3D12KHR reference to const.
 * @relates GraphicsRequirementsD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D12KHR const* get(
    GraphicsRequirementsD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsD3D12KHR
 * as the address of a raw XrGraphicsRequirementsD3D12KHR
 * @relates GraphicsRequirementsD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D12KHR* put(GraphicsRequirementsD3D12KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_visibility_mask
/*!
 * C++ projection of XrVisibilityMaskKHR
 *
 * Provided by the `XR_KHR_visibility_mask` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisibilityMaskKHR>
 * @xrentity{XrVisibilityMaskKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VisibilityMaskKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  VisibilityMaskKHR(

      void* next_ = nullptr)
      : Parent(StructureType::VisibilityMaskKHR, next_) {}

  //! Default copy constructor
  VisibilityMaskKHR(const VisibilityMaskKHR& rhs) = default;
  //! Default copy assignment
  VisibilityMaskKHR& operator=(const VisibilityMaskKHR& rhs) = default;
  //! Copy construct from raw
  VisibilityMaskKHR(const XrVisibilityMaskKHR& rhs) : VisibilityMaskKHR() { *put() = rhs; }
  //! Copy assign from raw
  VisibilityMaskKHR& operator=(const XrVisibilityMaskKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVisibilityMaskKHR&() const {
    return *reinterpret_cast<const XrVisibilityMaskKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVisibilityMaskKHR&() { return *reinterpret_cast<XrVisibilityMaskKHR*>(this); }

  //! Accessor for this as the address of a raw XrVisibilityMaskKHR
  XrVisibilityMaskKHR const* get() const noexcept {
    return reinterpret_cast<XrVisibilityMaskKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVisibilityMaskKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVisibilityMaskKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VisibilityMaskKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVisibilityMaskKHR*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector2f* vertices;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrVisibilityMaskKHR) == sizeof(VisibilityMaskKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVisibilityMaskKHR pointer to const from a
 * VisibilityMaskKHR reference to const.
 * @relates VisibilityMaskKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisibilityMaskKHR const* get(VisibilityMaskKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VisibilityMaskKHR as the
 * address of a raw XrVisibilityMaskKHR
 * @relates VisibilityMaskKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisibilityMaskKHR* put(VisibilityMaskKHR& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_visibility_mask

#ifdef XR_KHR_visibility_mask
/*!
 * C++ projection of XrEventDataVisibilityMaskChangedKHR
 *
 * Provided by the `XR_KHR_visibility_mask` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVisibilityMaskChangedKHR>
 * @xrentity{XrEventDataVisibilityMaskChangedKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataVisibilityMaskChangedKHR : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataVisibilityMaskChangedKHR(const Session& session_,
                                    const ViewConfigurationType& viewConfigurationType_,
                                    uint32_t viewIndex_, const void* next_ = nullptr)
      : Parent(StructureType::EventDataVisibilityMaskChangedKHR, next_),
        session{session_},
        viewConfigurationType{viewConfigurationType_},
        viewIndex{viewIndex_} {}

  //! Default/empty constructor
  EventDataVisibilityMaskChangedKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataVisibilityMaskChangedKHR, next_) {}

  //! Default copy constructor
  EventDataVisibilityMaskChangedKHR(const EventDataVisibilityMaskChangedKHR& rhs) = default;
  //! Default copy assignment
  EventDataVisibilityMaskChangedKHR& operator=(const EventDataVisibilityMaskChangedKHR& rhs) =
      default;
  //! Copy construct from raw
  EventDataVisibilityMaskChangedKHR(const XrEventDataVisibilityMaskChangedKHR& rhs)
      : EventDataVisibilityMaskChangedKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataVisibilityMaskChangedKHR& operator=(const XrEventDataVisibilityMaskChangedKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataVisibilityMaskChangedKHR&() const {
    return *reinterpret_cast<const XrEventDataVisibilityMaskChangedKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataVisibilityMaskChangedKHR&() {
    return *reinterpret_cast<XrEventDataVisibilityMaskChangedKHR*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataVisibilityMaskChangedKHR
  XrEventDataVisibilityMaskChangedKHR const* get() const noexcept {
    return reinterpret_cast<XrEventDataVisibilityMaskChangedKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataVisibilityMaskChangedKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataVisibilityMaskChangedKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataVisibilityMaskChangedKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataVisibilityMaskChangedKHR*>(this);
  }
  Session session;
  ViewConfigurationType viewConfigurationType;
  uint32_t viewIndex;
};
static_assert(sizeof(XrEventDataVisibilityMaskChangedKHR) ==
                  sizeof(EventDataVisibilityMaskChangedKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataVisibilityMaskChangedKHR pointer to const from
 * a EventDataVisibilityMaskChangedKHR reference to const.
 * @relates EventDataVisibilityMaskChangedKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVisibilityMaskChangedKHR const* get(
    EventDataVisibilityMaskChangedKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataVisibilityMaskChangedKHR as the address of a raw XrEventDataVisibilityMaskChangedKHR
 * @relates EventDataVisibilityMaskChangedKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVisibilityMaskChangedKHR* put(
    EventDataVisibilityMaskChangedKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataVisibilityMaskChangedKHR as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataVisibilityMaskChangedKHR
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataVisibilityMaskChangedKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_visibility_mask

#ifdef XR_KHR_composition_layer_color_scale_bias
/*!
 * C++ projection of XrCompositionLayerColorScaleBiasKHR
 *
 * Provided by the `XR_KHR_composition_layer_color_scale_bias` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerColorScaleBiasKHR>
 * @xrentity{XrCompositionLayerColorScaleBiasKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerColorScaleBiasKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerColorScaleBiasKHR(const Color4f& colorScale_, const Color4f& colorBias_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerColorScaleBiasKHR, next_),
        colorScale{colorScale_},
        colorBias{colorBias_} {}

  //! Default/empty constructor
  CompositionLayerColorScaleBiasKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerColorScaleBiasKHR, next_) {}

  //! Default copy constructor
  CompositionLayerColorScaleBiasKHR(const CompositionLayerColorScaleBiasKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerColorScaleBiasKHR& operator=(const CompositionLayerColorScaleBiasKHR& rhs) =
      default;
  //! Copy construct from raw
  CompositionLayerColorScaleBiasKHR(const XrCompositionLayerColorScaleBiasKHR& rhs)
      : CompositionLayerColorScaleBiasKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerColorScaleBiasKHR& operator=(const XrCompositionLayerColorScaleBiasKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerColorScaleBiasKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerColorScaleBiasKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerColorScaleBiasKHR&() {
    return *reinterpret_cast<XrCompositionLayerColorScaleBiasKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerColorScaleBiasKHR
  XrCompositionLayerColorScaleBiasKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerColorScaleBiasKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerColorScaleBiasKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerColorScaleBiasKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerColorScaleBiasKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerColorScaleBiasKHR*>(this);
  }
  Color4f colorScale;
  Color4f colorBias;
};
static_assert(sizeof(XrCompositionLayerColorScaleBiasKHR) ==
                  sizeof(CompositionLayerColorScaleBiasKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerColorScaleBiasKHR pointer to const from
 * a CompositionLayerColorScaleBiasKHR reference to const.
 * @relates CompositionLayerColorScaleBiasKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerColorScaleBiasKHR const* get(
    CompositionLayerColorScaleBiasKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerColorScaleBiasKHR as the address of a raw XrCompositionLayerColorScaleBiasKHR
 * @relates CompositionLayerColorScaleBiasKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerColorScaleBiasKHR* put(
    CompositionLayerColorScaleBiasKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_composition_layer_color_scale_bias

#ifdef XR_KHR_loader_init
/*!
 * C++ projection of XrLoaderInitInfoBaseHeaderKHR
 *
 * Provided by the `XR_KHR_loader_init` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInitInfoBaseHeaderKHR>
 * @xrentity{XrLoaderInitInfoBaseHeaderKHR}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS LoaderInitInfoBaseHeaderKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  LoaderInitInfoBaseHeaderKHR(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLoaderInitInfoBaseHeaderKHR&() const {
    return *reinterpret_cast<const XrLoaderInitInfoBaseHeaderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLoaderInitInfoBaseHeaderKHR&() {
    return *reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrLoaderInitInfoBaseHeaderKHR
  XrLoaderInitInfoBaseHeaderKHR const* get() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR const*>(this);
  }
};
static_assert(sizeof(XrLoaderInitInfoBaseHeaderKHR) == sizeof(LoaderInitInfoBaseHeaderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLoaderInitInfoBaseHeaderKHR pointer to const from a
 * LoaderInitInfoBaseHeaderKHR reference to const.
 * @relates LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR const* get(
    LoaderInitInfoBaseHeaderKHR const& s) {
  return s.get();
}

#endif  // XR_KHR_loader_init

#ifdef XR_KHR_loader_init_android
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrLoaderInitInfoAndroidKHR
 *
 * Provided by the `XR_KHR_loader_init_android` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInitInfoAndroidKHR>
 * @xrentity{XrLoaderInitInfoAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS LoaderInitInfoAndroidKHR : public LoaderInitInfoBaseHeaderKHR {
private:
  using Parent = LoaderInitInfoBaseHeaderKHR;

public:
  //! Constructor initializing all members.
  LoaderInitInfoAndroidKHR(void* XR_MAY_ALIAS applicationVM_,
                           void* XR_MAY_ALIAS applicationContext_, const void* next_ = nullptr)
      : Parent(StructureType::LoaderInitInfoAndroidKHR, next_),
        applicationVM{applicationVM_},
        applicationContext{applicationContext_} {}

  //! Default/empty constructor
  LoaderInitInfoAndroidKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::LoaderInitInfoAndroidKHR, next_) {}

  //! Default copy constructor
  LoaderInitInfoAndroidKHR(const LoaderInitInfoAndroidKHR& rhs) = default;
  //! Default copy assignment
  LoaderInitInfoAndroidKHR& operator=(const LoaderInitInfoAndroidKHR& rhs) = default;
  //! Copy construct from raw
  LoaderInitInfoAndroidKHR(const XrLoaderInitInfoAndroidKHR& rhs) : LoaderInitInfoAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  LoaderInitInfoAndroidKHR& operator=(const XrLoaderInitInfoAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLoaderInitInfoAndroidKHR&() const {
    return *reinterpret_cast<const XrLoaderInitInfoAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLoaderInitInfoAndroidKHR&() {
    return *reinterpret_cast<XrLoaderInitInfoAndroidKHR*>(this);
  }

  //! Accessor for this as a raw, base XrLoaderInitInfoBaseHeaderKHR const pointer
  XrLoaderInitInfoBaseHeaderKHR const* get_base() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR const*>(this);
  }
  //! Accessor for this as the address of a raw XrLoaderInitInfoAndroidKHR
  XrLoaderInitInfoAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrLoaderInitInfoAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrLoaderInitInfoAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = LoaderInitInfoAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrLoaderInitInfoAndroidKHR*>(this);
  }
  void* XR_MAY_ALIAS applicationVM;
  void* XR_MAY_ALIAS applicationContext;
};
static_assert(sizeof(XrLoaderInitInfoAndroidKHR) == sizeof(LoaderInitInfoAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLoaderInitInfoAndroidKHR pointer to const from a
 * LoaderInitInfoAndroidKHR reference to const.
 * @relates LoaderInitInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoAndroidKHR const* get(LoaderInitInfoAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing LoaderInitInfoAndroidKHR as
 * the address of a raw XrLoaderInitInfoAndroidKHR
 * @relates LoaderInitInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoAndroidKHR* put(LoaderInitInfoAndroidKHR& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const LoaderInitInfoAndroidKHR as a raw, pointer
 * to const XrLoaderInitInfoBaseHeaderKHR (the base type)
 * @relates LoaderInitInfoAndroidKHR
 * @relatesalso LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR const* get_base(
    LoaderInitInfoAndroidKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_loader_init_android

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanInstanceCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanInstanceCreateInfoKHR>
 * @xrentity{XrVulkanInstanceCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanInstanceCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanInstanceCreateInfoKHR(const SystemId& systemId_,
                              const VulkanInstanceCreateFlagsKHR& createFlags_,
                              PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr_,
                              const VkInstanceCreateInfo* vulkanCreateInfo_,
                              const VkAllocationCallbacks* vulkanAllocator_,
                              const void* next_ = nullptr)
      : Parent(StructureType::VulkanInstanceCreateInfoKHR, next_),
        systemId{systemId_},
        createFlags{createFlags_},
        pfnGetInstanceProcAddr{pfnGetInstanceProcAddr_},
        vulkanCreateInfo{vulkanCreateInfo_},
        vulkanAllocator{vulkanAllocator_} {}

  //! Default/empty constructor
  VulkanInstanceCreateInfoKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::VulkanInstanceCreateInfoKHR, next_) {}

  //! Default copy constructor
  VulkanInstanceCreateInfoKHR(const VulkanInstanceCreateInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanInstanceCreateInfoKHR& operator=(const VulkanInstanceCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanInstanceCreateInfoKHR(const XrVulkanInstanceCreateInfoKHR& rhs)
      : VulkanInstanceCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanInstanceCreateInfoKHR& operator=(const XrVulkanInstanceCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanInstanceCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanInstanceCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanInstanceCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanInstanceCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanInstanceCreateInfoKHR
  XrVulkanInstanceCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanInstanceCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanInstanceCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanInstanceCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanInstanceCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanInstanceCreateInfoKHR*>(this);
  }
  SystemId systemId;
  VulkanInstanceCreateFlagsKHR createFlags;
  PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
  const VkInstanceCreateInfo* vulkanCreateInfo;
  const VkAllocationCallbacks* vulkanAllocator;
};
static_assert(sizeof(XrVulkanInstanceCreateInfoKHR) == sizeof(VulkanInstanceCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanInstanceCreateInfoKHR pointer to const from a
 * VulkanInstanceCreateInfoKHR reference to const.
 * @relates VulkanInstanceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanInstanceCreateInfoKHR const* get(
    VulkanInstanceCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanInstanceCreateInfoKHR
 * as the address of a raw XrVulkanInstanceCreateInfoKHR
 * @relates VulkanInstanceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanInstanceCreateInfoKHR* put(VulkanInstanceCreateInfoKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanDeviceCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanDeviceCreateInfoKHR>
 * @xrentity{XrVulkanDeviceCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanDeviceCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanDeviceCreateInfoKHR(const SystemId& systemId_,
                            const VulkanDeviceCreateFlagsKHR& createFlags_,
                            PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr_,
                            VkPhysicalDevice vulkanPhysicalDevice_,
                            const VkDeviceCreateInfo* vulkanCreateInfo_,
                            const VkAllocationCallbacks* vulkanAllocator_,
                            const void* next_ = nullptr)
      : Parent(StructureType::VulkanDeviceCreateInfoKHR, next_),
        systemId{systemId_},
        createFlags{createFlags_},
        pfnGetInstanceProcAddr{pfnGetInstanceProcAddr_},
        vulkanPhysicalDevice{vulkanPhysicalDevice_},
        vulkanCreateInfo{vulkanCreateInfo_},
        vulkanAllocator{vulkanAllocator_} {}

  //! Default/empty constructor
  VulkanDeviceCreateInfoKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::VulkanDeviceCreateInfoKHR, next_) {}

  //! Default copy constructor
  VulkanDeviceCreateInfoKHR(const VulkanDeviceCreateInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanDeviceCreateInfoKHR& operator=(const VulkanDeviceCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanDeviceCreateInfoKHR(const XrVulkanDeviceCreateInfoKHR& rhs) : VulkanDeviceCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanDeviceCreateInfoKHR& operator=(const XrVulkanDeviceCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanDeviceCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanDeviceCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanDeviceCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanDeviceCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanDeviceCreateInfoKHR
  XrVulkanDeviceCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanDeviceCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanDeviceCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanDeviceCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanDeviceCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanDeviceCreateInfoKHR*>(this);
  }
  SystemId systemId;
  VulkanDeviceCreateFlagsKHR createFlags;
  PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
  VkPhysicalDevice vulkanPhysicalDevice;
  const VkDeviceCreateInfo* vulkanCreateInfo;
  const VkAllocationCallbacks* vulkanAllocator;
};
static_assert(sizeof(XrVulkanDeviceCreateInfoKHR) == sizeof(VulkanDeviceCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanDeviceCreateInfoKHR pointer to const from a
 * VulkanDeviceCreateInfoKHR reference to const.
 * @relates VulkanDeviceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanDeviceCreateInfoKHR const* get(
    VulkanDeviceCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanDeviceCreateInfoKHR as
 * the address of a raw XrVulkanDeviceCreateInfoKHR
 * @relates VulkanDeviceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanDeviceCreateInfoKHR* put(VulkanDeviceCreateInfoKHR& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanGraphicsDeviceGetInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanGraphicsDeviceGetInfoKHR>
 * @xrentity{XrVulkanGraphicsDeviceGetInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanGraphicsDeviceGetInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanGraphicsDeviceGetInfoKHR(const SystemId& systemId_, VkInstance vulkanInstance_,
                                 const void* next_ = nullptr)
      : Parent(StructureType::VulkanGraphicsDeviceGetInfoKHR, next_),
        systemId{systemId_},
        vulkanInstance{vulkanInstance_} {}

  //! Default/empty constructor
  VulkanGraphicsDeviceGetInfoKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::VulkanGraphicsDeviceGetInfoKHR, next_) {}

  //! Default copy constructor
  VulkanGraphicsDeviceGetInfoKHR(const VulkanGraphicsDeviceGetInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanGraphicsDeviceGetInfoKHR& operator=(const VulkanGraphicsDeviceGetInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanGraphicsDeviceGetInfoKHR(const XrVulkanGraphicsDeviceGetInfoKHR& rhs)
      : VulkanGraphicsDeviceGetInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanGraphicsDeviceGetInfoKHR& operator=(const XrVulkanGraphicsDeviceGetInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanGraphicsDeviceGetInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanGraphicsDeviceGetInfoKHR&() {
    return *reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR
  XrVulkanGraphicsDeviceGetInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanGraphicsDeviceGetInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanGraphicsDeviceGetInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanGraphicsDeviceGetInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }
  SystemId systemId;
  VkInstance vulkanInstance;
};
static_assert(sizeof(XrVulkanGraphicsDeviceGetInfoKHR) == sizeof(VulkanGraphicsDeviceGetInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanGraphicsDeviceGetInfoKHR pointer to const from a
 * VulkanGraphicsDeviceGetInfoKHR reference to const.
 * @relates VulkanGraphicsDeviceGetInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanGraphicsDeviceGetInfoKHR const* get(
    VulkanGraphicsDeviceGetInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VulkanGraphicsDeviceGetInfoKHR as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR
 * @relates VulkanGraphicsDeviceGetInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanGraphicsDeviceGetInfoKHR* put(VulkanGraphicsDeviceGetInfoKHR& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_composition_layer_equirect2
/*!
 * C++ projection of XrCompositionLayerEquirect2KHR
 *
 * Provided by the `XR_KHR_composition_layer_equirect2` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerEquirect2KHR>
 * @xrentity{XrCompositionLayerEquirect2KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerEquirect2KHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerEquirect2KHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                               const EyeVisibility& eyeVisibility_,
                               const SwapchainSubImage& subImage_, const Posef& pose_,
                               float radius_, float centralHorizontalAngle_,
                               float upperVerticalAngle_, float lowerVerticalAngle_,
                               const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerEquirect2KHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        centralHorizontalAngle{centralHorizontalAngle_},
        upperVerticalAngle{upperVerticalAngle_},
        lowerVerticalAngle{lowerVerticalAngle_} {}

  //! Default/empty constructor
  CompositionLayerEquirect2KHR(

      const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerEquirect2KHR, {}, {}, next_) {}

  //! Default copy constructor
  CompositionLayerEquirect2KHR(const CompositionLayerEquirect2KHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerEquirect2KHR& operator=(const CompositionLayerEquirect2KHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerEquirect2KHR(const XrCompositionLayerEquirect2KHR& rhs)
      : CompositionLayerEquirect2KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerEquirect2KHR& operator=(const XrCompositionLayerEquirect2KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerEquirect2KHR&() const {
    return *reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerEquirect2KHR&() {
    return *reinterpret_cast<XrCompositionLayerEquirect2KHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerEquirect2KHR
  XrCompositionLayerEquirect2KHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerEquirect2KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerEquirect2KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerEquirect2KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerEquirect2KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerEquirect2KHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  float centralHorizontalAngle;
  float upperVerticalAngle;
  float lowerVerticalAngle;
};
static_assert(sizeof(XrCompositionLayerEquirect2KHR) == sizeof(CompositionLayerEquirect2KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerEquirect2KHR pointer to const from a
 * CompositionLayerEquirect2KHR reference to const.
 * @relates CompositionLayerEquirect2KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirect2KHR const* get(
    CompositionLayerEquirect2KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerEquirect2KHR
 * as the address of a raw XrCompositionLayerEquirect2KHR
 * @relates CompositionLayerEquirect2KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirect2KHR* put(CompositionLayerEquirect2KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerEquirect2KHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerEquirect2KHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerEquirect2KHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_equirect2

#ifdef XR_KHR_binding_modification
/*!
 * C++ projection of XrBindingModificationBaseHeaderKHR
 *
 * Provided by the `XR_KHR_binding_modification` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBindingModificationBaseHeaderKHR>
 * @xrentity{XrBindingModificationBaseHeaderKHR}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS BindingModificationBaseHeaderKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  BindingModificationBaseHeaderKHR(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBindingModificationBaseHeaderKHR&() const {
    return *reinterpret_cast<const XrBindingModificationBaseHeaderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBindingModificationBaseHeaderKHR&() {
    return *reinterpret_cast<XrBindingModificationBaseHeaderKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrBindingModificationBaseHeaderKHR
  XrBindingModificationBaseHeaderKHR const* get() const noexcept {
    return reinterpret_cast<XrBindingModificationBaseHeaderKHR const*>(this);
  }
};
static_assert(sizeof(XrBindingModificationBaseHeaderKHR) ==
                  sizeof(BindingModificationBaseHeaderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBindingModificationBaseHeaderKHR pointer to const from a
 * BindingModificationBaseHeaderKHR reference to const.
 * @relates BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get(
    BindingModificationBaseHeaderKHR const& s) {
  return s.get();
}

#endif  // XR_KHR_binding_modification

#ifdef XR_KHR_binding_modification
/*!
 * C++ projection of XrBindingModificationsKHR
 *
 * Provided by the `XR_KHR_binding_modification` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBindingModificationsKHR>
 * @xrentity{XrBindingModificationsKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BindingModificationsKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BindingModificationsKHR(uint32_t bindingModificationCount_,
                          const BindingModificationBaseHeaderKHR* const* bindingModifications_,
                          const void* next_ = nullptr)
      : Parent(StructureType::BindingModificationsKHR, next_),
        bindingModificationCount{bindingModificationCount_},
        bindingModifications{bindingModifications_} {}

  //! Default/empty constructor
  BindingModificationsKHR(

      const void* next_ = nullptr)
      : Parent(StructureType::BindingModificationsKHR, next_) {}

  //! Default copy constructor
  BindingModificationsKHR(const BindingModificationsKHR& rhs) = default;
  //! Default copy assignment
  BindingModificationsKHR& operator=(const BindingModificationsKHR& rhs) = default;
  //! Copy construct from raw
  BindingModificationsKHR(const XrBindingModificationsKHR& rhs) : BindingModificationsKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BindingModificationsKHR& operator=(const XrBindingModificationsKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBindingModificationsKHR&() const {
    return *reinterpret_cast<const XrBindingModificationsKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBindingModificationsKHR&() {
    return *reinterpret_cast<XrBindingModificationsKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrBindingModificationsKHR
  XrBindingModificationsKHR const* get() const noexcept {
    return reinterpret_cast<XrBindingModificationsKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBindingModificationsKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBindingModificationsKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BindingModificationsKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrBindingModificationsKHR*>(this);
  }
  uint32_t bindingModificationCount;
  const BindingModificationBaseHeaderKHR* const* bindingModifications;
};
static_assert(sizeof(XrBindingModificationsKHR) == sizeof(BindingModificationsKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBindingModificationsKHR pointer to const from a
 * BindingModificationsKHR reference to const.
 * @relates BindingModificationsKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationsKHR const* get(BindingModificationsKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BindingModificationsKHR as
 * the address of a raw XrBindingModificationsKHR
 * @relates BindingModificationsKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationsKHR* put(BindingModificationsKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_binding_modification

#ifdef XR_EXT_performance_settings
/*!
 * C++ projection of XrEventDataPerfSettingsEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataPerfSettingsEXT>
 * @xrentity{XrEventDataPerfSettingsEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataPerfSettingsEXT : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataPerfSettingsEXT(const PerfSettingsDomainEXT& domain_,
                           const PerfSettingsSubDomainEXT& subDomain_,
                           const PerfSettingsNotificationLevelEXT& fromLevel_,
                           const PerfSettingsNotificationLevelEXT& toLevel_,
                           const void* next_ = nullptr)
      : Parent(StructureType::EventDataPerfSettingsEXT, next_),
        domain{domain_},
        subDomain{subDomain_},
        fromLevel{fromLevel_},
        toLevel{toLevel_} {}

  //! Default/empty constructor
  EventDataPerfSettingsEXT(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataPerfSettingsEXT, next_) {}

  //! Default copy constructor
  EventDataPerfSettingsEXT(const EventDataPerfSettingsEXT& rhs) = default;
  //! Default copy assignment
  EventDataPerfSettingsEXT& operator=(const EventDataPerfSettingsEXT& rhs) = default;
  //! Copy construct from raw
  EventDataPerfSettingsEXT(const XrEventDataPerfSettingsEXT& rhs) : EventDataPerfSettingsEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataPerfSettingsEXT& operator=(const XrEventDataPerfSettingsEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataPerfSettingsEXT&() const {
    return *reinterpret_cast<const XrEventDataPerfSettingsEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataPerfSettingsEXT&() {
    return *reinterpret_cast<XrEventDataPerfSettingsEXT*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataPerfSettingsEXT
  XrEventDataPerfSettingsEXT const* get() const noexcept {
    return reinterpret_cast<XrEventDataPerfSettingsEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataPerfSettingsEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataPerfSettingsEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataPerfSettingsEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataPerfSettingsEXT*>(this);
  }
  PerfSettingsDomainEXT domain;
  PerfSettingsSubDomainEXT subDomain;
  PerfSettingsNotificationLevelEXT fromLevel;
  PerfSettingsNotificationLevelEXT toLevel;
};
static_assert(sizeof(XrEventDataPerfSettingsEXT) == sizeof(EventDataPerfSettingsEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataPerfSettingsEXT pointer to const from a
 * EventDataPerfSettingsEXT reference to const.
 * @relates EventDataPerfSettingsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPerfSettingsEXT const* get(EventDataPerfSettingsEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataPerfSettingsEXT as
 * the address of a raw XrEventDataPerfSettingsEXT
 * @relates EventDataPerfSettingsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPerfSettingsEXT* put(EventDataPerfSettingsEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataPerfSettingsEXT as a raw, pointer
 * to const XrEventDataBaseHeader (the base type)
 * @relates EventDataPerfSettingsEXT
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataPerfSettingsEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsObjectNameInfoEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsObjectNameInfoEXT>
 * @xrentity{XrDebugUtilsObjectNameInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsObjectNameInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsObjectNameInfoEXT(const ObjectType& objectType_, uint64_t objectHandle_,
                              const char* objectName_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsObjectNameInfoEXT, next_),
        objectType{objectType_},
        objectHandle{objectHandle_},
        objectName{objectName_} {}

  //! Default/empty constructor
  DebugUtilsObjectNameInfoEXT(

      const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsObjectNameInfoEXT, next_) {}

  //! Default copy constructor
  DebugUtilsObjectNameInfoEXT(const DebugUtilsObjectNameInfoEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsObjectNameInfoEXT& operator=(const DebugUtilsObjectNameInfoEXT& rhs) = default;
  //! Copy construct from raw
  DebugUtilsObjectNameInfoEXT(const XrDebugUtilsObjectNameInfoEXT& rhs)
      : DebugUtilsObjectNameInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsObjectNameInfoEXT& operator=(const XrDebugUtilsObjectNameInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsObjectNameInfoEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsObjectNameInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsObjectNameInfoEXT&() {
    return *reinterpret_cast<XrDebugUtilsObjectNameInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsObjectNameInfoEXT
  XrDebugUtilsObjectNameInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsObjectNameInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsObjectNameInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsObjectNameInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsObjectNameInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsObjectNameInfoEXT*>(this);
  }
  ObjectType objectType;
  uint64_t objectHandle;
  const char* objectName;
};
static_assert(sizeof(XrDebugUtilsObjectNameInfoEXT) == sizeof(DebugUtilsObjectNameInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsObjectNameInfoEXT pointer to const from a
 * DebugUtilsObjectNameInfoEXT reference to const.
 * @relates DebugUtilsObjectNameInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsObjectNameInfoEXT const* get(
    DebugUtilsObjectNameInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsObjectNameInfoEXT
 * as the address of a raw XrDebugUtilsObjectNameInfoEXT
 * @relates DebugUtilsObjectNameInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsObjectNameInfoEXT* put(DebugUtilsObjectNameInfoEXT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsLabelEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsLabelEXT>
 * @xrentity{XrDebugUtilsLabelEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsLabelEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsLabelEXT(const char* labelName_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsLabelEXT, next_), labelName{labelName_} {}

  //! Default/empty constructor
  DebugUtilsLabelEXT(

      const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsLabelEXT, next_) {}

  //! Default copy constructor
  DebugUtilsLabelEXT(const DebugUtilsLabelEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsLabelEXT& operator=(const DebugUtilsLabelEXT& rhs) = default;
  //! Copy construct from raw
  DebugUtilsLabelEXT(const XrDebugUtilsLabelEXT& rhs) : DebugUtilsLabelEXT() { *put() = rhs; }
  //! Copy assign from raw
  DebugUtilsLabelEXT& operator=(const XrDebugUtilsLabelEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsLabelEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsLabelEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsLabelEXT&() { return *reinterpret_cast<XrDebugUtilsLabelEXT*>(this); }

  //! Accessor for this as the address of a raw XrDebugUtilsLabelEXT
  XrDebugUtilsLabelEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsLabelEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrDebugUtilsLabelEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsLabelEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsLabelEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsLabelEXT*>(this);
  }
  const char* labelName;
};
static_assert(sizeof(XrDebugUtilsLabelEXT) == sizeof(DebugUtilsLabelEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsLabelEXT pointer to const from a
 * DebugUtilsLabelEXT reference to const.
 * @relates DebugUtilsLabelEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsLabelEXT const* get(DebugUtilsLabelEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsLabelEXT as the
 * address of a raw XrDebugUtilsLabelEXT
 * @relates DebugUtilsLabelEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsLabelEXT* put(DebugUtilsLabelEXT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsMessengerCallbackDataEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerCallbackDataEXT>
 * @xrentity{XrDebugUtilsMessengerCallbackDataEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsMessengerCallbackDataEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsMessengerCallbackDataEXT(const char* messageId_, const char* functionName_,
                                     const char* message_, uint32_t objectCount_,
                                     DebugUtilsObjectNameInfoEXT* objects_,
                                     uint32_t sessionLabelCount_,
                                     DebugUtilsLabelEXT* sessionLabels_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsMessengerCallbackDataEXT, next_),
        messageId{messageId_},
        functionName{functionName_},
        message{message_},
        objectCount{objectCount_},
        objects{objects_},
        sessionLabelCount{sessionLabelCount_},
        sessionLabels{sessionLabels_} {}

  //! Default/empty constructor
  DebugUtilsMessengerCallbackDataEXT(

      const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsMessengerCallbackDataEXT, next_) {}

  //! Default copy constructor
  DebugUtilsMessengerCallbackDataEXT(const DebugUtilsMessengerCallbackDataEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsMessengerCallbackDataEXT& operator=(const DebugUtilsMessengerCallbackDataEXT& rhs) =
      default;
  //! Copy construct from raw
  DebugUtilsMessengerCallbackDataEXT(const XrDebugUtilsMessengerCallbackDataEXT& rhs)
      : DebugUtilsMessengerCallbackDataEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsMessengerCallbackDataEXT& operator=(const XrDebugUtilsMessengerCallbackDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsMessengerCallbackDataEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsMessengerCallbackDataEXT&() {
    return *reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsMessengerCallbackDataEXT
  XrDebugUtilsMessengerCallbackDataEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsMessengerCallbackDataEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsMessengerCallbackDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsMessengerCallbackDataEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }
  const char* messageId;
  const char* functionName;
  const char* message;
  uint32_t objectCount;
  DebugUtilsObjectNameInfoEXT* objects;
  uint32_t sessionLabelCount;
  DebugUtilsLabelEXT* sessionLabels;
};
static_assert(sizeof(XrDebugUtilsMessengerCallbackDataEXT) ==
                  sizeof(DebugUtilsMessengerCallbackDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsMessengerCallbackDataEXT pointer to const from
 * a DebugUtilsMessengerCallbackDataEXT reference to const.
 * @relates DebugUtilsMessengerCallbackDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCallbackDataEXT const* get(
    DebugUtilsMessengerCallbackDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * DebugUtilsMessengerCallbackDataEXT as the address of a raw XrDebugUtilsMessengerCallbackDataEXT
 * @relates DebugUtilsMessengerCallbackDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCallbackDataEXT* put(
    DebugUtilsMessengerCallbackDataEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsMessengerCreateInfoEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerCreateInfoEXT>
 * @xrentity{XrDebugUtilsMessengerCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsMessengerCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsMessengerCreateInfoEXT(const DebugUtilsMessageSeverityFlagsEXT& messageSeverities_,
                                   const DebugUtilsMessageTypeFlagsEXT& messageTypes_,
                                   PFN_xrDebugUtilsMessengerCallbackEXT userCallback_,
                                   void* XR_MAY_ALIAS userData_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsMessengerCreateInfoEXT, next_),
        messageSeverities{messageSeverities_},
        messageTypes{messageTypes_},
        userCallback{userCallback_},
        userData{userData_} {}

  //! Default/empty constructor
  DebugUtilsMessengerCreateInfoEXT(

      const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsMessengerCreateInfoEXT, next_) {}

  //! Default copy constructor
  DebugUtilsMessengerCreateInfoEXT(const DebugUtilsMessengerCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsMessengerCreateInfoEXT& operator=(const DebugUtilsMessengerCreateInfoEXT& rhs) =
      default;
  //! Copy construct from raw
  DebugUtilsMessengerCreateInfoEXT(const XrDebugUtilsMessengerCreateInfoEXT& rhs)
      : DebugUtilsMessengerCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsMessengerCreateInfoEXT& operator=(const XrDebugUtilsMessengerCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsMessengerCreateInfoEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsMessengerCreateInfoEXT&() {
    return *reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsMessengerCreateInfoEXT
  XrDebugUtilsMessengerCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsMessengerCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsMessengerCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsMessengerCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }
  DebugUtilsMessageSeverityFlagsEXT messageSeverities;
  DebugUtilsMessageTypeFlagsEXT messageTypes;
  PFN_xrDebugUtilsMessengerCallbackEXT userCallback;
  void* XR_MAY_ALIAS userData;
};
static_assert(sizeof(XrDebugUtilsMessengerCreateInfoEXT) ==
                  sizeof(DebugUtilsMessengerCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsMessengerCreateInfoEXT pointer to const from a
 * DebugUtilsMessengerCreateInfoEXT reference to const.
 * @relates DebugUtilsMessengerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCreateInfoEXT const* get(
    DebugUtilsMessengerCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * DebugUtilsMessengerCreateInfoEXT as the address of a raw XrDebugUtilsMessengerCreateInfoEXT
 * @relates DebugUtilsMessengerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCreateInfoEXT* put(
    DebugUtilsMessengerCreateInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_eye_gaze_interaction
/*!
 * C++ projection of XrSystemEyeGazeInteractionPropertiesEXT
 *
 * Provided by the `XR_EXT_eye_gaze_interaction` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemEyeGazeInteractionPropertiesEXT>
 * @xrentity{XrSystemEyeGazeInteractionPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemEyeGazeInteractionPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemEyeGazeInteractionPropertiesEXT(

      void* next_ = nullptr)
      : Parent(StructureType::SystemEyeGazeInteractionPropertiesEXT, next_) {}

  //! Default copy constructor
  SystemEyeGazeInteractionPropertiesEXT(const SystemEyeGazeInteractionPropertiesEXT& rhs) = default;
  //! Default copy assignment
  SystemEyeGazeInteractionPropertiesEXT& operator=(
      const SystemEyeGazeInteractionPropertiesEXT& rhs) = default;
  //! Copy construct from raw
  SystemEyeGazeInteractionPropertiesEXT(const XrSystemEyeGazeInteractionPropertiesEXT& rhs)
      : SystemEyeGazeInteractionPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemEyeGazeInteractionPropertiesEXT& operator=(
      const XrSystemEyeGazeInteractionPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemEyeGazeInteractionPropertiesEXT&() const {
    return *reinterpret_cast<const XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemEyeGazeInteractionPropertiesEXT&() {
    return *reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemEyeGazeInteractionPropertiesEXT
  XrSystemEyeGazeInteractionPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemEyeGazeInteractionPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemEyeGazeInteractionPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemEyeGazeInteractionPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }
  Bool32 supportsEyeGazeInteraction;
};
static_assert(sizeof(XrSystemEyeGazeInteractionPropertiesEXT) ==
                  sizeof(SystemEyeGazeInteractionPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemEyeGazeInteractionPropertiesEXT pointer to const
 * from a SystemEyeGazeInteractionPropertiesEXT reference to const.
 * @relates SystemEyeGazeInteractionPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEyeGazeInteractionPropertiesEXT const* get(
    SystemEyeGazeInteractionPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemEyeGazeInteractionPropertiesEXT as the address of a raw
 * XrSystemEyeGazeInteractionPropertiesEXT
 * @relates SystemEyeGazeInteractionPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEyeGazeInteractionPropertiesEXT* put(
    SystemEyeGazeInteractionPropertiesEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_eye_gaze_interaction

#ifdef XR_EXT_eye_gaze_interaction
/*!
 * C++ projection of XrEyeGazeSampleTimeEXT
 *
 * Provided by the `XR_EXT_eye_gaze_interaction` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazeSampleTimeEXT>
 * @xrentity{XrEyeGazeSampleTimeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EyeGazeSampleTimeEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EyeGazeSampleTimeEXT(

      void* next_ = nullptr)
      : Parent(StructureType::EyeGazeSampleTimeEXT, next_) {}

  //! Default copy constructor
  EyeGazeSampleTimeEXT(const EyeGazeSampleTimeEXT& rhs) = default;
  //! Default copy assignment
  EyeGazeSampleTimeEXT& operator=(const EyeGazeSampleTimeEXT& rhs) = default;
  //! Copy construct from raw
  EyeGazeSampleTimeEXT(const XrEyeGazeSampleTimeEXT& rhs) : EyeGazeSampleTimeEXT() { *put() = rhs; }
  //! Copy assign from raw
  EyeGazeSampleTimeEXT& operator=(const XrEyeGazeSampleTimeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEyeGazeSampleTimeEXT&() const {
    return *reinterpret_cast<const XrEyeGazeSampleTimeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEyeGazeSampleTimeEXT&() { return *reinterpret_cast<XrEyeGazeSampleTimeEXT*>(this); }

  //! Accessor for this as the address of a raw XrEyeGazeSampleTimeEXT
  XrEyeGazeSampleTimeEXT const* get() const noexcept {
    return reinterpret_cast<XrEyeGazeSampleTimeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazeSampleTimeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEyeGazeSampleTimeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EyeGazeSampleTimeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEyeGazeSampleTimeEXT*>(this);
  }
  Time time;
};
static_assert(sizeof(XrEyeGazeSampleTimeEXT) == sizeof(EyeGazeSampleTimeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEyeGazeSampleTimeEXT pointer to const from a
 * EyeGazeSampleTimeEXT reference to const.
 * @relates EyeGazeSampleTimeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazeSampleTimeEXT const* get(EyeGazeSampleTimeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazeSampleTimeEXT as the
 * address of a raw XrEyeGazeSampleTimeEXT
 * @relates EyeGazeSampleTimeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazeSampleTimeEXT* put(EyeGazeSampleTimeEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_eye_gaze_interaction

#ifdef XR_EXTX_overlay
/*!
 * C++ projection of XrSessionCreateInfoOverlayEXTX
 *
 * Provided by the `XR_EXTX_overlay` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionCreateInfoOverlayEXTX>
 * @xrentity{XrSessionCreateInfoOverlayEXTX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionCreateInfoOverlayEXTX : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionCreateInfoOverlayEXTX(const OverlaySessionCreateFlagsEXTX& createFlags_,
                               uint32_t sessionLayersPlacement_, const void* next_ = nullptr)
      : Parent(StructureType::SessionCreateInfoOverlayEXTX, next_),
        createFlags{createFlags_},
        sessionLayersPlacement{sessionLayersPlacement_} {}

  //! Default/empty constructor
  SessionCreateInfoOverlayEXTX(

      const void* next_ = nullptr)
      : Parent(StructureType::SessionCreateInfoOverlayEXTX, next_) {}

  //! Default copy constructor
  SessionCreateInfoOverlayEXTX(const SessionCreateInfoOverlayEXTX& rhs) = default;
  //! Default copy assignment
  SessionCreateInfoOverlayEXTX& operator=(const SessionCreateInfoOverlayEXTX& rhs) = default;
  //! Copy construct from raw
  SessionCreateInfoOverlayEXTX(const XrSessionCreateInfoOverlayEXTX& rhs)
      : SessionCreateInfoOverlayEXTX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SessionCreateInfoOverlayEXTX& operator=(const XrSessionCreateInfoOverlayEXTX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionCreateInfoOverlayEXTX&() const {
    return *reinterpret_cast<const XrSessionCreateInfoOverlayEXTX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionCreateInfoOverlayEXTX&() {
    return *reinterpret_cast<XrSessionCreateInfoOverlayEXTX*>(this);
  }

  //! Accessor for this as the address of a raw XrSessionCreateInfoOverlayEXTX
  XrSessionCreateInfoOverlayEXTX const* get() const noexcept {
    return reinterpret_cast<XrSessionCreateInfoOverlayEXTX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSessionCreateInfoOverlayEXTX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionCreateInfoOverlayEXTX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionCreateInfoOverlayEXTX{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionCreateInfoOverlayEXTX*>(this);
  }
  OverlaySessionCreateFlagsEXTX createFlags;
  uint32_t sessionLayersPlacement;
};
static_assert(sizeof(XrSessionCreateInfoOverlayEXTX) == sizeof(SessionCreateInfoOverlayEXTX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionCreateInfoOverlayEXTX pointer to const from a
 * SessionCreateInfoOverlayEXTX reference to const.
 * @relates SessionCreateInfoOverlayEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfoOverlayEXTX const* get(
    SessionCreateInfoOverlayEXTX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionCreateInfoOverlayEXTX
 * as the address of a raw XrSessionCreateInfoOverlayEXTX
 * @relates SessionCreateInfoOverlayEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfoOverlayEXTX* put(SessionCreateInfoOverlayEXTX& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXTX_overlay

#ifdef XR_EXTX_overlay
/*!
 * C++ projection of XrEventDataMainSessionVisibilityChangedEXTX
 *
 * Provided by the `XR_EXTX_overlay` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataMainSessionVisibilityChangedEXTX>
 * @xrentity{XrEventDataMainSessionVisibilityChangedEXTX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataMainSessionVisibilityChangedEXTX : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataMainSessionVisibilityChangedEXTX(const Bool32& visible_,
                                            const OverlayMainSessionFlagsEXTX& flags_,
                                            const void* next_ = nullptr)
      : Parent(StructureType::EventDataMainSessionVisibilityChangedEXTX, next_),
        visible{visible_},
        flags{flags_} {}

  //! Default/empty constructor
  EventDataMainSessionVisibilityChangedEXTX(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataMainSessionVisibilityChangedEXTX, next_) {}

  //! Default copy constructor
  EventDataMainSessionVisibilityChangedEXTX(const EventDataMainSessionVisibilityChangedEXTX& rhs) =
      default;
  //! Default copy assignment
  EventDataMainSessionVisibilityChangedEXTX& operator=(
      const EventDataMainSessionVisibilityChangedEXTX& rhs) = default;
  //! Copy construct from raw
  EventDataMainSessionVisibilityChangedEXTX(const XrEventDataMainSessionVisibilityChangedEXTX& rhs)
      : EventDataMainSessionVisibilityChangedEXTX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataMainSessionVisibilityChangedEXTX& operator=(
      const XrEventDataMainSessionVisibilityChangedEXTX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataMainSessionVisibilityChangedEXTX&() const {
    return *reinterpret_cast<const XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataMainSessionVisibilityChangedEXTX&() {
    return *reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataMainSessionVisibilityChangedEXTX
  XrEventDataMainSessionVisibilityChangedEXTX const* get() const noexcept {
    return reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataMainSessionVisibilityChangedEXTX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataMainSessionVisibilityChangedEXTX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataMainSessionVisibilityChangedEXTX{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }
  Bool32 visible;
  OverlayMainSessionFlagsEXTX flags;
};
static_assert(sizeof(XrEventDataMainSessionVisibilityChangedEXTX) ==
                  sizeof(EventDataMainSessionVisibilityChangedEXTX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataMainSessionVisibilityChangedEXTX pointer to
 * const from a EventDataMainSessionVisibilityChangedEXTX reference to const.
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMainSessionVisibilityChangedEXTX const* get(
    EventDataMainSessionVisibilityChangedEXTX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataMainSessionVisibilityChangedEXTX as the address of a raw
 * XrEventDataMainSessionVisibilityChangedEXTX
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMainSessionVisibilityChangedEXTX* put(
    EventDataMainSessionVisibilityChangedEXTX& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataMainSessionVisibilityChangedEXTX
 * as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataMainSessionVisibilityChangedEXTX const& h) {
  return h.get_base();
}
#endif  // XR_EXTX_overlay

#ifdef XR_MSFT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorCreateInfoMSFT(const Space& space_, const Posef& pose_, const Time& time_,
                              const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorCreateInfoMSFT, next_),
        space{space_},
        pose{pose_},
        time{time_} {}

  //! Default/empty constructor
  SpatialAnchorCreateInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorCreateInfoMSFT, next_) {}

  //! Default copy constructor
  SpatialAnchorCreateInfoMSFT(const SpatialAnchorCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCreateInfoMSFT& operator=(const SpatialAnchorCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCreateInfoMSFT(const XrSpatialAnchorCreateInfoMSFT& rhs)
      : SpatialAnchorCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCreateInfoMSFT& operator=(const XrSpatialAnchorCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoMSFT
  XrSpatialAnchorCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorCreateInfoMSFT*>(this);
  }
  Space space;
  Posef pose;
  Time time;
};
static_assert(sizeof(XrSpatialAnchorCreateInfoMSFT) == sizeof(SpatialAnchorCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoMSFT pointer to const from a
 * SpatialAnchorCreateInfoMSFT reference to const.
 * @relates SpatialAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoMSFT const* get(
    SpatialAnchorCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoMSFT
 * as the address of a raw XrSpatialAnchorCreateInfoMSFT
 * @relates SpatialAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoMSFT* put(SpatialAnchorCreateInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorSpaceCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorSpaceCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorSpaceCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorSpaceCreateInfoMSFT(const SpatialAnchorMSFT& anchor_,
                                   const Posef& poseInAnchorSpace_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorSpaceCreateInfoMSFT, next_),
        anchor{anchor_},
        poseInAnchorSpace{poseInAnchorSpace_} {}

  //! Default/empty constructor
  SpatialAnchorSpaceCreateInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorSpaceCreateInfoMSFT, next_) {}

  //! Default copy constructor
  SpatialAnchorSpaceCreateInfoMSFT(const SpatialAnchorSpaceCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorSpaceCreateInfoMSFT& operator=(const SpatialAnchorSpaceCreateInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorSpaceCreateInfoMSFT(const XrSpatialAnchorSpaceCreateInfoMSFT& rhs)
      : SpatialAnchorSpaceCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorSpaceCreateInfoMSFT& operator=(const XrSpatialAnchorSpaceCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorSpaceCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorSpaceCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT
  XrSpatialAnchorSpaceCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorSpaceCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorSpaceCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorSpaceCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }
  SpatialAnchorMSFT anchor;
  Posef poseInAnchorSpace;
};
static_assert(sizeof(XrSpatialAnchorSpaceCreateInfoMSFT) ==
                  sizeof(SpatialAnchorSpaceCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorSpaceCreateInfoMSFT pointer to const from a
 * SpatialAnchorSpaceCreateInfoMSFT reference to const.
 * @relates SpatialAnchorSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorSpaceCreateInfoMSFT const* get(
    SpatialAnchorSpaceCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorSpaceCreateInfoMSFT as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT
 * @relates SpatialAnchorSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorSpaceCreateInfoMSFT* put(
    SpatialAnchorSpaceCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor

#ifdef XR_EXT_view_configuration_depth_range
/*!
 * C++ projection of XrViewConfigurationDepthRangeEXT
 *
 * Provided by the `XR_EXT_view_configuration_depth_range` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationDepthRangeEXT>
 * @xrentity{XrViewConfigurationDepthRangeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationDepthRangeEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationDepthRangeEXT(

      void* next_ = nullptr)
      : Parent(StructureType::ViewConfigurationDepthRangeEXT, next_) {}

  //! Default copy constructor
  ViewConfigurationDepthRangeEXT(const ViewConfigurationDepthRangeEXT& rhs) = default;
  //! Default copy assignment
  ViewConfigurationDepthRangeEXT& operator=(const ViewConfigurationDepthRangeEXT& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationDepthRangeEXT(const XrViewConfigurationDepthRangeEXT& rhs)
      : ViewConfigurationDepthRangeEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationDepthRangeEXT& operator=(const XrViewConfigurationDepthRangeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationDepthRangeEXT&() const {
    return *reinterpret_cast<const XrViewConfigurationDepthRangeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationDepthRangeEXT&() {
    return *reinterpret_cast<XrViewConfigurationDepthRangeEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationDepthRangeEXT
  XrViewConfigurationDepthRangeEXT const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationDepthRangeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationDepthRangeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationDepthRangeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationDepthRangeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationDepthRangeEXT*>(this);
  }
  float recommendedNearZ;
  float minNearZ;
  float recommendedFarZ;
  float maxFarZ;
};
static_assert(sizeof(XrViewConfigurationDepthRangeEXT) == sizeof(ViewConfigurationDepthRangeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationDepthRangeEXT pointer to const from a
 * ViewConfigurationDepthRangeEXT reference to const.
 * @relates ViewConfigurationDepthRangeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationDepthRangeEXT const* get(
    ViewConfigurationDepthRangeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ViewConfigurationDepthRangeEXT as the address of a raw XrViewConfigurationDepthRangeEXT
 * @relates ViewConfigurationDepthRangeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationDepthRangeEXT* put(ViewConfigurationDepthRangeEXT& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_view_configuration_depth_range

#ifdef XR_MNDX_egl_enable
#if defined(XR_USE_PLATFORM_EGL)
/*!
 * C++ projection of XrGraphicsBindingEGLMNDX
 *
 * Provided by the `XR_MNDX_egl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingEGLMNDX>
 * @xrentity{XrGraphicsBindingEGLMNDX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingEGLMNDX : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingEGLMNDX(PFNEGLGETPROCADDRESSPROC getProcAddress_, EGLDisplay display_,
                         EGLConfig config_, EGLContext context_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingEGLMNDX, next_),
        getProcAddress{getProcAddress_},
        display{display_},
        config{config_},
        context{context_} {}

  //! Default/empty constructor
  GraphicsBindingEGLMNDX(

      const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingEGLMNDX, next_) {}

  //! Default copy constructor
  GraphicsBindingEGLMNDX(const GraphicsBindingEGLMNDX& rhs) = default;
  //! Default copy assignment
  GraphicsBindingEGLMNDX& operator=(const GraphicsBindingEGLMNDX& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingEGLMNDX(const XrGraphicsBindingEGLMNDX& rhs) : GraphicsBindingEGLMNDX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingEGLMNDX& operator=(const XrGraphicsBindingEGLMNDX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingEGLMNDX&() const {
    return *reinterpret_cast<const XrGraphicsBindingEGLMNDX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingEGLMNDX&() {
    return *reinterpret_cast<XrGraphicsBindingEGLMNDX*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingEGLMNDX
  XrGraphicsBindingEGLMNDX const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingEGLMNDX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingEGLMNDX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingEGLMNDX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingEGLMNDX{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingEGLMNDX*>(this);
  }
  PFNEGLGETPROCADDRESSPROC getProcAddress;
  EGLDisplay display;
  EGLConfig config;
  EGLContext context;
};
static_assert(sizeof(XrGraphicsBindingEGLMNDX) == sizeof(GraphicsBindingEGLMNDX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingEGLMNDX pointer to const from a
 * GraphicsBindingEGLMNDX reference to const.
 * @relates GraphicsBindingEGLMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingEGLMNDX const* get(GraphicsBindingEGLMNDX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingEGLMNDX as the
 * address of a raw XrGraphicsBindingEGLMNDX
 * @relates GraphicsBindingEGLMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingEGLMNDX* put(GraphicsBindingEGLMNDX& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_EGL)
#endif  // XR_MNDX_egl_enable

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrSystemHandTrackingPropertiesEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHandTrackingPropertiesEXT>
 * @xrentity{XrSystemHandTrackingPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemHandTrackingPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemHandTrackingPropertiesEXT(

      void* next_ = nullptr)
      : Parent(StructureType::SystemHandTrackingPropertiesEXT, next_) {}

  //! Default copy constructor
  SystemHandTrackingPropertiesEXT(const SystemHandTrackingPropertiesEXT& rhs) = default;
  //! Default copy assignment
  SystemHandTrackingPropertiesEXT& operator=(const SystemHandTrackingPropertiesEXT& rhs) = default;
  //! Copy construct from raw
  SystemHandTrackingPropertiesEXT(const XrSystemHandTrackingPropertiesEXT& rhs)
      : SystemHandTrackingPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemHandTrackingPropertiesEXT& operator=(const XrSystemHandTrackingPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemHandTrackingPropertiesEXT&() const {
    return *reinterpret_cast<const XrSystemHandTrackingPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemHandTrackingPropertiesEXT&() {
    return *reinterpret_cast<XrSystemHandTrackingPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemHandTrackingPropertiesEXT
  XrSystemHandTrackingPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrSystemHandTrackingPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemHandTrackingPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemHandTrackingPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemHandTrackingPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemHandTrackingPropertiesEXT*>(this);
  }
  Bool32 supportsHandTracking;
};
static_assert(sizeof(XrSystemHandTrackingPropertiesEXT) == sizeof(SystemHandTrackingPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemHandTrackingPropertiesEXT pointer to const from a
 * SystemHandTrackingPropertiesEXT reference to const.
 * @relates SystemHandTrackingPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingPropertiesEXT const* get(
    SystemHandTrackingPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemHandTrackingPropertiesEXT as the address of a raw XrSystemHandTrackingPropertiesEXT
 * @relates SystemHandTrackingPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingPropertiesEXT* put(SystemHandTrackingPropertiesEXT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandTrackerCreateInfoEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackerCreateInfoEXT>
 * @xrentity{XrHandTrackerCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackerCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandTrackerCreateInfoEXT(const HandEXT& hand_, const HandJointSetEXT& handJointSet_,
                           const void* next_ = nullptr)
      : Parent(StructureType::HandTrackerCreateInfoEXT, next_),
        hand{hand_},
        handJointSet{handJointSet_} {}

  //! Default/empty constructor
  HandTrackerCreateInfoEXT(

      const void* next_ = nullptr)
      : Parent(StructureType::HandTrackerCreateInfoEXT, next_) {}

  //! Default copy constructor
  HandTrackerCreateInfoEXT(const HandTrackerCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  HandTrackerCreateInfoEXT& operator=(const HandTrackerCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandTrackerCreateInfoEXT(const XrHandTrackerCreateInfoEXT& rhs) : HandTrackerCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackerCreateInfoEXT& operator=(const XrHandTrackerCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackerCreateInfoEXT&() const {
    return *reinterpret_cast<const XrHandTrackerCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackerCreateInfoEXT&() {
    return *reinterpret_cast<XrHandTrackerCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackerCreateInfoEXT
  XrHandTrackerCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandTrackerCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandTrackerCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackerCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackerCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackerCreateInfoEXT*>(this);
  }
  HandEXT hand;
  HandJointSetEXT handJointSet;
};
static_assert(sizeof(XrHandTrackerCreateInfoEXT) == sizeof(HandTrackerCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackerCreateInfoEXT pointer to const from a
 * HandTrackerCreateInfoEXT reference to const.
 * @relates HandTrackerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackerCreateInfoEXT const* get(HandTrackerCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackerCreateInfoEXT as
 * the address of a raw XrHandTrackerCreateInfoEXT
 * @relates HandTrackerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackerCreateInfoEXT* put(HandTrackerCreateInfoEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointsLocateInfoEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsLocateInfoEXT>
 * @xrentity{XrHandJointsLocateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointsLocateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandJointsLocateInfoEXT(const Space& baseSpace_, const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::HandJointsLocateInfoEXT, next_), baseSpace{baseSpace_}, time{time_} {}

  //! Default/empty constructor
  HandJointsLocateInfoEXT(

      const void* next_ = nullptr)
      : Parent(StructureType::HandJointsLocateInfoEXT, next_) {}

  //! Default copy constructor
  HandJointsLocateInfoEXT(const HandJointsLocateInfoEXT& rhs) = default;
  //! Default copy assignment
  HandJointsLocateInfoEXT& operator=(const HandJointsLocateInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandJointsLocateInfoEXT(const XrHandJointsLocateInfoEXT& rhs) : HandJointsLocateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointsLocateInfoEXT& operator=(const XrHandJointsLocateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointsLocateInfoEXT&() const {
    return *reinterpret_cast<const XrHandJointsLocateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointsLocateInfoEXT&() {
    return *reinterpret_cast<XrHandJointsLocateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandJointsLocateInfoEXT
  XrHandJointsLocateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointsLocateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandJointsLocateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointsLocateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointsLocateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointsLocateInfoEXT*>(this);
  }
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrHandJointsLocateInfoEXT) == sizeof(HandJointsLocateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointsLocateInfoEXT pointer to const from a
 * HandJointsLocateInfoEXT reference to const.
 * @relates HandJointsLocateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsLocateInfoEXT const* get(HandJointsLocateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointsLocateInfoEXT as
 * the address of a raw XrHandJointsLocateInfoEXT
 * @relates HandJointsLocateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsLocateInfoEXT* put(HandJointsLocateInfoEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointLocationEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointLocationEXT>
 * @xrentity{XrHandJointLocationEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandJointLocationEXT {
public:
  //! Constructor initializing all members.
  HandJointLocationEXT(const SpaceLocationFlags& locationFlags_, const Posef& pose_, float radius_)
      : locationFlags{locationFlags_}, pose{pose_}, radius{radius_} {}

  //! Default/empty constructor
  HandJointLocationEXT(

  ) {}

  //! Default copy constructor
  HandJointLocationEXT(const HandJointLocationEXT& rhs) = default;
  //! Default copy assignment
  HandJointLocationEXT& operator=(const HandJointLocationEXT& rhs) = default;
  //! Copy construct from raw
  HandJointLocationEXT(const XrHandJointLocationEXT& rhs) : HandJointLocationEXT() { *put() = rhs; }
  //! Copy assign from raw
  HandJointLocationEXT& operator=(const XrHandJointLocationEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointLocationEXT&() const {
    return *reinterpret_cast<const XrHandJointLocationEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointLocationEXT&() { return *reinterpret_cast<XrHandJointLocationEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointLocationEXT
  XrHandJointLocationEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointLocationEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointLocationEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandJointLocationEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandJointLocationEXT{};
    }
    return reinterpret_cast<XrHandJointLocationEXT*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
  float radius;
};
static_assert(sizeof(XrHandJointLocationEXT) == sizeof(HandJointLocationEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointLocationEXT pointer to const from a
 * HandJointLocationEXT reference to const.
 * @relates HandJointLocationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationEXT const* get(HandJointLocationEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointLocationEXT as the
 * address of a raw XrHandJointLocationEXT
 * @relates HandJointLocationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationEXT* put(HandJointLocationEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointVelocityEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointVelocityEXT>
 * @xrentity{XrHandJointVelocityEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandJointVelocityEXT {
public:
  //! Constructor initializing all members.
  HandJointVelocityEXT(const SpaceVelocityFlags& velocityFlags_, const Vector3f& linearVelocity_,
                       const Vector3f& angularVelocity_)
      : velocityFlags{velocityFlags_},
        linearVelocity{linearVelocity_},
        angularVelocity{angularVelocity_} {}

  //! Default/empty constructor
  HandJointVelocityEXT(

  ) {}

  //! Default copy constructor
  HandJointVelocityEXT(const HandJointVelocityEXT& rhs) = default;
  //! Default copy assignment
  HandJointVelocityEXT& operator=(const HandJointVelocityEXT& rhs) = default;
  //! Copy construct from raw
  HandJointVelocityEXT(const XrHandJointVelocityEXT& rhs) : HandJointVelocityEXT() { *put() = rhs; }
  //! Copy assign from raw
  HandJointVelocityEXT& operator=(const XrHandJointVelocityEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointVelocityEXT&() const {
    return *reinterpret_cast<const XrHandJointVelocityEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointVelocityEXT&() { return *reinterpret_cast<XrHandJointVelocityEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointVelocityEXT
  XrHandJointVelocityEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointVelocityEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointVelocityEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandJointVelocityEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandJointVelocityEXT{};
    }
    return reinterpret_cast<XrHandJointVelocityEXT*>(this);
  }
  SpaceVelocityFlags velocityFlags;
  Vector3f linearVelocity;
  Vector3f angularVelocity;
};
static_assert(sizeof(XrHandJointVelocityEXT) == sizeof(HandJointVelocityEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointVelocityEXT pointer to const from a
 * HandJointVelocityEXT reference to const.
 * @relates HandJointVelocityEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocityEXT const* get(HandJointVelocityEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointVelocityEXT as the
 * address of a raw XrHandJointVelocityEXT
 * @relates HandJointVelocityEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocityEXT* put(HandJointVelocityEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointLocationsEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointLocationsEXT>
 * @xrentity{XrHandJointLocationsEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointLocationsEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandJointLocationsEXT(

      void* next_ = nullptr)
      : Parent(StructureType::HandJointLocationsEXT, next_) {}

  //! Default copy constructor
  HandJointLocationsEXT(const HandJointLocationsEXT& rhs) = default;
  //! Default copy assignment
  HandJointLocationsEXT& operator=(const HandJointLocationsEXT& rhs) = default;
  //! Copy construct from raw
  HandJointLocationsEXT(const XrHandJointLocationsEXT& rhs) : HandJointLocationsEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointLocationsEXT& operator=(const XrHandJointLocationsEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointLocationsEXT&() const {
    return *reinterpret_cast<const XrHandJointLocationsEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointLocationsEXT&() { return *reinterpret_cast<XrHandJointLocationsEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointLocationsEXT
  XrHandJointLocationsEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointLocationsEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointLocationsEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointLocationsEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointLocationsEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointLocationsEXT*>(this);
  }
  Bool32 isActive;
  uint32_t jointCount;
  HandJointLocationEXT* jointLocations;
};
static_assert(sizeof(XrHandJointLocationsEXT) == sizeof(HandJointLocationsEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointLocationsEXT pointer to const from a
 * HandJointLocationsEXT reference to const.
 * @relates HandJointLocationsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationsEXT const* get(HandJointLocationsEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointLocationsEXT as the
 * address of a raw XrHandJointLocationsEXT
 * @relates HandJointLocationsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationsEXT* put(HandJointLocationsEXT& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointVelocitiesEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointVelocitiesEXT>
 * @xrentity{XrHandJointVelocitiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointVelocitiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandJointVelocitiesEXT(

      void* next_ = nullptr)
      : Parent(StructureType::HandJointVelocitiesEXT, next_) {}

  //! Default copy constructor
  HandJointVelocitiesEXT(const HandJointVelocitiesEXT& rhs) = default;
  //! Default copy assignment
  HandJointVelocitiesEXT& operator=(const HandJointVelocitiesEXT& rhs) = default;
  //! Copy construct from raw
  HandJointVelocitiesEXT(const XrHandJointVelocitiesEXT& rhs) : HandJointVelocitiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointVelocitiesEXT& operator=(const XrHandJointVelocitiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointVelocitiesEXT&() const {
    return *reinterpret_cast<const XrHandJointVelocitiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointVelocitiesEXT&() {
    return *reinterpret_cast<XrHandJointVelocitiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandJointVelocitiesEXT
  XrHandJointVelocitiesEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointVelocitiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointVelocitiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointVelocitiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointVelocitiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointVelocitiesEXT*>(this);
  }
  uint32_t jointCount;
  HandJointVelocityEXT* jointVelocities;
};
static_assert(sizeof(XrHandJointVelocitiesEXT) == sizeof(HandJointVelocitiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointVelocitiesEXT pointer to const from a
 * HandJointVelocitiesEXT reference to const.
 * @relates HandJointVelocitiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocitiesEXT const* get(HandJointVelocitiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointVelocitiesEXT as the
 * address of a raw XrHandJointVelocitiesEXT
 * @relates HandJointVelocitiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocitiesEXT* put(HandJointVelocitiesEXT& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrSystemHandTrackingMeshPropertiesMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHandTrackingMeshPropertiesMSFT>
 * @xrentity{XrSystemHandTrackingMeshPropertiesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemHandTrackingMeshPropertiesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemHandTrackingMeshPropertiesMSFT(

      void* next_ = nullptr)
      : Parent(StructureType::SystemHandTrackingMeshPropertiesMSFT, next_) {}

  //! Default copy constructor
  SystemHandTrackingMeshPropertiesMSFT(const SystemHandTrackingMeshPropertiesMSFT& rhs) = default;
  //! Default copy assignment
  SystemHandTrackingMeshPropertiesMSFT& operator=(const SystemHandTrackingMeshPropertiesMSFT& rhs) =
      default;
  //! Copy construct from raw
  SystemHandTrackingMeshPropertiesMSFT(const XrSystemHandTrackingMeshPropertiesMSFT& rhs)
      : SystemHandTrackingMeshPropertiesMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemHandTrackingMeshPropertiesMSFT& operator=(
      const XrSystemHandTrackingMeshPropertiesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemHandTrackingMeshPropertiesMSFT&() const {
    return *reinterpret_cast<const XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemHandTrackingMeshPropertiesMSFT&() {
    return *reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemHandTrackingMeshPropertiesMSFT
  XrSystemHandTrackingMeshPropertiesMSFT const* get() const noexcept {
    return reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemHandTrackingMeshPropertiesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemHandTrackingMeshPropertiesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemHandTrackingMeshPropertiesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }
  Bool32 supportsHandTrackingMesh;
  uint32_t maxHandMeshIndexCount;
  uint32_t maxHandMeshVertexCount;
};
static_assert(sizeof(XrSystemHandTrackingMeshPropertiesMSFT) ==
                  sizeof(SystemHandTrackingMeshPropertiesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemHandTrackingMeshPropertiesMSFT pointer to const
 * from a SystemHandTrackingMeshPropertiesMSFT reference to const.
 * @relates SystemHandTrackingMeshPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingMeshPropertiesMSFT const* get(
    SystemHandTrackingMeshPropertiesMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemHandTrackingMeshPropertiesMSFT as the address of a raw
 * XrSystemHandTrackingMeshPropertiesMSFT
 * @relates SystemHandTrackingMeshPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingMeshPropertiesMSFT* put(
    SystemHandTrackingMeshPropertiesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshSpaceCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshSpaceCreateInfoMSFT>
 * @xrentity{XrHandMeshSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshSpaceCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandMeshSpaceCreateInfoMSFT(const HandPoseTypeMSFT& handPoseType_,
                              const Posef& poseInHandMeshSpace_, const void* next_ = nullptr)
      : Parent(StructureType::HandMeshSpaceCreateInfoMSFT, next_),
        handPoseType{handPoseType_},
        poseInHandMeshSpace{poseInHandMeshSpace_} {}

  //! Default/empty constructor
  HandMeshSpaceCreateInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::HandMeshSpaceCreateInfoMSFT, next_) {}

  //! Default copy constructor
  HandMeshSpaceCreateInfoMSFT(const HandMeshSpaceCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshSpaceCreateInfoMSFT& operator=(const HandMeshSpaceCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshSpaceCreateInfoMSFT(const XrHandMeshSpaceCreateInfoMSFT& rhs)
      : HandMeshSpaceCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshSpaceCreateInfoMSFT& operator=(const XrHandMeshSpaceCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshSpaceCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrHandMeshSpaceCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshSpaceCreateInfoMSFT&() {
    return *reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshSpaceCreateInfoMSFT
  XrHandMeshSpaceCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshSpaceCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshSpaceCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshSpaceCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT*>(this);
  }
  HandPoseTypeMSFT handPoseType;
  Posef poseInHandMeshSpace;
};
static_assert(sizeof(XrHandMeshSpaceCreateInfoMSFT) == sizeof(HandMeshSpaceCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshSpaceCreateInfoMSFT pointer to const from a
 * HandMeshSpaceCreateInfoMSFT reference to const.
 * @relates HandMeshSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshSpaceCreateInfoMSFT const* get(
    HandMeshSpaceCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshSpaceCreateInfoMSFT
 * as the address of a raw XrHandMeshSpaceCreateInfoMSFT
 * @relates HandMeshSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshSpaceCreateInfoMSFT* put(HandMeshSpaceCreateInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshUpdateInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshUpdateInfoMSFT>
 * @xrentity{XrHandMeshUpdateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshUpdateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandMeshUpdateInfoMSFT(const Time& time_, const HandPoseTypeMSFT& handPoseType_,
                         const void* next_ = nullptr)
      : Parent(StructureType::HandMeshUpdateInfoMSFT, next_),
        time{time_},
        handPoseType{handPoseType_} {}

  //! Default/empty constructor
  HandMeshUpdateInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::HandMeshUpdateInfoMSFT, next_) {}

  //! Default copy constructor
  HandMeshUpdateInfoMSFT(const HandMeshUpdateInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshUpdateInfoMSFT& operator=(const HandMeshUpdateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshUpdateInfoMSFT(const XrHandMeshUpdateInfoMSFT& rhs) : HandMeshUpdateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshUpdateInfoMSFT& operator=(const XrHandMeshUpdateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshUpdateInfoMSFT&() const {
    return *reinterpret_cast<const XrHandMeshUpdateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshUpdateInfoMSFT&() {
    return *reinterpret_cast<XrHandMeshUpdateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshUpdateInfoMSFT
  XrHandMeshUpdateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshUpdateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshUpdateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshUpdateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshUpdateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshUpdateInfoMSFT*>(this);
  }
  Time time;
  HandPoseTypeMSFT handPoseType;
};
static_assert(sizeof(XrHandMeshUpdateInfoMSFT) == sizeof(HandMeshUpdateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshUpdateInfoMSFT pointer to const from a
 * HandMeshUpdateInfoMSFT reference to const.
 * @relates HandMeshUpdateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshUpdateInfoMSFT const* get(HandMeshUpdateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshUpdateInfoMSFT as the
 * address of a raw XrHandMeshUpdateInfoMSFT
 * @relates HandMeshUpdateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshUpdateInfoMSFT* put(HandMeshUpdateInfoMSFT& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshIndexBufferMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshIndexBufferMSFT>
 * @xrentity{XrHandMeshIndexBufferMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshIndexBufferMSFT {
public:
  //! Constructor initializing all members.
  HandMeshIndexBufferMSFT(uint32_t indexBufferKey_, uint32_t indexCapacityInput_,
                          uint32_t indexCountOutput_, uint32_t* indices_)
      : indexBufferKey{indexBufferKey_},
        indexCapacityInput{indexCapacityInput_},
        indexCountOutput{indexCountOutput_},
        indices{indices_} {}

  //! Default/empty constructor
  HandMeshIndexBufferMSFT(

  ) {}

  //! Default copy constructor
  HandMeshIndexBufferMSFT(const HandMeshIndexBufferMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshIndexBufferMSFT& operator=(const HandMeshIndexBufferMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshIndexBufferMSFT(const XrHandMeshIndexBufferMSFT& rhs) : HandMeshIndexBufferMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshIndexBufferMSFT& operator=(const XrHandMeshIndexBufferMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshIndexBufferMSFT&() const {
    return *reinterpret_cast<const XrHandMeshIndexBufferMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshIndexBufferMSFT&() {
    return *reinterpret_cast<XrHandMeshIndexBufferMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshIndexBufferMSFT
  XrHandMeshIndexBufferMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshIndexBufferMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshIndexBufferMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshIndexBufferMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshIndexBufferMSFT{};
    }
    return reinterpret_cast<XrHandMeshIndexBufferMSFT*>(this);
  }
  uint32_t indexBufferKey;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrHandMeshIndexBufferMSFT) == sizeof(HandMeshIndexBufferMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshIndexBufferMSFT pointer to const from a
 * HandMeshIndexBufferMSFT reference to const.
 * @relates HandMeshIndexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshIndexBufferMSFT const* get(HandMeshIndexBufferMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshIndexBufferMSFT as
 * the address of a raw XrHandMeshIndexBufferMSFT
 * @relates HandMeshIndexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshIndexBufferMSFT* put(HandMeshIndexBufferMSFT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshVertexMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshVertexMSFT>
 * @xrentity{XrHandMeshVertexMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshVertexMSFT {
public:
  //! Constructor initializing all members.
  HandMeshVertexMSFT(const Vector3f& position_, const Vector3f& normal_)
      : position{position_}, normal{normal_} {}

  //! Default/empty constructor
  HandMeshVertexMSFT(

  ) {}

  //! Default copy constructor
  HandMeshVertexMSFT(const HandMeshVertexMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshVertexMSFT& operator=(const HandMeshVertexMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshVertexMSFT(const XrHandMeshVertexMSFT& rhs) : HandMeshVertexMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandMeshVertexMSFT& operator=(const XrHandMeshVertexMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshVertexMSFT&() const {
    return *reinterpret_cast<const XrHandMeshVertexMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshVertexMSFT&() { return *reinterpret_cast<XrHandMeshVertexMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandMeshVertexMSFT
  XrHandMeshVertexMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshVertexMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshVertexMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshVertexMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshVertexMSFT{};
    }
    return reinterpret_cast<XrHandMeshVertexMSFT*>(this);
  }
  Vector3f position;
  Vector3f normal;
};
static_assert(sizeof(XrHandMeshVertexMSFT) == sizeof(HandMeshVertexMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshVertexMSFT pointer to const from a
 * HandMeshVertexMSFT reference to const.
 * @relates HandMeshVertexMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexMSFT const* get(HandMeshVertexMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshVertexMSFT as the
 * address of a raw XrHandMeshVertexMSFT
 * @relates HandMeshVertexMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexMSFT* put(HandMeshVertexMSFT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshVertexBufferMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshVertexBufferMSFT>
 * @xrentity{XrHandMeshVertexBufferMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshVertexBufferMSFT {
public:
  //! Constructor initializing all members.
  HandMeshVertexBufferMSFT(const Time& vertexUpdateTime_, uint32_t vertexCapacityInput_,
                           uint32_t vertexCountOutput_, HandMeshVertexMSFT* vertices_)
      : vertexUpdateTime{vertexUpdateTime_},
        vertexCapacityInput{vertexCapacityInput_},
        vertexCountOutput{vertexCountOutput_},
        vertices{vertices_} {}

  //! Default/empty constructor
  HandMeshVertexBufferMSFT(

  ) {}

  //! Default copy constructor
  HandMeshVertexBufferMSFT(const HandMeshVertexBufferMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshVertexBufferMSFT& operator=(const HandMeshVertexBufferMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshVertexBufferMSFT(const XrHandMeshVertexBufferMSFT& rhs) : HandMeshVertexBufferMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshVertexBufferMSFT& operator=(const XrHandMeshVertexBufferMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshVertexBufferMSFT&() const {
    return *reinterpret_cast<const XrHandMeshVertexBufferMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshVertexBufferMSFT&() {
    return *reinterpret_cast<XrHandMeshVertexBufferMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshVertexBufferMSFT
  XrHandMeshVertexBufferMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshVertexBufferMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshVertexBufferMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshVertexBufferMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshVertexBufferMSFT{};
    }
    return reinterpret_cast<XrHandMeshVertexBufferMSFT*>(this);
  }
  Time vertexUpdateTime;
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  HandMeshVertexMSFT* vertices;
};
static_assert(sizeof(XrHandMeshVertexBufferMSFT) == sizeof(HandMeshVertexBufferMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshVertexBufferMSFT pointer to const from a
 * HandMeshVertexBufferMSFT reference to const.
 * @relates HandMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexBufferMSFT const* get(HandMeshVertexBufferMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshVertexBufferMSFT as
 * the address of a raw XrHandMeshVertexBufferMSFT
 * @relates HandMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexBufferMSFT* put(HandMeshVertexBufferMSFT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshMSFT>
 * @xrentity{XrHandMeshMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandMeshMSFT(

      void* next_ = nullptr)
      : Parent(StructureType::HandMeshMSFT, next_) {}

  //! Default copy constructor
  HandMeshMSFT(const HandMeshMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshMSFT& operator=(const HandMeshMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshMSFT(const XrHandMeshMSFT& rhs) : HandMeshMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandMeshMSFT& operator=(const XrHandMeshMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshMSFT&() const { return *reinterpret_cast<const XrHandMeshMSFT*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshMSFT&() { return *reinterpret_cast<XrHandMeshMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandMeshMSFT
  XrHandMeshMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshMSFT*>(this);
  }
  Bool32 isActive;
  Bool32 indexBufferChanged;
  Bool32 vertexBufferChanged;
  HandMeshIndexBufferMSFT indexBuffer;
  HandMeshVertexBufferMSFT vertexBuffer;
};
static_assert(sizeof(XrHandMeshMSFT) == sizeof(HandMeshMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshMSFT pointer to const from a HandMeshMSFT
 * reference to const.
 * @relates HandMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshMSFT const* get(HandMeshMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshMSFT as the address
 * of a raw XrHandMeshMSFT
 * @relates HandMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshMSFT* put(HandMeshMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandPoseTypeInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandPoseTypeInfoMSFT>
 * @xrentity{XrHandPoseTypeInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandPoseTypeInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandPoseTypeInfoMSFT(const HandPoseTypeMSFT& handPoseType_, const void* next_ = nullptr)
      : Parent(StructureType::HandPoseTypeInfoMSFT, next_), handPoseType{handPoseType_} {}

  //! Default/empty constructor
  HandPoseTypeInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::HandPoseTypeInfoMSFT, next_) {}

  //! Default copy constructor
  HandPoseTypeInfoMSFT(const HandPoseTypeInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandPoseTypeInfoMSFT& operator=(const HandPoseTypeInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandPoseTypeInfoMSFT(const XrHandPoseTypeInfoMSFT& rhs) : HandPoseTypeInfoMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandPoseTypeInfoMSFT& operator=(const XrHandPoseTypeInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandPoseTypeInfoMSFT&() const {
    return *reinterpret_cast<const XrHandPoseTypeInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandPoseTypeInfoMSFT&() { return *reinterpret_cast<XrHandPoseTypeInfoMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandPoseTypeInfoMSFT
  XrHandPoseTypeInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandPoseTypeInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandPoseTypeInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandPoseTypeInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandPoseTypeInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandPoseTypeInfoMSFT*>(this);
  }
  HandPoseTypeMSFT handPoseType;
};
static_assert(sizeof(XrHandPoseTypeInfoMSFT) == sizeof(HandPoseTypeInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandPoseTypeInfoMSFT pointer to const from a
 * HandPoseTypeInfoMSFT reference to const.
 * @relates HandPoseTypeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandPoseTypeInfoMSFT const* get(HandPoseTypeInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandPoseTypeInfoMSFT as the
 * address of a raw XrHandPoseTypeInfoMSFT
 * @relates HandPoseTypeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandPoseTypeInfoMSFT* put(HandPoseTypeInfoMSFT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationSessionBeginInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationSessionBeginInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationSessionBeginInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationSessionBeginInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      uint32_t viewConfigurationCount_, const ViewConfigurationType* enabledViewConfigurationTypes_,
      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT, next_),
        viewConfigurationCount{viewConfigurationCount_},
        enabledViewConfigurationTypes{enabledViewConfigurationTypes_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationSessionBeginInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      const SecondaryViewConfigurationSessionBeginInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationSessionBeginInfoMSFT& operator=(
      const SecondaryViewConfigurationSessionBeginInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      const XrSecondaryViewConfigurationSessionBeginInfoMSFT& rhs)
      : SecondaryViewConfigurationSessionBeginInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationSessionBeginInfoMSFT& operator=(
      const XrSecondaryViewConfigurationSessionBeginInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationSessionBeginInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationSessionBeginInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT
  XrSecondaryViewConfigurationSessionBeginInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationSessionBeginInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationSessionBeginInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationSessionBeginInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  const ViewConfigurationType* enabledViewConfigurationTypes;
};
static_assert(sizeof(XrSecondaryViewConfigurationSessionBeginInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationSessionBeginInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT pointer
 * to const from a SecondaryViewConfigurationSessionBeginInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationSessionBeginInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSessionBeginInfoMSFT const* get(
    SecondaryViewConfigurationSessionBeginInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationSessionBeginInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationSessionBeginInfoMSFT
 * @relates SecondaryViewConfigurationSessionBeginInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSessionBeginInfoMSFT* put(
    SecondaryViewConfigurationSessionBeginInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationStateMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationStateMSFT>
 * @xrentity{XrSecondaryViewConfigurationStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SecondaryViewConfigurationStateMSFT(

      void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationStateMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationStateMSFT(const SecondaryViewConfigurationStateMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationStateMSFT& operator=(const SecondaryViewConfigurationStateMSFT& rhs) =
      default;
  //! Copy construct from raw
  SecondaryViewConfigurationStateMSFT(const XrSecondaryViewConfigurationStateMSFT& rhs)
      : SecondaryViewConfigurationStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationStateMSFT& operator=(const XrSecondaryViewConfigurationStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationStateMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationStateMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationStateMSFT
  XrSecondaryViewConfigurationStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationStateMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Bool32 active;
};
static_assert(sizeof(XrSecondaryViewConfigurationStateMSFT) ==
                  sizeof(SecondaryViewConfigurationStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationStateMSFT pointer to const
 * from a SecondaryViewConfigurationStateMSFT reference to const.
 * @relates SecondaryViewConfigurationStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationStateMSFT const* get(
    SecondaryViewConfigurationStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationStateMSFT as the address of a raw XrSecondaryViewConfigurationStateMSFT
 * @relates SecondaryViewConfigurationStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationStateMSFT* put(
    SecondaryViewConfigurationStateMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationFrameStateMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationFrameStateMSFT>
 * @xrentity{XrSecondaryViewConfigurationFrameStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationFrameStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SecondaryViewConfigurationFrameStateMSFT(

      void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationFrameStateMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationFrameStateMSFT(const SecondaryViewConfigurationFrameStateMSFT& rhs) =
      default;
  //! Default copy assignment
  SecondaryViewConfigurationFrameStateMSFT& operator=(
      const SecondaryViewConfigurationFrameStateMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationFrameStateMSFT(const XrSecondaryViewConfigurationFrameStateMSFT& rhs)
      : SecondaryViewConfigurationFrameStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationFrameStateMSFT& operator=(
      const XrSecondaryViewConfigurationFrameStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationFrameStateMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationFrameStateMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationFrameStateMSFT
  XrSecondaryViewConfigurationFrameStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationFrameStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationFrameStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationFrameStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  SecondaryViewConfigurationStateMSFT* viewConfigurationStates;
};
static_assert(sizeof(XrSecondaryViewConfigurationFrameStateMSFT) ==
                  sizeof(SecondaryViewConfigurationFrameStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationFrameStateMSFT pointer to
 * const from a SecondaryViewConfigurationFrameStateMSFT reference to const.
 * @relates SecondaryViewConfigurationFrameStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameStateMSFT const* get(
    SecondaryViewConfigurationFrameStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationFrameStateMSFT as the address of a raw
 * XrSecondaryViewConfigurationFrameStateMSFT
 * @relates SecondaryViewConfigurationFrameStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameStateMSFT* put(
    SecondaryViewConfigurationFrameStateMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationLayerInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationLayerInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationLayerInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationLayerInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationLayerInfoMSFT(const ViewConfigurationType& viewConfigurationType_,
                                          const EnvironmentBlendMode& environmentBlendMode_,
                                          uint32_t layerCount_,
                                          const CompositionLayerBaseHeader* const* layers_,
                                          const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationLayerInfoMSFT, next_),
        viewConfigurationType{viewConfigurationType_},
        environmentBlendMode{environmentBlendMode_},
        layerCount{layerCount_},
        layers{layers_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationLayerInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationLayerInfoMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationLayerInfoMSFT(const SecondaryViewConfigurationLayerInfoMSFT& rhs) =
      default;
  //! Default copy assignment
  SecondaryViewConfigurationLayerInfoMSFT& operator=(
      const SecondaryViewConfigurationLayerInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationLayerInfoMSFT(const XrSecondaryViewConfigurationLayerInfoMSFT& rhs)
      : SecondaryViewConfigurationLayerInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationLayerInfoMSFT& operator=(
      const XrSecondaryViewConfigurationLayerInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationLayerInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationLayerInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationLayerInfoMSFT
  XrSecondaryViewConfigurationLayerInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationLayerInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationLayerInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationLayerInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  EnvironmentBlendMode environmentBlendMode;
  uint32_t layerCount;
  const CompositionLayerBaseHeader* const* layers;
};
static_assert(sizeof(XrSecondaryViewConfigurationLayerInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationLayerInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationLayerInfoMSFT pointer to const
 * from a SecondaryViewConfigurationLayerInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationLayerInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationLayerInfoMSFT const* get(
    SecondaryViewConfigurationLayerInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationLayerInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationLayerInfoMSFT
 * @relates SecondaryViewConfigurationLayerInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationLayerInfoMSFT* put(
    SecondaryViewConfigurationLayerInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationFrameEndInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationFrameEndInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationFrameEndInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationFrameEndInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationFrameEndInfoMSFT(
      uint32_t viewConfigurationCount_,
      const SecondaryViewConfigurationLayerInfoMSFT* viewConfigurationLayersInfo_,
      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationFrameEndInfoMSFT, next_),
        viewConfigurationCount{viewConfigurationCount_},
        viewConfigurationLayersInfo{viewConfigurationLayersInfo_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationFrameEndInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationFrameEndInfoMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationFrameEndInfoMSFT(
      const SecondaryViewConfigurationFrameEndInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationFrameEndInfoMSFT& operator=(
      const SecondaryViewConfigurationFrameEndInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationFrameEndInfoMSFT(
      const XrSecondaryViewConfigurationFrameEndInfoMSFT& rhs)
      : SecondaryViewConfigurationFrameEndInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationFrameEndInfoMSFT& operator=(
      const XrSecondaryViewConfigurationFrameEndInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationFrameEndInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationFrameEndInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationFrameEndInfoMSFT
  XrSecondaryViewConfigurationFrameEndInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationFrameEndInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationFrameEndInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationFrameEndInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  const SecondaryViewConfigurationLayerInfoMSFT* viewConfigurationLayersInfo;
};
static_assert(sizeof(XrSecondaryViewConfigurationFrameEndInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationFrameEndInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationFrameEndInfoMSFT pointer to
 * const from a SecondaryViewConfigurationFrameEndInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationFrameEndInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameEndInfoMSFT const* get(
    SecondaryViewConfigurationFrameEndInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationFrameEndInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationFrameEndInfoMSFT
 * @relates SecondaryViewConfigurationFrameEndInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameEndInfoMSFT* put(
    SecondaryViewConfigurationFrameEndInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationSwapchainCreateInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationSwapchainCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationSwapchainCreateInfoMSFT
    : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const ViewConfigurationType& viewConfigurationType_, const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT, next_),
        viewConfigurationType{viewConfigurationType_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const SecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationSwapchainCreateInfoMSFT& operator=(
      const SecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs)
      : SecondaryViewConfigurationSwapchainCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationSwapchainCreateInfoMSFT& operator=(
      const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationSwapchainCreateInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
  XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationSwapchainCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationSwapchainCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
};
static_assert(sizeof(XrSecondaryViewConfigurationSwapchainCreateInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationSwapchainCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 * pointer to const from a SecondaryViewConfigurationSwapchainCreateInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const* get(
    SecondaryViewConfigurationSwapchainCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationSwapchainCreateInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @relates SecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* put(
    SecondaryViewConfigurationSwapchainCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_EPIC_view_configuration_fov
/*!
 * C++ projection of XrViewConfigurationViewFovEPIC
 *
 * Provided by the `XR_EPIC_view_configuration_fov` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationViewFovEPIC>
 * @xrentity{XrViewConfigurationViewFovEPIC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationViewFovEPIC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ViewConfigurationViewFovEPIC(const Fovf& recommendedFov_, const Fovf& maxMutableFov_,
                               const void* next_ = nullptr)
      : Parent(StructureType::ViewConfigurationViewFovEPIC, next_),
        recommendedFov{recommendedFov_},
        maxMutableFov{maxMutableFov_} {}

  //! Default/empty constructor
  ViewConfigurationViewFovEPIC(

      const void* next_ = nullptr)
      : Parent(StructureType::ViewConfigurationViewFovEPIC, next_) {}

  //! Default copy constructor
  ViewConfigurationViewFovEPIC(const ViewConfigurationViewFovEPIC& rhs) = default;
  //! Default copy assignment
  ViewConfigurationViewFovEPIC& operator=(const ViewConfigurationViewFovEPIC& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationViewFovEPIC(const XrViewConfigurationViewFovEPIC& rhs)
      : ViewConfigurationViewFovEPIC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationViewFovEPIC& operator=(const XrViewConfigurationViewFovEPIC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationViewFovEPIC&() const {
    return *reinterpret_cast<const XrViewConfigurationViewFovEPIC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationViewFovEPIC&() {
    return *reinterpret_cast<XrViewConfigurationViewFovEPIC*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationViewFovEPIC
  XrViewConfigurationViewFovEPIC const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationViewFovEPIC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationViewFovEPIC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationViewFovEPIC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationViewFovEPIC{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationViewFovEPIC*>(this);
  }
  Fovf recommendedFov;
  Fovf maxMutableFov;
};
static_assert(sizeof(XrViewConfigurationViewFovEPIC) == sizeof(ViewConfigurationViewFovEPIC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationViewFovEPIC pointer to const from a
 * ViewConfigurationViewFovEPIC reference to const.
 * @relates ViewConfigurationViewFovEPIC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationViewFovEPIC const* get(
    ViewConfigurationViewFovEPIC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationViewFovEPIC
 * as the address of a raw XrViewConfigurationViewFovEPIC
 * @relates ViewConfigurationViewFovEPIC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationViewFovEPIC* put(ViewConfigurationViewFovEPIC& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EPIC_view_configuration_fov

#ifdef XR_MSFT_holographic_window_attachment
#if defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
/*!
 * C++ projection of XrHolographicWindowAttachmentMSFT
 *
 * Provided by the `XR_MSFT_holographic_window_attachment` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHolographicWindowAttachmentMSFT>
 * @xrentity{XrHolographicWindowAttachmentMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HolographicWindowAttachmentMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HolographicWindowAttachmentMSFT(IUnknown* holographicSpace_, IUnknown* coreWindow_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::HolographicWindowAttachmentMSFT, next_),
        holographicSpace{holographicSpace_},
        coreWindow{coreWindow_} {}

  //! Default/empty constructor
  HolographicWindowAttachmentMSFT(

      const void* next_ = nullptr)
      : Parent(StructureType::HolographicWindowAttachmentMSFT, next_) {}

  //! Default copy constructor
  HolographicWindowAttachmentMSFT(const HolographicWindowAttachmentMSFT& rhs) = default;
  //! Default copy assignment
  HolographicWindowAttachmentMSFT& operator=(const HolographicWindowAttachmentMSFT& rhs) = default;
  //! Copy construct from raw
  HolographicWindowAttachmentMSFT(const XrHolographicWindowAttachmentMSFT& rhs)
      : HolographicWindowAttachmentMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HolographicWindowAttachmentMSFT& operator=(const XrHolographicWindowAttachmentMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHolographicWindowAttachmentMSFT&() const {
    return *reinterpret_cast<const XrHolographicWindowAttachmentMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHolographicWindowAttachmentMSFT&() {
    return *reinterpret_cast<XrHolographicWindowAttachmentMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHolographicWindowAttachmentMSFT
  XrHolographicWindowAttachmentMSFT const* get() const noexcept {
    return reinterpret_cast<XrHolographicWindowAttachmentMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHolographicWindowAttachmentMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHolographicWindowAttachmentMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HolographicWindowAttachmentMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHolographicWindowAttachmentMSFT*>(this);
  }
  IUnknown* holographicSpace;
  IUnknown* coreWindow;
};
static_assert(sizeof(XrHolographicWindowAttachmentMSFT) == sizeof(HolographicWindowAttachmentMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHolographicWindowAttachmentMSFT pointer to const from a
 * HolographicWindowAttachmentMSFT reference to const.
 * @relates HolographicWindowAttachmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHolographicWindowAttachmentMSFT const* get(
    HolographicWindowAttachmentMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * HolographicWindowAttachmentMSFT as the address of a raw XrHolographicWindowAttachmentMSFT
 * @relates HolographicWindowAttachmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHolographicWindowAttachmentMSFT* put(HolographicWindowAttachmentMSFT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_holographic_window_attachment

#ifdef XR_VALVE_analog_threshold
/*!
 * C++ projection of XrInteractionProfileAnalogThresholdVALVE
 *
 * Provided by the `XR_VALVE_analog_threshold` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileAnalogThresholdVALVE>
 * @xrentity{XrInteractionProfileAnalogThresholdVALVE}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileAnalogThresholdVALVE : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InteractionProfileAnalogThresholdVALVE(const Action& action_, const Path& binding_,
                                         float onThreshold_, float offThreshold_,
                                         const HapticBaseHeader* onHaptic_,
                                         const HapticBaseHeader* offHaptic_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileAnalogThresholdVALVE, next_),
        action{action_},
        binding{binding_},
        onThreshold{onThreshold_},
        offThreshold{offThreshold_},
        onHaptic{onHaptic_},
        offHaptic{offHaptic_} {}

  //! Default/empty constructor
  InteractionProfileAnalogThresholdVALVE(

      const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileAnalogThresholdVALVE, next_) {}

  //! Default copy constructor
  InteractionProfileAnalogThresholdVALVE(const InteractionProfileAnalogThresholdVALVE& rhs) =
      default;
  //! Default copy assignment
  InteractionProfileAnalogThresholdVALVE& operator=(
      const InteractionProfileAnalogThresholdVALVE& rhs) = default;
  //! Copy construct from raw
  InteractionProfileAnalogThresholdVALVE(const XrInteractionProfileAnalogThresholdVALVE& rhs)
      : InteractionProfileAnalogThresholdVALVE() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileAnalogThresholdVALVE& operator=(
      const XrInteractionProfileAnalogThresholdVALVE& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileAnalogThresholdVALVE&() const {
    return *reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileAnalogThresholdVALVE&() {
    return *reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionProfileAnalogThresholdVALVE
  XrInteractionProfileAnalogThresholdVALVE const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileAnalogThresholdVALVE.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileAnalogThresholdVALVE* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileAnalogThresholdVALVE{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE*>(this);
  }
  Action action;
  Path binding;
  float onThreshold;
  float offThreshold;
  const HapticBaseHeader* onHaptic;
  const HapticBaseHeader* offHaptic;
};
static_assert(sizeof(XrInteractionProfileAnalogThresholdVALVE) ==
                  sizeof(InteractionProfileAnalogThresholdVALVE),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileAnalogThresholdVALVE pointer to const
 * from a InteractionProfileAnalogThresholdVALVE reference to const.
 * @relates InteractionProfileAnalogThresholdVALVE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileAnalogThresholdVALVE const* get(
    InteractionProfileAnalogThresholdVALVE const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionProfileAnalogThresholdVALVE as the address of a raw
 * XrInteractionProfileAnalogThresholdVALVE
 * @relates InteractionProfileAnalogThresholdVALVE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileAnalogThresholdVALVE* put(
    InteractionProfileAnalogThresholdVALVE& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VALVE_analog_threshold

#ifdef XR_FB_display_refresh_rate
/*!
 * C++ projection of XrEventDataDisplayRefreshRateChangedFB
 *
 * Provided by the `XR_FB_display_refresh_rate` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataDisplayRefreshRateChangedFB>
 * @xrentity{XrEventDataDisplayRefreshRateChangedFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataDisplayRefreshRateChangedFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Constructor initializing all members.
  EventDataDisplayRefreshRateChangedFB(float fromDisplayRefreshRate_, float toDisplayRefreshRate_,
                                       const void* next_ = nullptr)
      : Parent(StructureType::EventDataDisplayRefreshRateChangedFB, next_),
        fromDisplayRefreshRate{fromDisplayRefreshRate_},
        toDisplayRefreshRate{toDisplayRefreshRate_} {}

  //! Default/empty constructor
  EventDataDisplayRefreshRateChangedFB(

      const void* next_ = nullptr)
      : Parent(StructureType::EventDataDisplayRefreshRateChangedFB, next_) {}

  //! Default copy constructor
  EventDataDisplayRefreshRateChangedFB(const EventDataDisplayRefreshRateChangedFB& rhs) = default;
  //! Default copy assignment
  EventDataDisplayRefreshRateChangedFB& operator=(const EventDataDisplayRefreshRateChangedFB& rhs) =
      default;
  //! Copy construct from raw
  EventDataDisplayRefreshRateChangedFB(const XrEventDataDisplayRefreshRateChangedFB& rhs)
      : EventDataDisplayRefreshRateChangedFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataDisplayRefreshRateChangedFB& operator=(
      const XrEventDataDisplayRefreshRateChangedFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataDisplayRefreshRateChangedFB&() const {
    return *reinterpret_cast<const XrEventDataDisplayRefreshRateChangedFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataDisplayRefreshRateChangedFB&() {
    return *reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataDisplayRefreshRateChangedFB
  XrEventDataDisplayRefreshRateChangedFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataDisplayRefreshRateChangedFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataDisplayRefreshRateChangedFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataDisplayRefreshRateChangedFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB*>(this);
  }
  float fromDisplayRefreshRate;
  float toDisplayRefreshRate;
};
static_assert(sizeof(XrEventDataDisplayRefreshRateChangedFB) ==
                  sizeof(EventDataDisplayRefreshRateChangedFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataDisplayRefreshRateChangedFB pointer to const
 * from a EventDataDisplayRefreshRateChangedFB reference to const.
 * @relates EventDataDisplayRefreshRateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataDisplayRefreshRateChangedFB const* get(
    EventDataDisplayRefreshRateChangedFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataDisplayRefreshRateChangedFB as the address of a raw
 * XrEventDataDisplayRefreshRateChangedFB
 * @relates EventDataDisplayRefreshRateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataDisplayRefreshRateChangedFB* put(
    EventDataDisplayRefreshRateChangedFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataDisplayRefreshRateChangedFB as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataDisplayRefreshRateChangedFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataDisplayRefreshRateChangedFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_color_space
/*!
 * C++ projection of XrSystemColorSpacePropertiesFB
 *
 * Provided by the `XR_FB_color_space` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemColorSpacePropertiesFB>
 * @xrentity{XrSystemColorSpacePropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemColorSpacePropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemColorSpacePropertiesFB(

      void* next_ = nullptr)
      : Parent(StructureType::SystemColorSpacePropertiesFB, next_) {}

  //! Default copy constructor
  SystemColorSpacePropertiesFB(const SystemColorSpacePropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemColorSpacePropertiesFB& operator=(const SystemColorSpacePropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemColorSpacePropertiesFB(const XrSystemColorSpacePropertiesFB& rhs)
      : SystemColorSpacePropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemColorSpacePropertiesFB& operator=(const XrSystemColorSpacePropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemColorSpacePropertiesFB&() const {
    return *reinterpret_cast<const XrSystemColorSpacePropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemColorSpacePropertiesFB&() {
    return *reinterpret_cast<XrSystemColorSpacePropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemColorSpacePropertiesFB
  XrSystemColorSpacePropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemColorSpacePropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemColorSpacePropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemColorSpacePropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemColorSpacePropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemColorSpacePropertiesFB*>(this);
  }
  ColorSpaceFB colorSpace;
};
static_assert(sizeof(XrSystemColorSpacePropertiesFB) == sizeof(SystemColorSpacePropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemColorSpacePropertiesFB pointer to const from a
 * SystemColorSpacePropertiesFB reference to const.
 * @relates SystemColorSpacePropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemColorSpacePropertiesFB const* get(
    SystemColorSpacePropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemColorSpacePropertiesFB
 * as the address of a raw XrSystemColorSpacePropertiesFB
 * @relates SystemColorSpacePropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemColorSpacePropertiesFB* put(SystemColorSpacePropertiesFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_color_space
}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_STRUCTS_HPP_
